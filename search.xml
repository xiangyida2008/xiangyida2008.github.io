<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[exkmp 笔记]]></title>
    <url>%2F2020%2F05%2F04%2Fexkmp-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[exkmp 用于求解这样的问题： 求文本串 $T$ 的每一个后缀与模式串 $M$ 的匹配长度（即最长公共前缀长度）。特别的，取 $M=T$，得到的这个长度被称为 $Z$ 函数。“函数”只是一个叫法，它本质上是个数组…为了好听，后面叫他“$Z$ 数组” （互联网上的确有人这么叫） 符号(字符串)$|S|$ 表示 $S$ 的长度 $S[l:r]$ 表示 $S$ 从 $l$ 到 $r$ 的子串。如果 $l$ 空着，默认为 $1$；同理 $r$ 默认为 $|S|$。 也就是 $S[:x]$ 表示 $S$ 到 $x$ 结束的前缀，$S[x:]$ 表示 $S$ 从 $x$ 开始的后缀。 $LCP(S_1,S_2)$ 表示 $S_1,S_2$ 的 最长公共前缀 （Longest Common Prefix） 算法讲解设 $p_i=LCP(T_i,M)$ 定义从 $l$ 开始的匹配区间为 $[l,l+p_l-1]$ （设 $l+p_l-1=r$） 我们枚举处理。假设现在已经求好了 $[1,i-1]$ 的 $p$ 数组，要求 $p_i$。记录一个 最靠后 的匹配区间 $[l,r]$ （$l&lt;i$，以 $r$ 靠后为第一关键字，$l$ 靠后为第二关键字），考虑直接从 $[l,r]$ 中继承点答案来，那很显然一个前提就是 $i\le r$ （你 $i$ 在 $r$ 外面继承啥） 显然，$p_i\ge LCP(T[i:r],M)$ （因为 $T[i:r]$ 是 $T[i:]$ 前缀） 由定义， $[l,r]$ 是最长匹配长度，可知 $T[l:r]=M[1:r-l+1]$。 然后现在假如 $l&lt;i\le r$，那么显然 $T[i:r]=M[i-l+1:r-l+1]$ 那么 $LCP(T[i:r],M)=LCP(M[i-l+1:r-l+1],M)$ 简单想一下，$LCP(A[l:r],A)=min(LCP(A[l:],A),r-l+1)$ 我们要求 $[l,r]$ 子串与整个串的 $LCP$，可以先求以 $l$ 开头的整个后缀的与整个串的 $LCP$，然后和区间长度取 $min$。这显然正确。 然后有： $LCP(M[i-l+1:r-l+1],M)=min(LCP(M[i-l+1:],M),(r-l+1)-(i-l+1+1))$ 右边的 $-l+1$ 两个抵消了，就变成 $r-i+1$ 然后前面是 $LCP(M[i-l+1:],M)$ 。这不就是 $M$ 的 $Z$ 数组的第 $i-l+1$ 个位置吗！（还记得 $Z$ 数组的定义吗？） 觉得看字母理解不了的看图（自己画的）（纯鼠标）： 红色的部分就是我们推出来的匹配部分。然后现在我们把 $M$ 移到 $i$ 开头的位置来匹配，就相当于把 $M[i-l+1:r-l+1]$ 这一段（红色）移到 $M$ 的开头处匹配。这一段匹配的长度就是 $min(Z_{i-l+1},r-i+1)$。 假设我们现在能求这个 $Z$ 数组，那么我们已经知道 $p_i$ 的最小值了 ，就是 $min(Z_{i-l+1},r-i+1)$ 。从这个位置开始暴力即可。这样就不用每次从 $1$ 开始匹配了。 求完 $p_i$ 之后，记得用 $[i,i+p_i-1]$ 更新 $[l,r]$。 时间是线性的，我不会证，可以参考网上的证明。 如何求 Z 数组我们发现 $Z$ 数组就是自己和自己匹配的过程。然后我们把上面过程中 $M$ 换成 $T$ 即可。 所以我们还是记录一个最靠后的匹配区间 $[l,r]$，然后 $p_i$ 就相当于 $Z_i$ 了。 易得： $Z_i=min(LCP(M[i-l+1:],M),r-i+1)=min(LCP(T[i-l+1:],T),r-i+1)=min(Z_{i-l+1},r-i+1)$ 求完 $Z_i$ 之后，记得用 $[i,i+Z_i-1]$ 来更新 $[l,r]$。 一样，也是从这里开始暴力即可。时间复杂度依然是线性的，可以参考网上的证明。 模板洛谷板子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;#define N 20000007#define F(i,l,r) for(int i=l;i&lt;=r;++i)#define D(i,r,l) for(int i=r;i&gt;=l;--i)#define Fs(i,l,r,c) for(int i=l;i&lt;=r;c)#define Ds(i,r,l,c) for(int i=r;i&gt;=l;c)#define MEM(x,a) memset(x,a,sizeof(x))#define FK(x) MEM(x,0)#define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))#define p_b push_back#define sz(a) ((int)a.size())#define all(a) a.begin(),a.end()#define iter(a,p) (a.begin()+p)#define Flandre_Scarlet int#define IsMyWife mainchar _c;int I()&#123; int x=0; int f=1; while(_c&lt;'0' or _c&gt;'9') f=(_c=='-')?-1:1,_c=getchar(); while(_c&gt;='0' and _c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(_c^48),_c=getchar(); return (x=(f==1)?x:-x);&#125;void Rd(int cnt,...)&#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args);&#125;char a[N],b[N];void Input()&#123; scanf("%s%s",a+1,b+1);&#125;int z[N];void Z(char s[]) // 求 Z 函数&#123; int n=strlen(s+1); z[1]=n; F(i,2,n) z[i]=0; // Z[1]=n 特判，同时也是递推边界 int l=0,r=0; F(i,2,n) &#123; if (i&lt;=r) z[i]=min(z[i-l+1],r-i+1); // 推理出下界 while(i+z[i]&lt;=n and s[i+z[i]]==s[z[i]+1]) ++z[i]; // 暴力 if (i+z[i]-1&gt;=r) l=i,r=i+z[i]-1; // 更新最靠后的匹配位置 &#125;&#125;int p[N];void ExKmp(char s[],char t[])&#123; int n=strlen(s+1); Z(t); int l=0,r=0; F(i,1,n) &#123; if (i&lt;=r) p[i]=min(z[i-l+1],r-i+1); // 推理出下界 while(i+p[i]&lt;=n and s[i+p[i]]==t[p[i]+1]) ++p[i]; // 暴力 if (i+p[i]-1&gt;r) l=i,r=i+p[i]-1; // 更新最靠后的匹配位置 &#125;&#125;void Soviet()&#123; ExKmp(a,b); int n=strlen(a+1),m=strlen(b+1); long long ans=0; F(i,1,m) ans^=1ll*i*(z[i]+1); printf("%lld\n",ans); ans=0; F(i,1,n) ans^=1ll*i*(p[i]+1); printf("%lld\n",ans);&#125;Flandre_Scarlet IsMyWife()&#123; Input(); Soviet(); getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>思维</tag>
        <tag>exkmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五边形数 笔记]]></title>
    <url>%2F2020%2F05%2F02%2F%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[近日，一国外小哥学习了这个定理，竟然能预处理出整数划分的方案数！快跟小编来看看吧 这个小哥学习的定理，就是小编（我）接下来要讲的五边形数定理 好的，让我们一起来看看这个定理吧 五边形数是啥百度百科 用图来讲，就是若干个点，排成若干个五边形，需要多少个点。 百度百科上有一个很清楚的图： 它的通项公式为 $a_n=\dfrac{n(3n-1)}{2}$，前面几项是 $0, 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, 176, 210…$。你可以在 OEIS 上找到它，是序列 A000326 我们要研究的是 广义五边形数，是这样一个数列：$p=a_0,a_{1},a_{-1},a_{2},a_{-2}…$ 其中，如果 $p$ 的下标是负数，照样代入到上面的通项公式里算即可。容易证明，当 $n&lt;0$ 时，$p_n$ 也是正的。前面几项是 $0, 1, 2, 5, 7, 12, 15, 22, 26, 35, 40, 51, 57, 70, 77, 92, 100, 117…$，同样可以在 OEIS 上找到它是 A001318 它能干啥欧拉函数（五边形数）（为了和欧拉数论函数区别开来，这里给它起名叫欧拉函数-五边形数(*/ω＼*) 是这样一个函数：$\varphi(x)=(1-x)(1-x^2)(1-x^3)(1-x^4)…(1-x^inf)=\prod\limits_{i=1}^{inf} (1-x^i)$ 这东西有一个很神奇的性质。如果你闲的没事，可以暴力拆开它，发现它等于 $x^0-x^1-x^2+x^5+x^7-x^{12}-x^{15}+x^{22}+x^{26}…=\sum\limits_{i=1}^{inf} (-1)^{(i+1)/2} x^{p_i}$ 系数：一个正，两个负，两个正，两个负，两个正，两个负… 指数：广义五边形数 与整数划分问题的联系然后我们可以来解决整数划分问题。设 $P(n)$ 表示将 $n$ 分成若干个整数的无序方案（即，$a+b$ 和 $b+a$ 只算一次），同一个数可以用很多次。 比如，$P(4)=5$，因为 $4$ $=1+1+1+1$ $=1+1+2$ $=1+3$ $=2+2$ $=4$ 特殊地，$P(0)=1$ 我们求出 $P(n)$ 的生成函数 $f(x)=\sum\limits_{n=0}^{inf} P(n)x^n$ 给它换个定义：我们要选出若干个（可以是 $0$ 个） $1$，若干个 $2$，若干个 $3$…使得选出来的所有数和为 $n$。 这样就好考虑了。看这个式子： $(1+x+x^2+x^3…)(1+x^2+(x^2)^2+(x^2)^3…)(1+x^3+(x^3)^2+(x^3)^3…)…$ 第一个因式表示我们能随便选择用多少个 $x^1$ 第二个因式表示我们能随便选择用多少个 $x^2$ … 乘起来之后，考虑 $x^n$ 的系数，你会发现它就是 $P(n)$！是不是特别巧妙φ(&gt;ω&lt;*) 于是 $f(x)=(1+x+x^2+x^3…)(1+x^2+(x^2)^2+(x^2)^3…)(1+x^3+(x^3)^2+(x^3)^3…)…=\prod\limits_{n=1}^{inf} \sum\limits_{i=0}^{inf} (x^n)^i$ 然后我们用等比数列求和公式化一下，得到： $f(x)=\prod\limits_{n=1}^{inf} \dfrac{1}{1-x^n}$ 我们发现它就是欧拉函数-五边形数的倒数(/≧▽≦/)！ 即 $\varphi(x)f(x)=1$ 也就是 $(1-x-x^2+x^5+x^7-x^{12}-x^{15}…)(\sum\limits_{n=0}^{inf} P(n)x^n)=1$ 观察其中 $x^n$ 项的系数（分别考虑左边和右边的括号出的是几次项），容易发现这个系数应该是 $P(n)-P(n-1)-P(n-2)+P(n-5)+P(n-7)…$ $n=0$ 时，这个式子显然为 $1$。那么 $n&gt;0$ 时， $x^n$ 乘以它的系数的和就得是 $0$ 了。 然后我们发现等式右边是 $1$。并且原式为恒等式，所以 $x$ 取任何值都成立。为了让 $x$ 取任何值时等式都成立，对于 $n&gt;0$ 时，$P(n)-P(n-1)-P(n-2)$ 这个可怜的等式只好取 $0$ 了。 然后就得到了： $P(n)-P(n-1)-P(n-2)+P(n-5)+P(n-7)-P(n-12)-P(n-15)…=0$ 于是 $P(n)=P(n-1)+P(n-2)-P(n-5)-P(n-7)+P(n-12)+P(n-15)…$ 然后 $\le n$ 的五边形数是 $\sqrt{n}$ 级别的（注意到五边形数的通项公式是二次的） 于是我们可以递推出 $P(n)$，是 $O(n\sqrt{n})$ 的，是不是很厉害呢(✪ω✪) 好了，以上就是这个定理的全部内容了，喜欢记得收藏起来哟]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>五边形数定理</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1231E Middle Out 题解]]></title>
    <url>%2F2020%2F05%2F02%2FCodeforces-1231E-Middle-Out-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述（$q$ 组数据）你有两个串，$s$ 和 $t$，长度都是 $n$。现在你可以对 $s$ 做若干次操作：选择某一个字符，把它移到最前面或者最后面（二选一）。 你现在要把 $s$ 变成 $t$，请问最少需要多少步操作。不行输出 $-1$。 $1\le q,n\le100$。 思路先放结论：求出最长的串 $a$ 使得 $a$ 是 $s$ 的子序列（不一定连续），并且是 $t$ 的子串（必须连续），答案是 $n-|a|$，$|a|$ 表示 $a$ 的长度 怎么想到的首先我们发现能任意从中间取字符放到首尾，根据某些直觉，我们发现：把不同的往两边放，把相同的留在中间对齐。 那么留在中间的“相同的”部分，想一想，应该是某一段公共子序列。 这一段公共子序列一定是最长公共子序列吗？不一定，发现我们 只能 对 $s$ 操作，不能动 $t$，所以这段公共子序列在 $t$ 中必须是连续的，不能有断开的。 就比如说样例第一个里面的第三组数据，$s=\texttt{“tste”}$，$t=\texttt{“test”}$，最长公共子序列应该是 $\texttt{“tst”}$，长度为 $3$。可是剩下的那一个字符 $\texttt{e}$ 并不能直接归位，因为要让它归位必须去动 $t$，但是我们只能动 $s$。最优策略应该是把 $\texttt{“st”}$ 放在中间，然后把 $\texttt{t}$ 和 $\texttt{e}$ 动两次归位。 然后现在还有一个问题：移动次数一定是 $n-|a|$ 吗？也就是说，剩下的 $n-|a|$ 个不同的恰好一定能在 $n-|a|$ 步之内归位？ 分两步证，先证一定不小于这个数，然后证可以做到 $n-|a|$ 步，又因为我们要步数最小，就只能恰好是这个答案了。 一定不小于：如果能小于，那么我们的最长公共子序列 $a$ 就能变的更长了。所以一定不会小于这个数。 一定能取到：在 $t$ 中，由于 $a$ 是一个子串，于是 $t$ 中和 $s$ 不匹配的地方，就是 $t$ 中抠掉 $a$ 剩下的部分，一定是一段前缀加一点后缀。先从右到左遍历剩下的前缀，在 $s$ 中找一个相等的，放到最前面来。再从左到右遍历剩下的后缀，在 $s$ 中找一个相等的，放到最后面来。然后这个步数显然可以做到 $n-|a|$ 步。（附：关于这个从左到右还是从右到左，可以简单的概括为：从里到外）（为啥是从里到外，可以自己手玩一下） 怎么求枚举这一段公共子序列在 $t$ 中的起点，然后写两个指针，匹配一下即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;#define N 122#define F(i,l,r) for(int i=l;i&lt;=r;++i)#define D(i,r,l) for(int i=r;i&gt;=l;--i)#define Fs(i,l,r,c) for(int i=l;i&lt;=r;c)#define Ds(i,r,l,c) for(int i=r;i&gt;=l;c)#define MEM(x,a) memset(x,a,sizeof(x))#define FK(x) MEM(x,0)#define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))#define p_b push_back#define sz(a) ((int)a.size())#define all(a) a.begin(),a.end()#define iter(a,p) (a.begin()+p)#define Flandre_Scarlet int#define IsMyWife mainchar _c;int I()&#123; int x=0; int f=1; while(_c&lt;'0' or _c&gt;'9') f=(_c=='-')?-1:1,_c=getchar(); while(_c&gt;='0' and _c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(_c^48),_c=getchar(); return (x=(f==1)?x:-x);&#125;void Rd(int cnt,...)&#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args);&#125;int n;string a,b;void Input()&#123; n=I(); cin&gt;&gt;a&gt;&gt;b;&#125;void Soviet()&#123; int ans=1e9; F(i,0,n-1) &#123; int pos=i; F(j,0,n-1) if (pos&lt;n and b[pos]==a[j]) ++pos; // pos 表示在 t 中的位置，j 表示在 s 中的位置 // pos-i 就是求出来的长度 ans=min(ans,n-(pos-i)); &#125; sort(all(a)); sort(all(b)); if (a!=b)&#123;puts("-1");return;&#125; // 判一下无解 printf("%d\n",ans);&#125;Flandre_Scarlet IsMyWife()&#123; int t=I(); F(i,1,t) &#123; Input(); Soviet(); &#125; getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cdq分治 笔记]]></title>
    <url>%2F2020%2F05%2F02%2Fcdq%E5%88%86%E6%B2%BB-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[算法讲解这个算法用于解决三维偏序问题。 三维偏序：给定 $n$ 个三元组： $(a_i,b_i,c_i)$，求同时满足满足 $a_i\le a_j,b_i\le b_j,c_i\le c_j$ 的 $(i,j)$ 的数量。 那这该咋求呢⊙(・◇・)？ 先把维度降下来，二维偏序，会不会做？就是求多少个 $(i,j)$ 满足 $a_i\le a_j,b_i\le b_j$。 显然，先按照 $a$ 排一下序。然后就变成了 $i&lt;j,b_i\le b_j$ 的问题了。可以用树状数组做。最典型的案例就是逆序对问题，这个都写熟练了哈(*╹▽╹*) 三维偏序的问题，也是先按 $a$ 排一下序。然后接下来的问题考虑分治（这样的分治过程被我们称为“cdq分治”） 假设我们要求 $[l,r]$ 中的答案。已经求好了 $[l,mid],[mid+1,r]$ 中的答案，现在只需要考虑跨区的答案了。 那么我们可以把 $[l,mid]$ 和 $[mid+1,r]$ 内部都按照 $b$ 排序。因为我们只要考虑跨区的答案，那么我们把两边分别都随便排序，对跨区的时候 $a$ 的大小关系没有影响。然后我们在 $[mid+1,r]$ 中枚举一个元素 $j$，找到在 $[l,mid]$ 中有多少个 $i$ 满足 $b_i\le b_j$，然后这个 $i$ 显然是递增的。然后我们一边单调的维护这个 $i$ ，一边用树状数组维护 $c_i\le c_j$ 的数量即可。 板子洛谷3810 陌上花开 （↑代码找我老婆要）（那张图是一个链接(*^▽^*)）（偷偷测试功能）]]></content>
      <tags>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树优化建图 笔记]]></title>
    <url>%2F2020%2F04%2F19%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[算法讲解其实不用讲，看标题就知道这大概是一个什么样的算法了。 它用来解决这样类型的问题：你要支持，从一个点往一个区间中的所有点连一条边，或者一个区间中的所有点连一条边（有向）。 然后你就要进行一些 最短路/强连通分量/最大流 等图论基本操作了。 那么这个咋整呢（⊙.⊙） 假设我们现在是从第 ⑨ 个点向 $[3,6]$ 区间中的所有点连边。可以如下图处理： 先建一颗线段树，这颗线段树上的每一个非叶子节点都向它的两个儿子连了一条有向边。 接着，我们把 $[3,6]$ 在线段树上拆分一下，变成 $[3,4]+[5,6]$。然后我们从 $9$ 连到线段树节点 $[3,4]$，还有 $[5,6]$，这样就可以 $O(\log n)$ 的时空复杂度实现一次区间连边了，是不是很神奇呢~~(✪ω✪) （我当时是被这个算法骚到了，吓的我目瞪口呆） 那么这个父子之间的有向边，边权多少呢？首要原则是，不能影响答案，比如你要求最大流，那么影响答案的就是路径最小值，此时要把边权都设置为 $INF$。如果是求最短路，那影响答案的就是路径和，此时把边权设置为 $0$ 就好了 (*^▽^*) 然后我们怎么从区间连向点呢？我们再建一颗树，这颗树的父子边是从儿子到父亲的有向边。然后再把区间拆分一下即可，和上面基本一样，就是反个方向☆daze~ 还是那句话（韩信带净化），只有你们想不到，没有出题人出不到，咱们去挑战一把毒瘤例题咯 ~❤ 起飞T1. 超级经典のCF786B Legacy（诶诶诶别吓我嗷，B 题就 *2600？ （对，没错，这就是 div.1 的神仙，自闭了 o(╥﹏╥)o 这题基本就是板子了（板子也毒瘤的要死），支持 $m$ 个三种形式的连边操作： 有向边 $u\xrightarrow[w]{\qquad} v$ 区间连点 $[l,r]\xrightarrow[w]{\qquad} u$ 点连区间 $u\xrightarrow[w]{\qquad} [l,r]$ 然后给你源点 $S$，求 $S$ 到每个点的最短路。 $n,m\le 10^5,w\le 10^9$，其余所有操作保证有意义且合法 然后，$m$ 指的是连边 操作 的数量，并不代表边数！ （边数可能会到 $O(n^2)$ 级别，存不下 题解就像上面那样，开两颗线段树，然后连边即可。我们管从父亲到儿子连边的线段树叫“入树”，即 $T_{in}$。它用来存储 $u\xrightarrow[w]{\qquad} [l,r]$ 形式的边。同理，另一颗叫“出树”，即 $T_{out}$。设 $T[l,r]$ 表示线段树 $T$ 上代表区间 $[l,r]$ 的节点。 对于 $u\xrightarrow[w]{\qquad} [l,r]$ 的边，就连边 $T_{out}[u,u]\xrightarrow[w]{\qquad}T_{in}[l,r]$。 同理，对于 $[l,r]\xrightarrow[w]{\qquad} u$ 的边，就连边 $T_{out}[l,r]\xrightarrow[w]{\qquad}T_{in}[u,u]$ 还有，两颗线段树对应的叶子节点本质上是同一个 点，所以要连 $n$ 条边权为 $0$ 的无向边，把这些叶子节点合并起来。即，对于每个 $i$，连边 $T_{out}[i,i]\xrightarrow[0]{\qquad}T_{in}[i,i]$ 然后从 $T_{out}[s,s]$ 跑一遍最短路即可。最后输出记得输出 $dis[T_{in}[i,i]]$。 代码 注意刚接触的时候，一定要想清楚 入树 和 出树！ （不建议背，要好好理解，看不懂的私信我 T2. libreoj2255戳我 中文超短题意，我就不概括了。 题解显然，每个能引爆的所有炸弹，最后是要连续的 对于每个点，向它能一步引爆的炸弹连一条有向边（点到区间连边，这一步用线段树优化） 然后维护它能到的点中，最小和最大的编号即可。这个可以 Tarjan 缩点后一遍 DFS 求出来。 然后就是硬上了… 这题比上面水的是，不用注意出树和入树，这题就一个入树… 代码]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>线段树优化建图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4962 简单的字符串 题解]]></title>
    <url>%2F2020%2F04%2F19%2Fbzoj-4962-%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给你一个长度为 $n$ 的数组 $a$，问你有多少个区间，满足： 长度为偶数 前一半和后一半循环同构 $n\le 5000,a_i\le 5000$ 思路两个串 $a,b$ 循环同构 ，那么一定可以把 $a$ 分成两个串 $u,v$ 接起来，然后把 $b$ 表示成 $v,u$ 的形式。 就比如 $a=\texttt{“abcde”},b=\texttt{“cdeab”}$，那么 $a=\texttt{“ab”+”cde”},b=\texttt{“cde”+”ab”}$。 然后现在这两个串相邻了，也就是有一段连续的 $uv|vu$ 的形式。考虑枚举中间这个划分线，然后计算两边有多少满足条件的。这也许能用哈希水过，但是我们要想一个正经办法(*^▽^*) 一般我们遇到这样的“分块回文” 的问题，都是怎么做的呢⊙(・◇・)？ 联想一下 codeforces 932G 这个题，我们可以把前面一半的 $uv$ 反过来，然后一个隔一个的插入到后半边的 $vu$ 里面去。这样插入完就会变成两个长度为偶数的回文串拼在一起啦 (/≧▽≦/) 点击 关于它为啥会变成这样先考虑一个串的情况。现在有一个 $u$，假设它由三个字符 $a,b,c$ 构成。我们把它反过来，然后一个隔一个的插入，变成： $\color{red} c\color{black}a \color{red} b \color{black} b \color{red} a \color{black} c$ 新插入的用红色表示，原来就有的用黑色表示。然后我们发现它变成了一个回文串！ 容易归纳证明，无论它长度多少，这样子做总会变成一个回文串。 然后考虑两个串 $u,v$ 拼一块的情况。我们把 $u+v$ 反过来，一个隔一个的插入到 $v+u$ 中，会变成什么呢？ 设 $s’$ 是 $s$ 反过来的串。然后显然 $(u+v)’=v’+u’$。我们把它插入到 $v+u$ 中之后，前面 $|v|$ 个串会先变成一个长度为 $2|v|$ 的回文串，后面还有 $|u|$ 个串，会变成长度为 $2|u|$ 的回文串。于是总体就变成了一个长度为 $2|v|+2|u|$ 的两个偶数长度回文串。 举个例子，$u=\texttt{“ab”},v=\texttt{“cd”}$，这样插入完之后变成 这样：公式炸了，点我 它等于 $\texttt{“dccd”}+\texttt{“baab”}$。 （你们可能不知道这公式有多难打，就为了举个形象的例子… 唉o(╥﹏╥)o） 然后我们只需要用 Manacher 统计一下有多少个这样的回文串即可（～￣▽￣～） 设 $pre[i]$ 表示从 $i$ 往前最多能跳多少长度，使得跳过的部分是回文串。然后 $f[i]$ 是回文中心。 用 $last$ 记录上一个回文前缀的位置。当前位置在 $i$ ，如果 $[last,i]$ 是个回文串，或者 $[i-pre[i]+1,i]$ 是个回文串，那么当前的 $i$ 就是合法的~☆，答案 ++。 那么如何判断 $[l,r]$ 是不是回文串呢⊙(・◇・)？设 $mid=(l+r)/2$，看看是否满足 $f[mid]\ge (r-l+1)/2$ 即可。 代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 14444 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) int I() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args); &#125; int n; int a[N]; void Input() &#123; n=I(); F(i,1,n) a[i]=I(); &#125; int s[N]; int f[N],pre[N]; int calc(int p) &#123; int l=p,r=p+1; int cnt=0; while(l&gt;=1 and r&lt;=n) s[++cnt]=a[l],s[++cnt]=a[r],--l,++r; F(i,0,cnt+1) f[i]=pre[i]=0; int id=1,Max=1; F(i,1,cnt) &#123; f[i]=min(max(Max-i,0),f[id+(id-i)]); while(i+f[i]+1&lt;=n and i-f[i]&gt;0 and s[i+f[i]+1]==s[i-f[i]]) ++f[i]; if (i+f[i]&gt;=Max) Max=i+f[i],id=i; pre[i+f[i]]=max(pre[i+f[i]],f[i]); &#125; D(i,cnt,1) pre[i]=max(pre[i],pre[i+1]-1); Ds(i,cnt,1,i-=2) pre[i]*=2; int ans=0,last=0; Fs(i,2,cnt,i+=2) &#123; if (f[i/2]==i/2) last=i; if (f[(i+last)/2]&gt;=(i-last)/2 or f[(i-pre[i])/2]&gt;=(i-pre[i])/2) ++ans; &#125; return ans; &#125; void Soviet() &#123; int ans=0; F(i,1,n-1) ans+=calc(i); printf("%d\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libreoj 6192 「美团 CodeM 复赛」城市网络 题解]]></title>
    <url>%2F2020%2F04%2F19%2Flibreoj-6192-%E3%80%8C%E7%BE%8E%E5%9B%A2-CodeM-%E5%A4%8D%E8%B5%9B%E3%80%8D%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述有 $n$ 个城市，组成一张树形网络。第 $i$ 个城市售卖价值为 $a_i$ 的珠宝。zps 的父母计划了 $q$ 次行程。每次先带上价值为 $c$ 的珠宝，从城市 $u$ 走到城市 $v$ （保证 $v$ 在 $u$ 到 $1$ 的路径上）。如果当前的城市售卖的珠宝比手头的贵（严格大于，等于不行），那么 zps 的父母会买入这个珠宝。 对于每次行程，求出 zps 的父母进行了多少次“买入”操作。 $n,q,c,a_i\le 10^5$，$1\le u,v\le n$ 思路我们发现，对于每一次行程，除了第一次要特判一下之外，我下一次走到哪里应该是固定的。 假设我们当前在 $u$，那么我们下一次走的位置，应该就是 $u$ 往上跳，第一个 $a_i&gt;a_u$ 的 $i$（当然，如果这个 $i$ 跳到了 $v$ 外面，那么我们不算它） 于是我们考虑，先用倍增求出第一个 $a_i&gt;a_u$ 的 $i$，然后重新建图，把 $u$ 直接连到 $i$ 上。这样，对于每次行程，我们把首尾特判掉之后，就相当于新树上求一段路径的长度了。这个直接维护一个深度就能求了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) int I() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args); &#125; class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[N&lt;&lt;1]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; int n,m; int a[N]; void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,1,n) a[i]=I(); G.clear(); F(i,1,n-1) &#123; int u,v; Rd(2,&amp;u,&amp;v); G.Add2(u,v); &#125; &#125; int deep[N],fa[N][22],Max[N][22]; void DFS(int u,int f) &#123; deep[u]=(u==f)?0:deep[f]+1; fa[u][0]=f; F(i,1,20) fa[u][i]=fa[fa[u][i-1]][i-1]; Max[u][0]=max(a[u],a[f]); F(i,1,20) Max[u][i]=max(Max[u][i-1],Max[fa[u][i-1]][i-1]); Tra(i,u) if (v!=f) DFS(v,u); &#125; int PathMax(int u,int f) // 求路径最大值 &#123; if (u==f) return a[u]; int ans=0; D(i,20,0) if (deep[fa[u][i]]&gt;=deep[f]) &#123; ans=max(ans,Max[u][i]),u=fa[u][i]; &#125; return ans; &#125; int MaxPos(int u,int f) // 求路径最大值是哪个位置 &#123; int Mx=PathMax(u,f); if (a[u]==Mx) return u; D(i,20,0) if (Max[u][i]&lt;Mx) u=fa[u][i]; return fa[u][0]; &#125; int FirstBig(int u,int c) // 找到 u 往上第一个满足 a[i]&gt;c 的 &#123; if (a[u]&gt;c) return u; if (Max[u][20]&lt;=c) return n+1; D(i,20,0) if (Max[u][i]&lt;=c) u=fa[u][i]; return fa[u][0]; &#125; namespace Re_build // 把重新建的图封装起来，避免名字冲突 &#123; Graph G; int deep[N],fa[N][22]; void Init() &#123; G.clear(); F(i,1,n) G.AddEdge(fa[i][0],i); &#125; void DFS(int u) &#123; deep[u]=(u==n+1)?0:deep[fa[u][0]]+1; F(i,1,20) fa[u][i]=fa[fa[u][i-1]][i-1]; Tra(i,u) DFS(v); &#125; int Query(int u,int fu) &#123;return deep[u]-deep[fu];&#125; &#125; void Soviet() &#123; DFS(1,1); F(i,1,n) Re_build::fa[i][0]=(Max[i][20]==a[i])?n+1:FirstBig(i,a[i]); // 重新设置 fa 数组 Re_build::Init(); Re_build::DFS(n+1); // 重新 DFS 一遍 F(i,1,m) &#123; int u,v,c; Rd(3,&amp;u,&amp;v,&amp;c); int uu=u,vv=v; // 存储原始的 u,v (后面会有修改) if (u==v) &#123;puts(c&lt;a[u]?"1":"0"); continue;&#125; if (c&gt;=PathMax(u,v)) &#123;puts("0"); continue;&#125; u=FirstBig(uu,c); // 先跳到上面第一个 &gt;c 的 （注意，这里先跳了一次，所以答案+1） v=MaxPos(uu,vv); // 处理一下开头结尾 printf("%d\n",Re_build::Query(u,v)+1); // 如上面所说，答案 +1 &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>树形结构</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯容斥 笔记]]></title>
    <url>%2F2020%2F04%2F18%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%AE%B9%E6%96%A5-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[算法讲解（本篇文章假设您学过莫比乌斯反演 (〃’▽’〃) 我们知道莫比乌斯函数有一个性质： $\sum\limits_{d|n} \mu(d)=[n=1]$ 根据这条性质，我们写出一个类似筛的东西：一个数组，初始都是 $0$。 第 $i$ 轮，将 $i$ 的倍数都加上 $\mu(i)$。 $n$ 轮之后，显然只有第一个位置还剩一个 $1$，其它都变成了 $0$。好好理解下这个表，然后往下看。 那么，假设现在我们要求 $n=1$ 时的答案，但是我们方便求的只有 $n$ 的倍数的答案和，如何转化捏 （⊙.⊙） 我们设 $f(x)$ 表示 $n$ 恰好为 $x$ 的答案，$F(x)$ 表示 $n$ 为 $x$ 的倍数的答案和，即 $\sum\limits_{d|n} f(n)$。 考虑 $\sum\limits_{i=1}^{n} \mu(i)F(i)$， 它 $=\sum\limits_{i=1}^{n}\sum\limits_{i|j} \mu(i)f(j)$ 考虑每个 $f(i)$ 被算了多少次，变为： $\sum\limits_{j=1}^{n} f(j) \sum\limits_{i|j} \mu(i)=\sum\limits_{j=1}^{n} f(j) [j=1]=f(1)$ $f(1)$ 不就是我们要求的，$n$ 恰好为 $1$ 的方案吗(✪ω✪) 其实你也可以联系上面那个表来理解，我们给每一列带上一个 $f(i)$ 的权值，$F(i)$ 就是 $i$ 的倍数列的额。然后我们把所有的 $F(i)*\mu(i)$ 加起来， 根据上面那个表，只会在第一列剩下一个“1”。又因为我们带了一个 $f(i)$ 的权，相当于剩下的就是 $f(1)$ 了。 所以，莫比乌斯容斥的解题步骤： 转化成 $n=1$ 的方案（一般这步比较考思维） 求 $n$ 的倍数的方案和 说这些有点抽象，还是做点题☆daze~ 起飞~T1. CF 439E给定 $q$ 个询问，每次给定 $n,k$ ，问有多少种方法，把 $n$ 分成 $k$ 个数相加，并且 所有数 的 $\gcd$ 为 $1$（即：允许有部分的 $\gcd$ 不为 $1$ ，比如 $n=20,k=3$ 时，$\{2,3,15\}$ 是合法的一组拆分） $q,n\le 10^5,k\le n$ 题解如何转化成上面的 “$n=1$ 的方案数” 呢 设 $f(i)$ 表示：$k$ 个数的 $\gcd=i$ 的方案数，$F(i)$ 表示：$k$ 个数的 $\gcd$ 为 $i$ 的倍数的方案数（即：$k$ 个数都是 $i$ 的倍数的方案数） $F(i)$ 好求。显然，此时 $i$ 是 $n$ 的因数（$k$ 个数都是 $i$ 的倍数，所以它们加起来， $n$ 也是 $i$ 的倍数）。如果不是，那么 $F(i)=0$ 然后所有数都是 $i$ 的倍数的划分方案，我们可以把 $i$ 个数并成一块，然后有 $n/i$ 个块，任意划分成 $k$ 个部分，求方案数。然后我们在 $n/i$ 个块中间插入 $n/i-1$ 个隔板，选择 $k-1$ 个，就能把 $n$ 个数分成 $k$ 个部分，每个部分都是 $i$ 的倍数了。这样方案数是 $F(i)=C_{n/i-1}^{k-1}$。预处理阶乘和阶乘逆元，这个 $O(1)$ 算。 然后根据莫比乌斯容斥的式子，$f(1)=\sum\limits_{i=1}^{n} F(i) \mu(i)$。然后在这题中要变下型 （看上面），因为 $i|n$ 时，$F(i)$ 才能按照上面的方法算，否则 $F(i)=0$。于是， $f(1)=\sum\limits_{i|n} F(i)\mu(i)$ 然后这个枚举因数是 $O(\sqrt{n})$ 的。总的复杂度 $O(q\sqrt{n})$，能过。 代码 （篇幅问题，我就不放主页了(*^▽^*)）（代码看不懂的右下角联系我，或者在代码那边的评论区留言~~❤） T2. CF 900D同样是求划分的问题。相当于在 $T1$ 的基础上： 去掉 $k$ 的限制 一组询问，范围改成 $n\le 10^9$，答案模 $10^9+7$ 给定了参数 $y$，划分完所有数的 $\gcd=y$ （而不是等于 $1$） 题解所有数 $\gcd=y$，相当于所有数除以 $y$ 之后 $\gcd=1$。 然后没有了 $k$ 的限制，相当于所有的隔板随便选/不选。这咋整捏 ⊙(・◇・)？ 假设有 $n$ 个隔板，答案为 $2^{n}$。然后，$n$ 个数不限个数划分，每个数都是 $y$ 的倍数，方案数就是 $2^{n/y-1}$。 然后要注意的是，$n\le 10^9$，只有一部分 $\mu$ 可以筛出来，超过范围的就只好暴力算了。 这个时间复杂度有点玄学…但还是能过的 φ(&gt;ω&lt;*) 代码 T3. CF1036F$T$ 组询问，每次询问 $[2,n]$ 中有多少好数。一个数 $x$ 是“好数”，那么不存在任何一个 $k$ 使得 $\sqrt[k]{x}$ 是整数。 $T\le 10^5,x\le 10^{18}$。 题解一个数是“好数”，那么它分解质因数后，所有指数的 $\gcd=1$ 然后我们考虑所有指数的 $\gcd$ 是 $k$ 的倍数怎么算。很显然，这个方案数就是 $\lfloor \sqrt[k]{x} \rfloor$ 。 然后 $k$ 大概枚举到 $60,70$ 就够了。 然后卡亿点点常数就过了 o(╥﹏╥)o 代码 结语如果您认真的看完并理解了我上面的瞎扯… 恭喜您！学会了莫比乌斯反演！φ(&gt;ω&lt;*) 完结撒花花~~~]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>毒瘤</tag>
        <tag>思维</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 4247 bzoj 2962 [清华集训2012]序列操作]]></title>
    <url>%2F2020%2F04%2F11%2F%E6%B4%9B%E8%B0%B7-4247-bzoj-2962-%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2012-%E5%BA%8F%E5%88%97%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[题意简述给一个长度为 $n$ 的序列 $a$，支持 $q$ 个操作：I l r x 区间元素整体 $+x$。 R l r 区间元素整体 $\times (-1)$ Q l r x 询问：从 $[l,r]$ 中选择 $x$ 个数的积的所有方案的和，$\bmod 19940417$。 $n,q\le 5\times 10^4$。 所有操作保证 $[l,r]$ 有意义。操作 I 中，$x\le 10^9$；操作 Q 中，$x\le min(r-l+1,20)$ 思路我们观察到 $x\le 20$。不妨在线段树中维护每一种情况的答案。设 $S[x]$ 表示当前节点中选择 $x$ 个数的积的所有方案的和。为了方便考虑，设 $S[0]=1$。然后，显然还需要维护取相反数的标记和加法标记。 然后开始线段树传 统 艺 能了。 如何合并左右儿子的答案我们在左半边选 $a$ 个，右半边选 $b$ 个，那就一共选了 $a+b$ 个，贡献是 $lS[a]\times rS[b]$。其中 $lS,rS$ 表示左儿子，右儿子的 $S$ 数组。 如何单节点加值我们其实就是要考虑这样一个东西： $a_1\times a_2\cdots \times a_m$ 如何变成 $(a_1+x)(a_2+x)\cdots (a_m+x)$ 每个括号里可能是 $a_i$，也可能是 $x$。 枚举 $i$ 个括号出了 $a_i$，剩下 $m-i$ 个括号出了 $x$，贡献为： (a 中选 i 个数的积的所有方案的和) $\times x^{m-i}$。 那么，$S[m]$ （不要想歪）该怎么算呢？还是不好算。 其实是因为还差一步转换：我们考虑每个 $i$ 给 $m$ 的贡献。 根据上面的式子，当前的 $i$ 会给 $S[m]$ 加上 $S[i]\times x^{m-i}$ 。那么，加了多少遍呢？我们上面假设现在钦定了 $i$ 个括号出了 $a_i$，然后剩下 $m-i$ 个括号出了 $x$。剩下 $m-i$ 个括号显然不是唯一确定的，那么它们有多少种选择呢？显然是 $C_{len-i}^{m-i}$。其中 $len$ 表示线段树当前区间的长度。 于是， S[m]=\sum\limits_{i=1}^{m} S[i]\times x^{m-i}\times C_{len-i}^{m-i}如何单节点取反显然，取反只会改变正负性，不改变绝对值，而且只有奇数位置会被改变正负性。 即：对于奇数的 $i$，$S[i]$ 变为 $-S[i]$。 到此，这题涉及到的全部操作都解决了。 代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 54444 #define mod 19940417 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) int I() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args); &#125; // ==================== 预处理组合数 int CC[N][30]; void Init() &#123; CC[0][0]=1; int n=5e4; F(i,1,n) &#123; CC[i][0]=1; F(j,1,min(20ll,i)) CC[i][j]=(CC[i-1][j-1]+CC[i-1][j])%mod; &#125; &#125; // ==================== struct node&#123;int l,r; bool f; int a,ans[22];&#125;; node operator+(node ls,node rs) // 合并区间就用重载运算符了 &#123; node cur; cur.l=ls.l; cur.r=rs.r; cur.f=0; cur.a=0; FK(cur.ans); F(i,0,min(20ll,ls.r-ls.l+1)) F(j,0,min(20ll-i,rs.r-rs.l+1)) &#123; cur.ans[i+j]=(cur.ans[i+j]%mod+ls.ans[i]*rs.ans[j]%mod+2*mod)%mod; // cur.ans[i+j]+=ls.ans[i]*rs.ans[j] // 话说取膜好丑啊... &#125; return cur; &#125; class SegmentTree &#123; public: node tree[N&lt;&lt;2]; #define ls index&lt;&lt;1 #define rs index&lt;&lt;1|1 #define L tree[index].l #define R tree[index].r #define C tree[index].f #define A tree[index].a #define S tree[index].ans #define lL tree[ls].l #define lR tree[ls].r #define lC tree[ls].f #define lA tree[ls].a #define lS tree[ls].ans #define rL tree[rs].l #define rR tree[rs].r #define rC tree[rs].f #define rA tree[rs].a #define rS tree[rs].ans #define up(index) tree[index]=tree[ls]+tree[rs] void Build(int l,int r,int index) &#123; L=l,R=r; C=A=0; FK(S); if (l==r) &#123; S[0]=1; S[1]=(I()%mod+mod)%mod; // 为了方便合并左右，设 S[0]=1 return; &#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,ls); Build(mid+1,r,rs); up(index); &#125; void AddOne(int x,int index) &#123; A=(A+x)%mod; int p[22]; p[0]=1; F(i,1,min(20ll,R-L+1)) p[i]=p[i-1]*x%mod; // 预处理出幂 S[0]=1; D(i,min(20ll,R-L+1),1) F(j,0,i-1) &#123; S[i]=(S[i]+S[j]*p[i-j]%mod*CC[R-L+1-j][i-j]%mod)%mod; // S[i]+=S[j]*x^(i-j)*CC[len-j][i-j]; &#125; F(i,0,min(20ll,R-L+1)) S[i]=(S[i]%mod+mod)%mod; &#125; void FlipOne(int index) &#123; F(i,1,min(20ll,R-L+1)) S[i]=(i&amp;1)?(mod-S[i]):S[i]; // 奇数位置取反 A=mod-A; // 注意：取反会影响到加法标记的！！！ C^=1; &#125; void PushDown(int index) &#123; if (C) &#123; FlipOne(ls); FlipOne(rs); C=0; &#125; if (A) &#123; AddOne(A,ls); AddOne(A,rs); A=0; &#125; &#125; void Add(int l,int r,int x,int index) &#123; if (l&gt;R or L&gt;r) return; if (l&lt;=L and R&lt;=r) return AddOne(x,index); PushDown(index); Add(l,r,x,ls); Add(l,r,x,rs); up(index); &#125; void Flip(int l,int r,int index) &#123; if (l&gt;R or L&gt;r) return; if (l&lt;=L and R&lt;=r) return FlipOne(index); PushDown(index); Flip(l,r,ls); Flip(l,r,rs); up(index); &#125; node Query(int l,int r,int index) &#123; if (l&lt;=L and R&lt;=r) return tree[index]; PushDown(index); int mid=(L+R)&gt;&gt;1; if (mid&lt;l) return Query(l,r,rs); if (r&lt;=mid) return Query(l,r,ls); return Query(l,r,ls)+Query(l,r,rs); &#125; &#125;T; int n,m; void Input() &#123; Rd(2,&amp;n,&amp;m); T.Build(1,n,1); &#125; void Soviet() &#123; Init(); F(i,1,m) &#123; char s[3]; scanf("%s",s); if (s[0]=='I') &#123; int l,r,x; Rd(3,&amp;l,&amp;r,&amp;x); T.Add(l,r,x,1); &#125; if (s[0]=='R') &#123; int l,r; Rd(2,&amp;l,&amp;r); T.Flip(l,r,1); &#125; if (s[0]=='Q') &#123; int l,r,k; Rd(3,&amp;l,&amp;r,&amp;k); node ans=T.Query(l,r,1); printf("%lld\n",ans.ans[k]); &#125; &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷-4492-HAOI2018-苹果树-题解]]></title>
    <url>%2F2020%2F04%2F11%2F%E6%B4%9B%E8%B0%B7-4492-HAOI2018-%E8%8B%B9%E6%9E%9C%E6%A0%91-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[先膜一发 shadowice1984的题解，太神了！ 题意简述你有一个 $n$，表示你的二叉树将要有 $n$ 个节点。然后每次你的树会等概率选择某个点的还没长过的儿子，在这里长一个儿子。容易证明，这样有 $n!$ 种方案。 （第一次有一种方案，第二次两种，第三次三种…一共就是 $n!$ 种） 然后你要输出树上路径和的期望值乘以 $n!$ 后 $\bmod{p}$ 的值。 $n,p$ 给定，满足：$n\le 2000,p\le 10^9+7$ 思路考虑每条边的贡献：如果树是确定的，那么从 $i$ 连向 $i$ 父亲的边，的贡献是 $size_i(n-size_i)$。其中 $size_u$ 表示 $u$ 的子树大小。枚举 $i$，把这个式子加起来就是答案了。 然后我们现在树是不确定的…注意到 $n\le 2000$，所以我们考虑再加一维枚举 $size$。关键就是，如何计算点 $i$ 的子树里有 $size$ 个点的树的方案数？ 考虑点 $i$ 子树内，有 $size!$ 种生成的形态。然后我们选择哪些点呢？这个方案数有 $C_{n-1}^{size-i}$ 种。 这一部分答案为 $size!\times C_{n-i}^{size-1}$。 考虑点 $i$ 子树外。在树生成到 $i$ 之前，有 $i!$ 种方案。然后我们后面的 $n-i-size+1$ 个点，还要保证不能放到 $i$ 子树内。然后第一次有 $i-1$ 种方案，第二次 $i$ 种，第 $k$ 次有 $i-k+2$ 种方案。一共就是 $(i-1)i(i+1)(i+2)…(n-size-1)$ 种方案。 这一部分答案为 $i!\times (i-1)i(i+1)(i+2)…(n-size-1)=(n-size-1)!\times i (i+1)$ 于是，枚举 $i,size$ 后，总共的答案就是 $size(n-size) \times size!C_{n-i}^{size-1}\times i(i-1)(n-size-1)!$ $i$ 从 $2$ 到 $n$，$size$ 从 $1$ 到 $n-i+1$，求和即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 2333 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) int I() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args); &#125; // ==================== 预处理阶乘,组合数 int C[N][N],fac[N]; int mod; void Init() &#123; int n=2000; C[0][0]=fac[0]=1; F(i,1,n) &#123; fac[i]=fac[i-1]*i%mod; C[i][0]=1; F(j,1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod; &#125; &#125; // ==================== int n; void Input() &#123; Rd(2,&amp;n,&amp;mod); &#125; int InSubtree(int i,int size) &#123;return C[n-i][size-1]*fac[size]%mod;&#125; // 在子树内的方案 int OutSubtree(int i,int size) &#123;return fac[n-size-1]%mod*i%mod*(i-1)%mod;&#125; // 在子树外的方案 void Soviet() &#123; int ans=0; F(i,2,n) F(size,1,n-i+1) &#123; int cur=size*(n-size)%mod; cur=cur*InSubtree(i,size)%mod; cur=cur*OutSubtree(i,size)%mod; ans=(ans+cur)%mod; &#125; printf("%lld\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Init(); Soviet(); &#125; #undef int //long long&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>期望</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 5295 [北京省选集训2019]图的难题 题解]]></title>
    <url>%2F2020%2F04%2F11%2F%E6%B4%9B%E8%B0%B7-5295-%E5%8C%97%E4%BA%AC%E7%9C%81%E9%80%89%E9%9B%86%E8%AE%AD2019-%E5%9B%BE%E7%9A%84%E9%9A%BE%E9%A2%98-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给你一个 $n$ 个点 $m$ 条边的无向图，判断是否能将一些边染色为白色，其它的染成黑色，并且没有一个纯色的环。 $n\le 501,m\le 2n$ 思路一张图有 $E$ 条边，$V$ 个点。那么，它要满足没有纯色的环，$E$ 最大值为 $2(V-1)$（此时的情况就是白色和黑色分别构成两颗生成树）。 $E\le 2V-2$，可以变成 $E-2V\le -2$。 那么我们现在总的图都要满足条件，那对于任意一个子图当然也满足条件了。我们可以这样转换：$E-2V$ 最大的子图，也满足 $E-2V\le -2$。 那如何求 $E-2V$ 最大的子图呢？把边当成点，点当成边，这就变成了最大权闭合子图问题。 （不会的百度一下） 代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 100055 #define INF 0x5f5f5f5f #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) int I() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args); &#125; class Graph &#123; public: int EdgeCount; int head[N]; int To[N],Label[N],Next[N]; inline void clear() &#123; MEM(head,-1); EdgeCount=-1; &#125; inline void AddEdge(int u,int v,int w) &#123; ++EdgeCount; To[EdgeCount]=v; Label[EdgeCount]=w; Next[EdgeCount]=head[u]; head[u]=EdgeCount; &#125; int Source,Sink; int deep[N]; queue&lt;int&gt; Q; bool BFS() &#123; while(!Q.empty()) Q.pop(); FK(deep); Q.push(Source); deep[Source]=1; do &#123; int u=Q.front();Q.pop(); for(register int i=head[u];~i;i=Next[i]) &#123; int v=To[i]; if (!deep[v] and Label[i]) &#123; deep[v]=deep[u]+1; if (v==Sink) &#123;return true;&#125; Q.push(v); &#125; &#125; &#125;while(!Q.empty()); return (bool)(deep[Sink]); &#125; int DFS(int u,int MinFlow) &#123; if (u==Sink) return MinFlow; int rest=MinFlow; for(register int i=head[u];~i and rest;i=Next[i]) &#123; int v=To[i]; if (deep[v]==deep[u]+1 and Label[i]!=0) &#123; int d=DFS(v,min(MinFlow,Label[i])); if (!d) deep[v]=0; Label[i]-=d; Label[i^1]+=d; rest-=d; &#125; &#125; return MinFlow-rest; &#125; int Dinic() &#123; int ans=0; while(BFS()) ans+=DFS(Source,INF); return ans; &#125; &#125;Nt; // 网络流 int n,m; int uu[N],vv[N]; void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,1,m) uu[i]=I(),vv[i]=I(); &#125; #define S Nt.Source #define T Nt.Sink #define AddFlow(u,v,w) &#123;Nt.AddEdge(u,v,w); Nt.AddEdge(v,u,0);&#125; // 建流 int MustChoose(int s) // 强制选择点 s 的答案 &#123; Nt.clear(); F(i,1,m) &#123; int u=uu[i],v=vv[i]; AddFlow(S,i,1); AddFlow(i,m+u,INF); AddFlow(i,m+v,INF); &#125; F(i,1,n) if (i!=s) &#123; AddFlow(i+m,T,2); &#125; return m-2-Nt.Dinic(); &#125; void Soviet() &#123; S=n+m+1,T=n+m+2; int ans=-INF; F(i,1,n) &#123; ans=max(ans,MustChoose(i)); // 把每个强制选 i 的答案取 max，就是最大闭合子图了 if (ans&gt;-2) &#123;puts("No"); return;&#125; // 每一个都要 &lt;=-2，有一个 &gt; 就直接输出 No &#125; puts((ans&lt;=-2)?"Yes":"No"); &#125; #define Flan void Flan IsMyWife() &#123; int t=I(); F(i,1,t) &#123; Input(); Soviet(); &#125; &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>思维</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 5112 FZOUTSY 题解]]></title>
    <url>%2F2020%2F04%2F11%2F%E6%B4%9B%E8%B0%B7-5112-FZOUTSY-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定字符串 $S$，设 $suf(i)$ 表示从 $i$ 开始的后缀。支持 $q$ 个询问，每次给定 $[l,r]$，求这段区间中有多少对 $i,j$ 使得 $suf(i)$ 和 $suf(j)$ 的最长公共前缀长度 $\ge k$。$k$ 是一个定值，每次都一样。 （备注：$(i,j)$ 和 $(j,i)$ 是同样的一对，只算一次） $k\le |S|\le 3\times 10^6,m\le 10^5$，并且满足 $n^2m\le 10^{15}$。 思路$n^2m\le 10^{15}$？这看起来很奇怪。 冷静分析一下，这提示着我们，$O(n\sqrt{m})$ 的算法是可以通过的。仔细想一下 ，带根号的静态区间询问的算法… 莫队 ！ 然后，$suf(i),suf(j)$ 最长公共前缀长度 $\ge k$，等价于：$i$ 往后 $k$ 个的子串，和 $j$ 往后 $k$ 个的子串相同。 然后我们要快速比较两端子串是否相同… 哈希 ！ 于是问题变为： 处理第 $i$ 位往后 $k$ 个位置的哈希值，设为 $h[i]$ 每次询问，就相当于询问 $h[l,r]$ 中有多少不重复的数，显然可以莫队维护。 代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;#include &lt;unordered_map&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 3000006 #define ll long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) int I() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args); &#125; int n,m,k; char a[N]; void Input() &#123; Rd(3,&amp;n,&amp;m,&amp;k); scanf("%s",a+1); &#125; ll pre[N],pw[N]; ll RHash(int l,int r) &#123;return pre[r]-pre[l-1]*pw[r-l+1];&#125; // Range Hash，求区间哈希值 ll h[N]; unordered_map&lt;ll,int&gt; desc; struct node&#123;int l,r,id;&#125;q[N]; int sn; bool operator&lt;(node a,node b)&#123;return (a.l/sn&lt;b.l/sn) or (a.l/sn==b.l/sn and a.r&lt;b.r);&#125; // 莫队 // sn 为块大小 ll cnt[N]; ll cur=0; void Add(int x)&#123;cur+=cnt[h[x]]; cnt[h[x]]++;&#125; // 加入一个位置 void Del(int x)&#123;cnt[h[x]]--; cur-=cnt[h[x]];&#125; // 删除一个位置 ll ans[N]; void Soviet() &#123; pw[0]=1; F(i,1,n) pw[i]=pw[i-1]*233ll; // 哈希底数开大点 F(i,1,n) pre[i]=(pre[i-1]*233ll+(a[i]-'a')); F(i,1,n-k+1) h[i]=RHash(i,i+k-1); // 预处理出 h[i] 数组 int dcnt=0; F(i,1,n-k+1) &#123; if (!desc[h[i]]) desc[h[i]]=++dcnt; h[i]=desc[h[i]]; &#125; // 离散化 // 只是一个重新编号 // 我们只保证：原来相等的还相等，原来不相等的还不相等 // 并不保证 &lt; 的关系 （也没有必要） sn=n/sqrt(m); // 块长开 n/sqrt(m) // 据说开 sqrt(n) 也不会被卡 F(i,1,m) q[i]=(node)&#123;I(),min(I(),n-k+1),i&#125;; // 因为右端点 &gt;n-k+1 的时候显然不可能有长度为 k 的最长公共前缀 // 所以 r 和 n-k+1 取 min sort(q+1,q+m+1); int l=1,r=0; cur=0ll; F(i,1,m) &#123; if (q[i].l&gt;q[i].r) &#123;ans[q[i].id]=0; continue;&#125; // 会有这种情况...判掉 while(r&lt;q[i].r) ++r,Add(r); while(r&gt;q[i].r) Del(r),--r; while(l&lt;q[i].l) Del(l),++l; while(l&gt;q[i].l) --l,Add(l); ans[q[i].id]=cur; &#125; F(i,1,m) printf("%lld\n",ans[i]); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>莫队</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libreoj 6270 数据结构板子题 题解]]></title>
    <url>%2F2020%2F04%2F06%2Flibreoj-6270-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90%E9%A2%98-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定 $n$ 个区间 $[l_i,r_i]$，和 $Q$ 个询问，每次给你三个整数 $[l,r,k]$，求被 $[l,r]$ 完全包含且长度 $\ge k$ 的区间数量。 注：定义一个区间 $[l,r]$ 的长度是 $r-l$。 $n,q\le 10^6$，$1\le l_i,r_i,l,r,k\le n$，$l_i&lt;r_i,l&lt;r$ 思路如果没有 $k$ 的限制，只是要求完全包含的区间数量，可以用两个树状数组，然后计算右端点在 $[1,r]$ 中的数量减去左端点在 $[1,l-1]$ 中的数量。 然后现在有了 $k$ 的限制，我们把一个询问拆成 $[l,r,r-l]$ 减去 $[l,r,k-1]$。然后把询问和区间都按长度排序，一个一个处理即可。还有就是记录一下这个答案属于第几个询问，带正号还是带负号 （$[l,r,r-l]$ 带正号，$[l,r,k-1]$ 带负号，看上面答案是怎么算的） 然后就做完了。 代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1666666 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) int I() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args); &#125; class BIT &#123; public: int tree[N],len; void Build(int _len) &#123;FK(tree); len=_len;&#125; void Add(int pos,int x) &#123; while(pos&lt;=len) tree[pos]+=x,pos+=(pos&amp;(-pos)); &#125; int Query(int pos) &#123; int ans=0; while(pos&gt;0) ans+=tree[pos],pos-=(pos&amp;(-pos)); return ans; &#125; &#125;L,R; struct seg&#123;int l,r;&#125;a[N]; bool operator&lt;(seg a,seg b)&#123;return a.r-a.l&lt;b.r-b.l;&#125; // 给定的线段，按长度排序 struct que&#123;int l,r,k,id,tp;&#125;q[N]; bool operator&lt;(que a,que b)&#123;return a.k&lt;b.k;&#125; // 询问，也是按长度排序 int n,m; int cnt=0; void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,1,n) &#123;a[i].l=I(); a[i].r=I();&#125; F(i,1,m) &#123; int l,r,k; Rd(3,&amp;l,&amp;r,&amp;k); if (k&gt;r-l) continue; q[++cnt]=(que)&#123;l,r,r-l,i,1&#125;; // 记录编号和符号 q[++cnt]=(que)&#123;l,r,k-1,i,-1&#125;; &#125; &#125; int ans[N]; void Soviet() &#123; sort(a+1,a+n+1); sort(q+1,q+cnt+1); L.Build(n); R.Build(n); // 两颗树状数组，记录左端点和右端点 int pos=1; F(i,1,cnt) &#123; while(pos&lt;=n and a[pos].r-a[pos].l&lt;=q[i].k) &#123; L.Add(a[pos].l,1); R.Add(a[pos].r,1); ++pos; &#125; ans[q[i].id]+=q[i].tp*(R.Query(q[i].r)-L.Query(q[i].l-1)); &#125; F(i,1,m) printf("%d\n",ans[i]); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5102 [POI2018]Prawnicy 题解]]></title>
    <url>%2F2020%2F04%2F06%2Fbzoj-5102-POI2018-Prawnicy-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[[toc] 题意简述给你 $n$ 个区间 $[l_i,r_i]$，选出 恰好 $k$ 个，使得交集最大。输出最长的长度和方案。 注：区间 $[l,r]$ 的长度被定义为 $r-l$。 $1\le k\le n\le 10^5$。 思路框架若干的区间的交集，显然，左端点是所有左端点的最大值，右端点是所有右端点的最小值。 然后我们枚举左端点的最大值。怎么枚举呢？按左端点从小到大排序，枚举到 $i$ 表示只能用 $i$ 之前的区间。那么所有的左端点就都 $\le l_i$ 了。 然后这个时候我们怎么选最大值呢？ 我们只能在 $1\sim i$ 中选 选择 $k$ 个使得最小值最大 怎么选择 $k$ 个使得最小值最大呢？那肯定是从大到小排序之后选前 $k$ 个啊！然后这时候最大的最小值，就是从大到小之后排第 $k$ 位的数。那么我们现在就是要支持动态插入（无删除）的第 $k$ 大。可以用对顶堆做。 点击 对顶堆如何做维护一个小根堆（堆顶是最小值），和一个大根堆（堆顶是最大值）。我们默认把数字插入到小根堆中，如果小根堆中的数字个数 $&gt;k$，那么我们把小根堆中的 最小值 放到大根堆里。 那么有一个显然易证的性质：大根堆中的所有数，任何时候都 $\le$ 小根堆中的所有数。也就是，大根堆的堆顶 $\le$ 小根堆的堆顶。 而且我们还保证了小根堆中只有 $k$ 个数。那么这 $k$ 个数 $\ge$ 当前的其它所有数，显然，这 $k$ 个数字就是前 $k$ 大。求出这 $k$ 个数中的最小值（小根堆顶），就是当前的第 $k$ 大。 这个办法也可以用于求中位数 （也就是 $k$ 不一定静态，单调递增的情况也可以求） 代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1666666 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define all(a) a.begin(),a.end() #define iter(a,p) (a.begin()+p) int I() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args); &#125; struct node&#123;int l,r,id;&#125; a[N]; bool operator&lt;(node a,node b)&#123;return a.l&lt;b.l;&#125; int n,k; void Input() &#123; Rd(2,&amp;n,&amp;k); F(i,1,n) a[i]=(node)&#123;I(),I(),i&#125;; &#125; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; Q1; // 小根堆 priority_queue&lt;int&gt; Q2; // 大根堆 void Soviet() &#123; sort(a+1,a+n+1); int Max=-0x3f3f3f3f,l,r; F(i,1,n) &#123; Q1.push(a[i].r); if (sz(Q1)&gt;k) // 其实这里理论上应该是个 while 循环 // 然而实际上我们每次只会新加入一个数，那么 sz(Q1) 顶多等于 k+1，弹一次即可 // 写中位数的话，这里要改成 while ! &#123; Q2.push(Q1.top()); Q1.pop(); &#125; if (i&gt;=k) // 这里注意判一下 i&gt;=k，很重要，会出错！ （我就挂在这的QaQ &#123; int rr=Q1.top(),ll=a[i].l; if (rr-ll&gt;Max) &#123; Max=rr-ll; l=ll; r=rr; &#125; &#125; &#125; printf("%d\n",Max); int cnt=0; F(i,1,n) &#123; if (a[i].l&lt;=l and r&lt;=a[i].r) &#123; printf("%d ",a[i].id); ++cnt; &#125; if (cnt==k) break; &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libreoj 2037 洛谷 4344 [SHOI2015]脑洞治疗仪 题解]]></title>
    <url>%2F2020%2F04%2F01%2Flibreoj-2037-%E6%B4%9B%E8%B0%B7-4344-SHOI2015-%E8%84%91%E6%B4%9E%E6%B2%BB%E7%96%97%E4%BB%AA-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言友链：zhk 的题解 但是我觉得他这篇里面提的有点简单（主要是没给代码），于是我自己来写一下~ 题意简述zps 是又可爱又傻的女孩子！于是她决定自己治疗她的脑子 zps 的垃圾脑子是一个长度为 $n$ 的序列，每个位置用 $1$ 表示这里有脑组织，$0$ 表示有脑洞（没有脑组织）。初始时全部正常。支持操作若干： 0 l r zps 在 $[l,r]$ 之间所有脑组织都挖掉 1 l0 r0 l1 r1 zps 把 $[l_0,r_0]$ 中的脑组织都挖出来，假设有 $K$ 个，那么她会用这些脑洞来填补 $[l_1,r_1]$ 中从左到右前 $K$ 个脑洞。如果还有剩下的脑组织，她会选择直接扔掉 3 l r 询问区间 $[l,r]$ 中，最长连续脑洞长度。 $1\le n,m\le 2\times 10^5$ 思路框架线段树维护。我们整理一下需要哪些操作。 对于 $0$ 操作，我们需要区间覆盖操作 对于 $1$ 操作，我们需要求出 $[l_0,r_0]$ 中的脑洞个数 $K$（即维护区间和 $S$），把这一段区间全都覆盖为 $0$，然后还要把 $l_1,r_1$ 的前 $k$ 个脑洞变成脑组织。 对于 $2$ 操作，我们要支持维护区间的最大连续长度操作。 查询要维护区间脑洞个数 $S$，然后要维护最长左连续脑洞长度 $LC$，右连续脑洞长度 $RC$，还有一个最长连续脑洞长度 $X$。 $S$ 就是左右加起来，显然。 如果左儿子的 $LC$ 等于左儿子的长度，那么我们的 $LC$ 跨过整个左半边再加上右儿子的 $LC$。否则 $LC$ 等于左儿子的 $LC$。 $RC$ 和 $LC$ 类似的，就是判一下能不能跨过整个右半边。 $X$ 就等于左右儿子 $X$ 的最大值，再和 左 $RC$ 加上右 $LC$ 取 $\max$。 我们把每个线段树节点封装成一个 struct，然后重载运算符来实现这个合并。 修改区间覆盖我们打一个 $C$ 标记 （C=Cover）。然后每次我们先打一下 $C$ 标记，然后如果覆盖的是 $0$（脑洞），$S=LC=RC=X=R-L+1$。否则 $S=LC=RC=X=0$。 区间填充前 k 个把区间分成左右两块，设左半边的脑洞个数为 $lson$。 如果 $k&lt;=lson$，那么只在左边填即可。 否则我们就把左半区间整个覆盖上 $1$ （脑组织），然后在右半边填充 $k-lson$ 个。 线段树上查找的边界为，当： 当前区间完全被查询区间覆盖 （且）$k&gt;=S$ （这种情况显然是直接整个区间覆盖上 $1$ 就行了） 为了方便写代码，我们填充完 一段区间后，函数返回一个整数，表示成功填充了多少个。 （就是有多少挖出来的脑组织没有被扔掉）。后面就会知道它为啥好写了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 255555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) int R() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=R();&#125; va_end(args); &#125; struct node&#123;int l,r,lc,rc,s,x,c;&#125; ; node operator+(node ls,node rs) // 重载一个加号~ &#123; node t; t.l=ls.l; t.r=rs.r; t.c=-1; t.s=ls.s+rs.s; t.x=max(max(ls.x,rs.x),ls.rc+rs.lc); t.lc=ls.lc; if (ls.lc==ls.r-ls.l+1) t.lc+=rs.lc; t.rc=rs.rc; if (rs.rc==rs.r-rs.l+1) t.rc+=ls.rc; return t; &#125; class SegementTree &#123; public: node tree[N&lt;&lt;2]; #define ls index&lt;&lt;1 #define rs index&lt;&lt;1|1 #define L tree[index].l #define R tree[index].r #define LC tree[index].lc #define RC tree[index].rc #define S tree[index].s #define X tree[index].x #define C tree[index].c void Update(int index=1) &#123;tree[index]=tree[ls]+tree[rs];&#125; void Build(int l,int r,int index=1) // 常规的建树 &#123; L=l,R=r; if (l==r) &#123;S=X=LC=RC=0; return;&#125; // 一开始都是脑组织，所以脑洞数量为 0 int mid=(l+r)&gt;&gt;1; Build(l,mid,ls); Build(mid+1,r,rs); Update(index); &#125; void CoverOne(int x,int index=1) &#123; C=x; if (x==1) &#123;S=X=LC=RC=0;&#125; else &#123;S=X=LC=RC=R-L+1;&#125; &#125; void PushDown(int index=1) &#123; if (~C) &#123; CoverOne(C,ls); CoverOne(C,rs); C=-1; &#125; &#125; void Cover(int l,int r,int x,int index=1) // 区间覆盖操作 &#123; if (l&gt;R or L&gt;r) return; if (l&lt;=L and R&lt;=r) return CoverOne(x,index); PushDown(index); Cover(l,r,x,ls); Cover(l,r,x,rs); Update(index); &#125; int Fill(int l,int r,int cnt,int index=1) // 区间填充操作 &#123; if (l&lt;=L and R&lt;=r and cnt&gt;=S) &#123; int s=S; CoverOne(1,index); return s; &#125; PushDown(index); int mid=(L+R)&gt;&gt;1; int sum=0; if (r&lt;=mid) sum=Fill(l,r,cnt,ls); else if (l&gt;mid) sum=Fill(l,r,cnt,rs); else &#123; sum=Fill(l,mid,cnt,ls); if (cnt&gt;sum) sum+=Fill(mid+1,r,cnt-sum,rs); &#125; Update(index); return sum; &#125; node Query(int l,int r,int index=1) &#123; if (l&lt;=L and R&lt;=r) return tree[index]; PushDown(index); int mid=(L+R)&gt;&gt;1; if (r&lt;=mid) return Query(l,r,ls); else if (l&gt;mid) return Query(l,r,rs); else return Query(l,mid,ls)+Query(mid+1,r,rs); &#125; &#125;T; int n,q; void Input() &#123; Rd(2,&amp;n,&amp;q); T.Build(1,n); &#125; void Soviet() &#123; F(i,1,q) &#123; int o,l,r; Rd(3,&amp;o,&amp;l,&amp;r); if (o==0) &#123; T.Cover(l,r,0); &#125; if (o==1) &#123; int l2,r2; Rd(2,&amp;l2,&amp;r2); int cnt=(r-l+1)-T.Query(l,r).s; T.Cover(l,r,0); if (cnt&gt;0) T.Fill(l2,r2,cnt); &#125; if (o==2) &#123; printf("%d\n",T.Query(l,r).x); &#125; &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展卢卡斯定理 笔记]]></title>
    <url>%2F2020%2F03%2F27%2F%E6%89%A9%E5%B1%95%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[先问一个简单的问题，求： C_{n}^{m}\pmod {q}不保证 $q$ 是质数。$1\le q\le 10^6,1\le m\le n\le 10^{18}$。 （原题：洛谷上的板子） 这很毒瘤了！我们平常熟知的几个方法，预处理阶乘和阶乘逆元，或者是 Lucas 定理，都需要 $q$ 为质数才能这么干。现在 $q$ 连质数都不是，可咋整呢… 正片开始主题思路 我们用公式 $C_n^m=\dfrac{n!}{m!(n-m)!}$ 把 $q$ 分解质因数，分解成若干的 $p^k$ 相乘的形式 现在假设模数为 $p^k$，求 $C_n^m \pmod {p^k}$ 用中国剩余定理合并答案 那么，卢卡斯定理呢？引用某神仙写题解时，说过的一句话： 首先，得确定先会扩展欧几里得算法和扩展中国剩余定理。至于卢卡斯定理，那并不重要。 —— Great_Influence 神仙 （扩展卢卡斯定理和卢卡斯定理并没有任何关系2333） 对每个质因数求答案我们发现，$n$ 的范围比 $q$ 要大很多。也就是说，分子分母两个阶乘很可能都是 $0$。 那么就出现了一个想法：我们把分子分母中的含 $p$ 的因子都单独拿出来。 设 $n!$ 中最多包含 $a$ 个 $p$ 因子，$m!$ 和 $(n-m)!$ 中分别包含 $b,c$ 个。设 $f(x)$ 表示把 $x!$ 中的 $p$ 因子都去掉后的值，于是答案等于 \dfrac{f(n)}{f(m)f(n-m)}\times p^{a-b-c} \pmod{p^k}然后现在我们要求两个东西： $f(x)$ （定义见上） $x!$ 中有多少 $p$ 因子，设为 $g(x)$（这个小学就会了吧，$g(x)=g(x/p)+(x/p)$） 那怎么求 $f(x)$ 呢？ 第一部分：拿掉所有倍数先把所有 $p$ 的倍数都拿掉，大概等于： $[1\times 2\times 3\times …\times (p-1)]\times [(p+1)\times (p+2)\times (p+3)…\times (2p-1)]\times …$ （一直乘到 $x$ 往下最后一个不是 $p$ 的倍数的数） 然后你们就会发现我偷偷的把每 $p-1$ 个数分在了同一个中括号里面。我们称这一个中括号为“一组”。组从 $1$ 开始编号（也就是 $1\times 2\times …\times (p-1)$ 是第 $1$ 组，然后剩下的依次编号） 找一下规律： 第 $x$ 组的积就等于 $[xp-p+1,xp-1]$ 之间的数的积。 然后考虑 $p^k-1$ 这个数，它显然是第 $p^{k-1}$ 组的最后一个。那它下一组，就是以下这些数的乘积： $p^k+1,p^k+2,… p^k+p-1$。 别忘了我们的 $f(x)$ 模数是 $p^k$ （见上面的式子）。所以，很显然，这些数同余于： $1,2,…p-1$ 这和第一组是一样的了。那就出现了 循环节！ 我们设“一节”的积为 $S$，那它就等于第 $1$ 组，第 $2$ 组,…第 $p^{k-1}$ 组中的所有数的乘积。 显然，$x!$ 一共能分出 $\dfrac{x}{p^k}$ 个 $S$。 当然，还有 $x \bmod {p^k}$ 个不完整的“一节”，设为 $R$。暴力计算即可。 这一部分的答案（设为 $A$）就等于 $(S)^{\frac{x}{p^k}} \times R$ 那么求 $S$ 和求最后几个不完整的块，就都是 $O(p^k)$ 的了。因为 $q\le 10^6$，所以不会有问题。 第二部分：只考虑 p 的倍数那这一部分就等于 $p\times 2p \times 3p \times …\times (n/p)p$ 然后我们要去掉所有 $p$ 的因子。于是剩下了一个 $(n/p)!$ 但是我们发现这个玩意要递归计算…于是这一部分答案为 $f(n/p)$ 综上 f(x)= \begin{cases} 1\ & (\texttt{if}\quad x=1) \\ f(x/p)+A & (\texttt{else}) \\ \end{cases}时间复杂度 $O(p^k\log x)$ 中国剩余定理合并答案什么？你中国剩余定理不会？ 额…好的，我会写（gu）博（gu）客（gu）的！ 洛谷上的板子代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162// 以下注释中的 ^ 均表示幂// （这个代码里面没有异或.......#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdarg&gt;#include &lt;cmath&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int n,k,p; void Input() &#123; Rd(3,&amp;n,&amp;k,&amp;p); &#125; int qpow(int a,int b,int m) // 快速幂，不用细看，求 a^b%m &#123; int r=1; while(b) &#123; if (b&amp;1) r=r*a%m; a=a*a%m,b&gt;&gt;=1; &#125; return r; &#125; void exgcd(int a,int b,int &amp;x,int &amp;y) // exgcd，用来求逆元，以及中国剩余定理 &#123; if (b==0) &#123;x=1;y=0;return;&#125; int x2,y2; exgcd(b,a%b,x2,y2); x=y2; y=x2-(a/b)*y2; &#125; int inv(int a,int p) // 求 a 模 p 的逆元 &#123; int x,y; exgcd(a,p,x,y); return (x%p+p)%p; &#125; int lcm(int a,int b)&#123;return a/__gcd(a,b)*b;&#125; // 以下函数中的 pk 参数均表示 p^k // 分解质因数的时候顺便求的，这样就不用再求一遍快速幂了 // 常数小~ int fac(int n,int p,int pk) // 这个就是 f 函数 &#123; if (n==0 or n==1) return 1; int r1=1; // r1 就是上面说的 A，表示完整部分 F(i,1,pk) if (i%p) r1=(r1*i)%pk; r1=qpow(r1,n/pk,pk); // 乘一个 n/pk int r2=1; // r2 就是上面说的 R，表示剩余部分 // 写解析的时间和上代码的时间并不同步，所以...名字不同，稍微转化下 F(i,(n/pk)*pk,n) if (i%p) r2=(r2*(i%pk))%pk; return fac(n/p,p,pk)*r1%pk*r2%pk; &#125; int g(int n,int p) // 求 n! 中有多少 p 因子 &#123; if (n&lt;p) return 0; return n/p+g(n/p,p); &#125; int C(int n,int m,int p,int pk) // 求 C(n,m)%pk &#123; if (m&gt;n) return 0; int f1=fac(n,p,pk); int i1=inv(fac(m,p,pk),pk),i2=inv(fac(n-m,p,pk),pk); int gg=g(n,p)-g(m,p)-g(n-m,p); return f1%pk*i1%pk*i2%pk*qpow(p,gg,pk)%pk; &#125; int m[N],a[N]; int cnt=0; void solve(int a,int b,int c,int &amp;x,int &amp;y) // 求方程 ax+by=c 的其中一组特殊解，直接修改 x,y 的值并返回 &#123; int g=__gcd(a,b); if (c%g) &#123;x=-1e9; y=-1e9; return;&#125; a/=g; b/=g; c/=g; exgcd(a,b,x,y); x*=c; y*=c; &#125; int China() // 中国剩余定理（看这伟大的函数名 &#123; int M=m[1],A=a[1]; F(i,2,cnt) &#123; int x,y; solve(M,m[i],a[i]-A,x,y); if (x==-1e9 and y==-1e9) &#123;return -1;&#125; x%=m[i]; A=(A+M*x); M=lcm(M,m[i]); A=(A%M+M)%M; &#125; return A; &#125; int exLucas(int n,int k,int mod) // 正片：求 C(n,k)%mod &#123; cnt=0; for(int i=2;i*i&lt;=mod;++i) if (mod%i==0) // 分解质因数 &#123; int p=i,pk=1; while(mod%i==0) pk*=i,mod/=i; // 找到一个质因数，就顺便把 p^k 给求了 ++cnt; m[cnt]=pk; a[cnt]=C(n,k,p,pk)%pk; &#125; if (mod!=1) &#123; ++cnt; m[cnt]=mod; a[cnt]=C(n,k,mod,mod)%mod; &#125; return China(); &#125; void Soviet() &#123; printf("%lld\n",exLucas(n,k,p)); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libreoj 10051 「一本通 2.3 例 3」Nikitosh 和异或]]></title>
    <url>%2F2020%2F03%2F26%2Flibreoj%2010051%20%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-2-3-%E4%BE%8B-3%E3%80%8DNikitosh-%E5%92%8C%E5%BC%82%E6%88%96%2F</url>
    <content type="text"><![CDATA[题意简述给一个长度为 $n$ 的序列 $a_1,a_2…a_n$，求两个区间 $[l_1,r_1],[l_2,r_2]$，使得两端区间不相交，且两端区间的异或和加起来最大。 $n\le 10^5$，每个 $a_i\le 10^9$。 思路设 $s_i$ 为前缀 $i$ 个的异或和。那么 $[l,r]$ 的异或和相当于 $s_r\oplus s_{l-1}$（$\oplus$ 表示异或）。 设 $pre[i]$ 表示在 $[1,i]$ 中区间的异或和的最大值。$suf[i]$ 表示 $[i,n]$ 中区间的异或和的最大值。那么答案就是 $max\{pre[i]+suf[i+1]\},1\le i\le n-1$。 然后 $pre$ 和 $suf$ 求法基本相同，如果会求 $pre$，只要反过来求一遍就能求出 $suf$ 了。 然后我们可以用 01-TRIE 求出必须以 $i$ 为右端点的最大区间异或和。然后求一个前缀最大值，就能得到 $pre$ 数组了。 如何求（会的跳过）点击 假设我们当前有一些数。我们把它二进制拆分成 $32$ 位，然后从高到低插入 TRIE 树中。 现在我们要查询，这些数中哪个和 $x$ 异或起来最大。 我们把 $x$ 也拆开，对于当前这一位 $x[i]$（其值为 $0/1$），如果有一个儿子编号和 $x[i]$ 不同，尽量往不同的这里走，并且答案加上 $2^i$。否则就只能走相同的那一条边了，因为相同的异或起来为 $0$，所以这时对答案没有贡献。 我们把 $s[0,1,2\cdots i-1]$ 都插入到 TRIE 树中，然后查询必须选 $s[i]$ 的答案，就能得到以 $i$ 为右端点的最大区间异或和。然后求一遍前缀最大值，就能得到 $pre$ 数组。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 10000007 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class Trie &#123; public: int ch[N][2]; //01-TRIE 树，儿子编号开 0/1 即可 int tot; void Init()&#123;FK(ch); tot=0;&#125; void Insert(int x) &#123; int cur=0; D(i,30,0) &#123; int id=((x&gt;&gt;i)&amp;1); if (!ch[cur][id]) ch[cur][id]=++tot; cur=ch[cur][id]; &#125; &#125; int Query(int x) &#123; int cur=0;int ans=0; D(i,30,0) &#123; int id=((x&gt;&gt;i)&amp;1); if (ch[cur][id^1]) cur=ch[cur][id^1],ans|=(1&lt;&lt;i); else if (ch[cur][id]) cur=ch[cur][id]; else return 0; &#125; return ans; &#125; &#125;T; int n,a[N]; void Input() &#123; R1(n); F(i,1,n) R1(a[i]); &#125; int L[N],R[N]; void Soviet() &#123; T.Init(); F(i,1,n) &#123; L[i]=max(L[i-1],T.Query(a[i])); // 一边求答案，一边求了前缀最大值 T.Insert(a[i]); &#125; T.Init(); //注意每次都要把树清空一下 D(i,n,1) &#123; R[i]=max(R[i+1],T.Query(a[i])); T.Insert(a[i]); &#125; long long ans=0; F(i,1,n) ans=max(ans,1ll*L[i]+1ll*R[i+1]); printf("%lld\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>TRIE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主席树 笔记]]></title>
    <url>%2F2020%2F03%2F23%2F%E4%B8%BB%E5%B8%AD%E6%A0%91-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[对于现在的我来说，只要有“可持久化”这个标签，一定伴随着 “毒瘤“，毕竟我刚学会… 好的首先介绍一下主席树是啥。主席树是“可持久化线段树”（Persistant Segment Tree）的中文民间俗称。不知道是因为有人把 Persistant 看成了 Presidant，还是因为它的发明者是 HJT（和某一任国家主席简称相同），被叫做“主席树”。 但是，可持久化是啥呢？ 可持久化是啥可持久化是亿点小优化，当你要开 $n$ 个线段树，但是线段树之间只差一次修改的时候，把空间复杂度降到 $O(n\log n)$。 如何优化呢？考虑我们现在要对一个单点进行修改，那么我们能影响到的位置（就是这个点以及它的祖先），一共才 $\log n$ ，个而其它位置都一样，所以我们可以 只新建 $\log n$ 个位置，整一个副本出来，其余位置直接继承原树即可。 蒯一张图举个例子，$n=5$，修改了第四个点： （原作者） （原博客） （侵权删）（私信 3348064478@qq.com，本站评论有锅） 这样就能节省下超级多的空间！ 但是，有利总有弊。这样的结构破坏的原来线段树的编号的完美特性，不能再用 index&lt;&lt;1 和 index&lt;&lt;1|1 来访问左右儿子了。我们要在线段树中多维护两个元素，左儿子和右儿子的编号。 经典题型静态/动态区间第 $k$ 位：给定一个序列，每次给出 $l,r,k$，求 $[l,r]$ 中的数排序后，第 $k$ 个位置的数是谁。（当然，我们不会实际去排序，所以询问操作对原序列没有影响） 如果是动态的，那你还要支持单点修改的操作，会给定 $x,y$，要支持把第 $x$ 个位置上的数改成 $y$。 （假设我们离散化过了所有 $a_i$，和所有询问修改后变成的 $y$） 静态的问题板子见 洛谷 3834 对于一个查询 $(l,r,k)$ ，（假设我们能）把 $a[l\cdots r]$ 拿出来建一颗权值线段树 $T$，查询就很容易了：把区间分成左半部分和右半部分，设左半部分中数字的个数为 $lsum$。如果 $k\le lsum$，那么就在左半部分中查找，否则就在右半部分中查找第 $k-lsum$ 个。 但是我们怎么把 $a[l\cdots r]$ 拿出来建一颗权值线段树呢？这个时空复杂度都是 $O(nlogn)$ 每次，再乘一个询问次数，肯定炸。 但是我们发现，线段树满足一种微妙的“可减性”：我们考虑建 $n$ 颗线段树 $T$，$T_i$ 表示 $a[1\cdots i]$ 组成的权值线段树。然后 $a[l\cdots r]$ 组成的权值线段树的对应位置就是 $T_r$ 的对应位置减去 $T_{l-1}$的对应位置。但是把 $T$ 建出来，光空间就够炸的了，是 $O(n^2)$ 的 考虑用上面“可持久化”的办法来优化求 $T$ 的过程：$T_i$ 和 $T_{i-1}$之间，差的只是在（离散化后的） $a_i$ 位置上加一。那么我们就让 $T_i$ 在 $T_{i-1}$ 的基础上，复制其中的 $\log$ 条链即可。这样就可以空间复杂度 $O(n\log n)$ ，时间复杂度 $O(n\log^2 n)$ 的过去了。 一个伏笔请把它理解成“前缀和套线段树”。 那么恭喜您，现在您已经会了一个嵌套型的数据结构了 关于为什么要把它理解成这样…看到后面就知道啦，现在保密哦，不能告诉你(ฅ&gt;ω&lt;*ฅ) 静态问题(板子)的代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 200005 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) int I() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args); &#125; class Persistant_Tree &#123; public: struct node&#123;int lid,rid; int l,r; int s;&#125; t[N&lt;&lt;5]; // 注意空间往死里开 // lid,rid 存储左右儿子编号 int rt[N],tot=0; // rt[i] 存第 i 颗线段树的根的编号 #define ls(x) t[x].lid #define rs(x) t[x].rid #define L t[rt].l #define R t[rt].r #define S t[rt].s #define up(x) t[x].s=t[t[x].lid].s+t[t[x].rid].s void Init() &#123;tot=0;&#125; int Build(int l,int r) // 建树，这一步和普通的线段树差别不大 &#123; int rt=++tot; L=l,R=r,S=0; if (l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; ls(rt)=Build(l,mid); rs(rt)=Build(mid+1,r); &#125; return rt; &#125; int Insert(int pos,int rt) // 在 rt 这个根的基础上，修改了 pos 位置 // 把一路上修改的线段树上的链存一个副本，并返回这个链的顶端 &#123; int rr=++tot; t[rr].l=L; t[rr].r=R; t[rr].s=S+1; ls(rr)=ls(rt); rs(rr)=rs(rt); // 默认直接继承 if (L&lt;R) &#123; int mid=(L+R)&gt;&gt;1; if (pos&lt;=mid) ls(rr)=Insert(pos,ls(rt)); // 如果要修改左儿子，那么就左儿子开一个副本 else rs(rr)=Insert(pos,rs(rt)); // 右儿子同理 &#125; return rr; &#125; int QueryKth(int r1,int r2,int l,int r,int k) // 在 T[r2]-T[r1] 这颗权值线段树中，查询排名为 k 的位置 &#123; if (l==r) return l; int mid=(l+r)&gt;&gt;1; int lsum=t[ls(r2)].s-t[ls(r1)].s; // 左边有多少数 if (k&lt;=lsum) return QueryKth(ls(r1),ls(r2),l,mid,k); // k&lt;=lsum，在左边找 else return QueryKth(rs(r1),rs(r2),mid+1,r,k-lsum); // 否则在右边找 &#125; &#125;T; int n,q,a[N]; void Input() &#123; Rd(2,&amp;n,&amp;q); F(i,1,n) a[i]=I(); &#125; int d[N]; void Soviet() &#123; F(i,1,n) d[i]=a[i]; sort(d+1,d+n+1); F(i,1,n) a[i]=lower_bound(d+1,d+n+1,a[i])-d; T.Init(); T.rt[0]=T.Build(1,n); F(i,1,n) &#123; T.rt[i]=T.Insert(a[i],T.rt[i-1]); // 第 i 颗线段树的根，就是在第 i-1 颗线段树的基础上，在 a[i] 的位置上加了一 &#125; F(i,1,q) &#123; int l=I(),r=I(),k=I(); int pos=T.QueryKth(T.rt[l-1],T.rt[r],1,n,k); // 查询第 r 颗树减去第 l-1 颗树的第 k 位，就相当于 a[l...r] 中的第 k 位 printf("%d\n",d[pos]); &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125; 动态的问题板子见 洛谷 2617 做好准备，这比静态的问题要困难的多。我当时调试了 $10$ 个小时才过去。 前置芝士： 树状数组点击 （你不会这个还来学主席树？） （算了，还是先复习一下） 首先回顾一下树状数组的概念： 对于第 $i$ 个位置，我们维护从 $i$ 开始往前 $\operatorname{lowbit}(i)$ 个数的和。然后每次修改只需要改 $\log$ 个位置， 查询也只要求 $\log$ 个位置的和。 为了方便说明，下面设 $nex(i)=i+\operatorname{lowbit}(i)$，$pre(i)=i-\operatorname{lowbit}(i)$ （才不是因为我懒得打 $\operatorname{lowbit}$ 呢！哼╭(╯^╰)╮） 故 技 重 施动态的问题就是我们要支持对其中一个位置进行修改了。修改 了第 $i$ 个位置后，$[i,n]$ 范围内的所有线段树都要被修改一次，时间复杂度就爆炸了。 等等，这个问题我们是不是见过一次？ 把时间倒回大约一两年前，我们遇到过这样一个问题：“单点修改，求区间和” 我们当时是用的树状数组解决的问题：树状数组 $T$，第 $i$ 个位置 $T_i$ 维护 $pre(i)+1$ 到 $i$ 的和。要查询 $i$ 的前缀和，只要求 $T_i,T_{pre(i)},T_{pre(pre(i))}\cdots $ 的和即可。 那么我们可以用树状数组的思路维护主席树啊！ 总体思路那么我们怎么写呢？我们写一个“树状数组套线段树”：维护 $n$ 个线段树 $T$，其中 $T_i$ 维护 $[pre(i)+1,i]$ 之间的所有 $a_{x}$ 组成的权值线段树即可。 初始化对于初始化操作，我们建树。先开 $n$ 颗线段树，但是初始的时候 $n$ 颗线段树 全部 和初始的线段树共用 （也就是对于每个 $i$，$root[i]=root[0]$） 然后对于第 $i$ 个位置，它只能影响到 $i,nex(i),nex(nex(i))\cdots $ 位置上的线段树。对于这些位置上的每一个线段树 $T_i$，我们在它 自己 的基础上，插入 $a[i]$ 位置（并加一）。 修改操作对于修改第 $x$ 个位置从原来的 $a[x]$ 变成 $y$ （修改完令 $a[x]=y$），我们要找到所有包含它的线段树，$T$，在第 $a[x]$ 个位置 $-1$，在 $y$ 的位置 $+1$，这样就完成了修改操作。 查询操作静态的问题中，查询 $[l,r]$ 的第 $k$ 大，用 $T_r$ 来减掉 $T_{l-1}$，然后判断答案在左边还是在右边。传参数只要传入 $T_{l-1}$ 和 $T_r$ 的根节点编号即可。 然而我们现在是树状数组套线段树，两者相减，可不是两颗线段树相减了，而是 第 $r,pre(r),pre(pre(r))\cdots$ 颗线段树的和，减去 第 $l-1,pre(l-1),pre(pre(l-1)) \cdots$ 颗线段树的和。 然后我们显然没法一次性传这么多参数进去（而且还是不定长度，更麻烦了）。我们的办法是，在查询之前，先把所有的 $l-1,pre(l-1),pre(pre(l-1)) \cdots$ 保存在一个数组 $R_1$ 里，再把所有的 $r,pre(r),pre(pre(r)) \cdots$ 保存在一个数组 $R_2$ 里（并记下这两个数组的长度）（从 $1$ 开始编号的同学可以考虑用第 $0$ 个位置作为长度，我就是这么写的） 每次查询前缀 $r$ 颗树减去前缀 $l-1$ 颗树的时候，就遍历 $R_1,R_2$，把第 $R_{2i}$ 颗树的对应位置都加起来，把第 $R_{1i}$ 颗树的对应位置都减掉，得到 $lsum$。然后用静态里面的做法即可。 代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 100005 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) int I() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args); &#125; class Persistant_tree // 被卡常了的主席树... &#123; public: struct node&#123;int lid,rid,s;&#125; t[N*400]; // 去掉了存储左右区间的成员变量，左右区间在函数调用过程中记录 // 从而把空间优化成原来的 3/5，然后数组开大点 int rt[N],tot; #define ls(x) t[x].lid #define rs(x) t[x].rid #define S t[rt].s void Init() &#123;tot=0;&#125; int Build(int l,int r) &#123; int rt=++tot; S=0; if (l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; ls(rt)=Build(l,mid); rs(rt)=Build(mid+1,r); &#125; return rt; &#125; // 这个一样的 int Insert(int l,int r,int pos,int type,int rt) // 修改操作可能会有 -1，于是加上一个 type，type=1或-1表示加还是减 &#123; int rr=++tot; ls(rr)=ls(rt); rs(rr)=rs(rt); t[rr].s=S+type; if (l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) ls(rr)=Insert(l,mid,pos,type,ls(rt)); else rs(rr)=Insert(mid+1,r,pos,type,rs(rt)); // 这些一样的 &#125; return rr; &#125; int R2[30],R1[30]; // R2,R1 含义见上面 // 数组第 0 个位置保存数组长度 int QueryKth(int l,int r,int k) &#123; if (l==r) return l; int lsum=0; F(i,1,R2[0]) lsum+=t[ls(R2[i])].s; F(i,1,R1[0]) lsum-=t[ls(R1[i])].s; // 这个就是要遍历累加来求出 lsum 的值了 int mid=(l+r)&gt;&gt;1; if (k&lt;=lsum) &#123; F(i,1,R2[0]) R2[i]=ls(R2[i]); F(i,1,R1[0]) R1[i]=ls(R1[i]); // 跳左右儿子也要一块跳...这个复杂度活生生的多一个 log 啊 return QueryKth(l,mid,k); &#125; else &#123; F(i,1,R2[0]) R2[i]=rs(R2[i]); F(i,1,R1[0]) R1[i]=rs(R1[i]); return QueryKth(mid+1,r,k-lsum); &#125; &#125; &#125;T; int n,m,a[N]; struct node&#123;char type; int a,b,c;&#125; q[N]; // 如果是 C 操作，那么我们只用 a,b，表示将 a 位置变成了 b // 如果是 Q 操作，那么我们 a,b,c 都用，表示 [a,b] 区间排名第 c 位的数 void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,1,n) a[i]=I(); F(i,1,m) &#123; char o[3]; scanf("%s",o); if (o[0]=='Q') &#123; q[i]=(node)&#123;o[0],I(),I(),I()&#125;; &#125; else &#123; q[i]=(node)&#123;o[0],I(),I()&#125;; &#125; &#125; &#125; int d[N&lt;&lt;2],dcnt=0; #define Find(x) (lower_bound(d+1,d+dcnt+1,x)-d) void Insert(int pos,int type) &#123; int x=Find(a[pos]); for(int i=pos;i&lt;=n;i+=(i&amp;(-i))) &#123; int lastr=T.rt[i]; // 保存原来的根 T.rt[i]=T.Insert(1,dcnt,x,type,lastr); // 以便在原来的基础上插入 &#125; &#125; int Query(int l,int r,int k) &#123; F(i,0,22) T.R1[i]=T.R2[i]=0; for(int i=r;i&gt;0;i-=(i&amp;(-i))) T.R2[++T.R2[0]]=T.rt[i]; for(int i=l;i&gt;0;i-=(i&amp;(-i))) T.R1[++T.R1[0]]=T.rt[i]; // 先预先求好 R1,R2 return T.QueryKth(1,dcnt,k); &#125; void Soviet() &#123; F(i,1,n) d[++dcnt]=a[i]; F(i,1,m) if (q[i].type=='C') d[++dcnt]=q[i].b; sort(d+1,d+dcnt+1); T.Init(); T.rt[0]=T.Build(1,dcnt); F(i,1,n) T.rt[i]=1; F(i,1,n) Insert(i,1); F(i,1,m) &#123; if (q[i].type=='Q') &#123; int pos=Query(q[i].a-1,q[i].b,q[i].c); printf("%d\n",d[pos]); &#125; if (q[i].type=='C') &#123; int x=q[i].a,y=q[i].b; Insert(x,-1); a[x]=y; Insert(x,1); &#125; &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>线段树</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libreoj 10067 「一本通 3.1 练习 2」构造完全图 题解]]></title>
    <url>%2F2020%2F03%2F21%2Flibreoj-10067-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-1-%E7%BB%83%E4%B9%A0-2%E3%80%8D%E6%9E%84%E9%80%A0%E5%AE%8C%E5%85%A8%E5%9B%BE-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个树 $T$ ，求一个完全图 $G$ 使得 $T$ 是 $G$ 的最小生成树，并且 $G$ 的边权和最小。求出这个最小的边权和。$T$ 的点数 $n\le 10^5$，每个边权 $w\le 10^5​$ 思路我们把 $T​$ 中的边权排一下序，反向推一下 Kruskal 算法的步骤。 我们每次考虑到第 $i​$ 条边 $(u,v,w)​$，假设这之前的 $i-1​$ 条边已经构造好了若干个都是完全图的联通块，并且 $T​$ 中的前 $i-1​$ 条边就是这些联通块的生成树（也就是保证了 Kruskal 算法前 $i-1​$ 步都选的是 $T​$ 中的边）。 在连上 $(u,v,w)$ 之前，$(u,v)$ 应该分在两个联通块里。我们把 $(u,v,w)$ 连起来之后，对于两个联通块里除了 $(u,v)$ 以外的所有点对，都连一条权为 $w+1$ 的边。这样，显然在 Kruskal 算法的第 $i$ 步中，选的是第 $i$ 条边（因为现在只剩下两个联通块连接，除了 $(u,v,w)$ 之外所有的边权都 $\ge w$，肯定得选 $(u,v,w)$） 所以我们把 $T$ 中的边按边权排序，并查集合并的时候记录一下联通块大小。然后 $(u,v,w)$ 这条边的贡献就是 $(cnt[u]\times cnt[v]-1)\times (w+1)​$ 代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) int I() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args); &#125; class DSU &#123; public: int Fa[N],Cnt[N]; void Init()&#123;F(i,0,N-1) Fa[i]=i,Cnt[i]=1;&#125; int Find(int u)&#123;return u==Fa[u]?u:Fa[u]=Find(Fa[u]);&#125; bool Merge(int u,int v) &#123; int au=Find(u),av=Find(v); if (au==av) return false; if (Cnt[au]&lt;Cnt[av]) Cnt[av]+=Cnt[au],Fa[au]=av; else Cnt[au]+=Cnt[av],Fa[av]=au; return true; &#125; &#125;D; struct node&#123;int u,v,w;&#125;e[N]; bool operator&lt;(node a,node b)&#123;return a.w&lt;b.w;&#125; int n; void Input() &#123; n=I(); F(i,1,n-1) e[i]=(node)&#123;I(),I(),I()&#125;; &#125; void Soviet() &#123; int ans=0; F(i,1,n-1) ans+=e[i].w; // 初始答案为所有边的边权和，这个显然 sort(e+1,e+n); D.Init(); F(i,1,n-1) &#123; int u=e[i].u,v=e[i].v; int au=D.Find(u),av=D.Find(v); ans+=(D.Cnt[au]*D.Cnt[av]-1)*(e[i].w+1); D.Merge(u,v); &#125; printf("%lld\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 3831 [SHOI2012]回家的路 题解]]></title>
    <url>%2F2020%2F03%2F21%2F%E6%B4%9B%E8%B0%B7-3831-%5BSHOI2012%5D%E5%9B%9E%E5%AE%B6%E7%9A%84%E8%B7%AF-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述$n$ 行 $n$ 列的矩阵上，只有 $m$ 个“关键点”处（在第 $x$ 行 $y$ 列）才能拐弯。从格子到上下左右四个相邻格子花费 $2$，转弯花费 $1$。 求从某个位置走到另一个位置的最小花费。无解输出 $-1​$。 思路新建两个点 $S$ 和 $T$ 表示起点。 然后把所有点 $A$（包括关键点和 $S,T$） 拆成两个点 $A_1$ 和 $A_2$，分别表示横向跑和纵向跑。 对于所有关键点 $K$ （不包括 $S,T$），$K_1$ 到 $K_2$ 连一条边权为 $1$ 的无向边，表示换乘。 然后对于所有同一行 （$x$ 相同）的点，按照列号 $y$ 排序。对于相邻的 $A,B$，连边 $(A_1,B_1,2\times dis)$，其中 $dis$ 为 $A,B$ 两点 $y$ 值的距离。为啥乘二，是因为相邻格子要花费 $2$。 同一列同理（同一列连的是 $A_2$ 和 $B_2$）。 然后我们从 $S_1$ 跑到 $T_1,T_2$，从 $S_2$ 跑到 $T_1,T_2$ ，四种方案，看哪个最小。如果都不能到达…那就输出 $-1$。 代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 255555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) int I() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args); &#125; class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[1666666]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123; // printf("Add %d %d\n",u,v); AddEdge(u,v,w);AddEdge(v,u,w); &#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; struct node&#123;int x,y,id;&#125;a[N]; bool cmp_x(node a,node b) &#123;return a.x&lt;b.x or (a.x==b.x and a.y&lt;b.y);&#125; bool cmp_y(node a,node b) &#123;return a.y&lt;b.y or (a.y==b.y and a.x&lt;b.x);&#125; #define lin(x) x #define col(x) (x)+m+2 int n,m; void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,1,m) a[i]=(node)&#123;I(),I(),i&#125;; a[m+1]=(node)&#123;I(),I(),m+1&#125;; a[m+2]=(node)&#123;I(),I(),m+2&#125;; &#125; void Build() &#123; G.clear(); sort(a+1,a+m+3,cmp_x); F(i,2,m+2) if (a[i].x==a[i-1].x) G.Add2(lin(a[i].id),lin(a[i-1].id),2*abs(a[i].y-a[i-1].y)); sort(a+1,a+m+3,cmp_y); F(i,2,m+2) if (a[i].y==a[i-1].y) G.Add2(col(a[i].id),col(a[i-1].id),2*abs(a[i].x-a[i-1].x)); F(i,1,m+2) if (a[i].id&lt;=m) G.Add2(lin(a[i].id),col(a[i].id),1); &#125; struct djnode&#123;int v,w;&#125;; bool operator&lt;(djnode a,djnode b)&#123;return a.w&gt;b.w;&#125; priority_queue&lt;djnode&gt; Q; bool vis[N];int dis[N]; void Dijkstra(int s) &#123; MEM(dis,0x3f); FK(vis); while(!Q.empty()) Q.pop(); Q.push((djnode)&#123;s,0&#125;); dis[s]=0; while(!Q.empty()) &#123; djnode Min=Q.top(); Q.pop(); int u=Min.v; if (vis[u]) continue; vis[u]=1; Tra(i,u) if (!vis[v] and dis[v]&gt;dis[u]+G.Label(i)) &#123; dis[v]=dis[u]+G.Label(i); Q.push((djnode)&#123;v,dis[v]&#125;); &#125; &#125; // F(i,1,2*(m+2)) printf("%d ",dis[i]&gt;1e9?-1:dis[i]); // putchar('\n'); &#125; void Soviet() &#123; Build(); int ans=0x3f3f3f3f; Dijkstra(lin(m+1)); ans=min(ans,min(dis[lin(m+2)],dis[col(m+2)])); Dijkstra(col(m+1)); ans=min(ans,min(dis[lin(m+2)],dis[col(m+2)])); printf("%d\n",ans&gt;1e9?-1:ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>建图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 1117 libreoj 2083 优秀的拆分 题解]]></title>
    <url>%2F2020%2F03%2F17%2F%E6%B4%9B%E8%B0%B7-1117-libreoj-2083-%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述一个字符串是“优秀”的，定义为：存在两个非空的字符串 $A,B$，满足这个字符串 $S=AABB$，那么这个 $S$ 就是优秀的。 给定一个串，计算它有多少子串是“优秀”的。相同的子串出现在不同的位置也被算两次。 长度 $\le 3e4$ 思路对于每个位置，我们维护 $pre[i]$ 表示以 $i$ 结尾的 $AA$ 形式的串有多少个，$suf[i]$ 同理。 然后答案就是 $\prod\limits_{i=1}^{n-1}pre[i]\times suf[i+1]$ 然后考虑怎么求 $pre$。（$suf$ 的话，就把串反过来求一遍 $pre$ 即可） 如何求 pre不会吧？不会就对了，黑题是这么容易做出来的嘛。 我们继续降低要求，我们求特定长度的 $pre[i]$。我们设 $A$ 的长度为 $k$，也就是 $AA$ 串的长度为 $2k$ 。 这个好判断，哈希就行了。 对于位置 $i$，如果 $[i-k+1,i]$ 区间的哈希值等于区间 $[i-2k+1,i-k]$ 的哈希值，那么 $pre[i]$ 就可以 $+1$，因为长度 $k$ 满足条件。 但是这样是 $O(n^2)$ 的呀，怎么更快速的求呢。 假如现在我们枚举 $k$，能很快的求出 $[1,n]$ 的答案，那多好啊。 那有了这样一个巧妙的做法（看题解前我也不会）：对于长度 $k$，我们在 $k,2k,3k…k\times (n/k)$ 的位置都打上一个标记。显然，标记的总数是 $(n/1)+(n/2)+(n/3)…+(n/n)=n\ln n$。 而且还有一个特性，一个长度为 $2k$ 的 $AA$ 串，把它分成等长度并且相同的两半，肯定各自覆盖到一个标记。 如这个图所示，蓝色是整个大串 $S$，黄色+绿色是一个串 $A$，黄色+绿色+黄色+绿色是一个 $AA$ 串。红色的是两个标记。 我们发现，黄色部分长度是两个标记的公共后缀长度之一，绿色部分则是两个标记的公共前缀长度之一。 对于每个标记，我们求出这个标记和上一个标记的最长公共前缀，和最长公共后缀（二分+哈希）。（当然，这最长公共前后缀的长度不能超过 $k$）设当前位置在 $p$，上一个标记位置是 $p-k$。 子串 $s[p,n]$ 和子串 $s[p-k,n]$ ，最长公共前缀为 $LCP$（Longest Common Prefix），子串 $s[1,p]$ 和子串 $s[1,p-k]$ 的最长公共后缀为 $LCS$。 那么这个 $AA$ 串，长度为 $2k$，左端点最左能到 $L=p-k-LCS+1$，右端点最右能到 $R=p+LCP-1$。那么这个 $AA$ 的右端点的范围就是 $[L+2k-1,R]$。当然，这个范围不能超过 $P$ ，注意和 $P$ 取一下 $\min$ 或者 $\max$。显然，对于这个区间的所有 $pre$ 数组都能 $+1$。（因为它是一个 $AA$ 串的右端点） 我们发现，前面都是加法操作，而只要维护一次查询（最后的总查询），用差分即可。 代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define mod 114514027ll //这模数太臭了 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int p[N]; void Init() &#123; p[0]=1; F(i,1,1e5) p[i]=(p[i-1]*31)%mod; // 31为底，质数，保险 &#125; char a[N]; int n; void Input() &#123; scanf("%s",a+1); n=strlen(a+1); &#125; int pre[N]; int rangehash(int l,int r) &#123;return (pre[l]-pre[r+1]*p[r-l+1]%mod+mod)%mod;&#125; // 区间哈希值 int LCS(int a,int b) //最长公共后缀长度 &#123; if (a&gt;b) swap(a,b); int l=1,r=b-a; while(l&lt;r) &#123; int mid=(l+r+1)&gt;&gt;1; if (rangehash(a-mid+1,a)==rangehash(b-mid+1,b)) l=mid; else r=mid-1; &#125; return l; &#125; int LCP(int a,int b) // 最长公共前缀长度 &#123; if (a&gt;b) swap(a,b); int l=1,r=b-a; while(l&lt;r) &#123; int mid=(l+r+1)&gt;&gt;1; if (rangehash(a,a+mid-1)==rangehash(b,b+mid-1)) l=mid; else r=mid-1; &#125; return l; &#125; int L[N],R[N]; // L 和 R 对应上面说的 suf 和 pre // L[i]: 以 i 为左端点（开头）的 AA 串有多少个 // R[i]: 以 i 为右端点（结尾）的 AA 串有多少个 void rangeadd(int c[],int l,int r)&#123;c[l]++; c[r+1]--;&#125; // 差分数组 区间加 void Soviet() &#123; F(i,0,n+1) pre[i]=L[i]=R[i]=0; D(i,n,1) pre[i]=(pre[i+1]*31+(a[i]-'a'+1))%mod; F(len,1,n/2) Fs(i,2*len,n,i+=len) &#123; if (a[i]!=a[i-len]) continue; int l=i-LCS(i,i-len)+1,r=i+LCP(i,i-len)-1; l=max(l+len-1,i); r=min(r,i+len-1); // 和 i 取一下min和max，注意范围 if (l&lt;=r) &#123; rangeadd(R,l-2*len+1,r-2*len+1); rangeadd(L,l,r); &#125; &#125; F(i,1,n) L[i]+=L[i-1],R[i]+=R[i-1]; // 最后可别忘了求前缀和 int ans=0; F(i,1,n-1) ans+=L[i]*R[i+1]; // 答案式子 printf("%lld\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; int t;R1(t); Init(); F(i,1,t) &#123; Input(); Soviet(); &#125; &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>字符串</tag>
        <tag>思维</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1235E Ehab's REAL Number Theory Problem 题解]]></title>
    <url>%2F2020%2F03%2F17%2FCodeforces-1235E-Ehab-s-REAL-Number-Theory-Problem-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[考场上想出了思路，但是没能写出来代码，实在可惜 题意简述有 $n\le 1e5$ 个正整数，每个数值域都是 $[1,10^6]$，并且最多有 $7$ 个因数。 请你求出最少选多少个数能使得乘积是平方数。 思路最多 $7$ 个因数 $\leftrightarrow$ 最多两个质因数 而且对于一个质因数，显然我们还可以把它的指数膜个 $2$。如果指数到最后是 $0$，那么我们直接扔掉这个质因数；如果两个质因数指数都是 $0$，那好了，直接输出 $1$，结束程序。 然后就是一个数等于 $p$ 或者 $p\times q$ 的情况了。$p$ 的情况就加边 $(1,p)$，$p\times q$ 的情况就加边 $(p,q)$，然后求一个最小环即可。 而且我们发现，一个环上顶多有一个点在 $&gt;1000$ ，那么我们可以以 $1~1000$ 中的点为起点，分别使用 $BFS$ 找环法。这样只能找到包含某个点的最小环，但这足够了，因为这个环必然包含一个编号小于等于 $1000$ 的点。而我们只会在质数间连边，所以我们的实际复杂度比你想象的要小很多！ 怎么想到的主要就是如何转换为最小环那一步。首先这个相当于我们选若干个数，分解成 $1\times p$ 或者 $p\times q$ 的形式，然后几个数覆盖起来，每个质数 $p$ 都得被算偶数次（$0$ 也是偶数，不算到也是可以的）。那这样我们的总乘积中，每个质因数都是偶数次方，那就是完全平方数了。 考虑到一个简单的环上的每个点度数都是 $2$，所以我们就能想到把它建成图，然后跑最小环。那么有小朋友（无 中 生 友）就问了，会不会有环上的点度数为 $4,6,8$，甚至更大的偶数呢？其实这个就相当于一个点被算了很多次嘛，但是我们要求的是“最少多少个数的积是平方数”，也就是我们要让环尽量的小。容易证明，一个最小的环肯定是简单环。（因为如果你是一个复合的环，那么肯定能拆出来若干的简单环，答案更优） 代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1666666 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) int I() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args); &#125; class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Next; &#125;Ed[N&lt;&lt;1]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v) &#123; Ed[++EdgeCount]=(Edge)&#123;v,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v) &#123;AddEdge(u,v);AddEdge(v,u);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; bool notp[N]; int primes[N];; vector&lt;int&gt; pd[N]; //prime divisors 的简写，保存质因数 void Init() &#123; notp[1]=1; int n=1e6; F(i,2,n) if (!notp[i]) &#123; primes[++primes[0]]=i; pd[i].p_b(i); Fs(j,2*i,n,j+=i) &#123; if (sz(pd[j])&lt;2) pd[j].p_b(i); notp[j]=1; // 题目保证质因数个数&lt;=2，只要存前两个即可，空间复杂度O(2n) &#125; &#125; &#125; int n,a[N]; void Input() &#123; n=I(); F(i,1,n) a[i]=I(); sort(a+1,a+n+1); &#125; int cnt(int p,int x) //计算 x 有多少个因子 p &#123; int ans=0; while(x%p==0) &#123;ans^=1; x/=p;&#125; return ans; &#125; int ans=0x3f3f3f3f; bool added[N]; // 判一下重边 void add(int a,int b) &#123; if (added[a*b]) &#123;ans=min(ans,2); return;&#125; //有重边，那就能组成一个二元环，答案更新为 2 added[a*b]=1; G.Add2(a,b); &#125; void Factor(int x) &#123; if (x==1) &#123;puts("1"); exit(0);&#125; if (sz(pd[x])==1) &#123; int p=pd[x][0],pp=cnt(p,x); if (pp==0) &#123;ans=min(ans,1);&#125; else &#123;add(1,p);&#125; &#125; else //pd[x].size()==2 &#123; int p=pd[x][0],q=pd[x][1]; int pp=cnt(p,x),qq=cnt(q,x); if (pp==0 and qq==0) &#123;ans=min(ans,1);&#125; else if (pp==1 and qq==1) &#123;add(p,q);&#125; else if (pp==0 and qq==1) &#123;add(1,q);&#125; else if (pp==1 and qq==0) &#123;add(1,p);&#125; &#125; &#125; int Q[N],vis[N],dis[N],fa[N]; int Round=0; void BFS(int s) // 包含 s 的最小环 &#123; int head=1,tail=1; ++Round; Q[tail]=s; dis[s]=0; while(head&lt;=tail) &#123; int u=Q[head++]; vis[u]=Round; Tra(i,u) &#123; if (vis[v]!=Round) &#123;dis[v]=dis[u]+1; vis[v]=Round; Q[++tail]=v; fa[v]=u;&#125; else &#123; if (v!=fa[u]) ans=min(ans,dis[u]+dis[v]+1); // 此时 s-&gt;u,u-&gt;v,v-&gt;s 组成一个环，三个部分长度分别是 dis[u],1,dis[v]，总长度就是 dis[u]+dis[v]+1 // 注意不能搜回前驱节点 &#125; &#125; &#125; &#125; void Soviet() &#123; G.clear(); F(i,1,n) Factor(a[i]); if (ans&lt;=2) &#123;printf("%d\n",ans); return;&#125; BFS(1); F(i,1,180) BFS(primes[i]); printf("%d\n",ans==0x3f3f3f3f?-1:ans); &#125; #define Flan void Flan IsMyWife() &#123; Init(); Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>数论</tag>
        <tag>转化思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 1238 最小公倍数之和 V3 题解]]></title>
    <url>%2F2020%2F03%2F17%2F51nod-1238-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E4%B9%8B%E5%92%8C-V3-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n} \operatorname{lcm}(i,j)$ $n\le 10^{10}$ （简短题意，恶臭规模） 思路总的来说，就是先把式子变一变，然后巧妙的用欧拉函数 $\varphi$ 加上杜教筛和整除分块来算。 变形首先我们知道 $\operatorname{lcm}(a,b)=\operatorname{lcm}(b,a)$ 所以，当 $i\not=j$ 时候，我们计算 $j&lt;i$ 的情况，然后 $\times 2$ 即可 对于 $i=j$ 的情况特判，这时候产生的贡献和为 $\dfrac{n(n+1)}{2}$ 所以，答案化为 $\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i-1} \operatorname{lcm}(i,j) + \dfrac{n(n+1)}{2}$ 我们都知道 $\operatorname{lcm}(i,j)=\dfrac{ij}{\gcd(i,j)}$。这个再换一下即可。 开始硬♂上开局一公式，结论全靠推。让我们开心的推倒式子吧~ 首先枚举 $gcd$，然后枚举互质的倍数 $i,j$。 原式 $=\sum\limits_{d=1}^{n}\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{i} [\gcd(i,j)=1] ijd$$=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i} [\gcd(i,j)=1] ij \sum\limits_{d=1}^{n/i} d$ （枚举一对互质的 $i,j$ ，计算有多少个 $d$ 算到了这对 $i,j$，加起来）设 $S_k(n)=\sum\limits_{i=1}^{n} i^k$ 。显然， $k=1,2,3$ 时这个式子都能 $O(1)$ 算。接下来变成$=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i}[\gcd(i,j)=1] ij S_1(n/i)$ （恭喜你少了一个 $d$）考虑如何求 $\sum\limits_{j=1}^{i} [\gcd(i,j)=1]j$，也就是求 $i$ 以内和 $i$ 互质的数的和。 点击 如何求 i 以内和 i 互质的数的和（会的跳过）首先数量一共有 $\varphi(i)$ 个。然后我们打表发现，这东西和等差数列有一个很类似的性质：我们把 $[1,i]$ 中和 $i$ 互质的 $j$ 从小到大排一排，换一行，再从大到小排一排，对应位置和相等（都是 $i$）！根据高斯当年想出来的办法，和就是（每个对应位置的和）乘以（一共有多少项），然后除二。换到这题来，这个和就是 $\dfrac{1}{2}i\times \varphi(i)$ 它等于 $\dfrac{1}{2}i\times \varphi(i)$。带入原式： $=\sum\limits_{i=1}^{n} i\times S_1(n/i) \times \dfrac{i\times \varphi(i)}{2}$ （恭喜你又少了一个 $j$，它现在是一维了）$=\dfrac{1}{2}\sum\limits_{i=1}^{n} i^2\varphi(i)\times S_1(n/i)$ $S_1(n/i)$ 显然可以整除分块，但是整除分块我们要考虑一个东西： 如何求 $i^2\varphi(i)$ 的前缀和？显然，用杜教筛求一下和即可。 点击 具体怎么杜教筛 （老样子，会的跳过）设 $f(n)=n^2\varphi(n)$关键就是要配一个好算的 $g$ ，使得 $f\times g$ 也是一个好算的函数 $h$。 由狄利克雷卷积的定义，$h(n)=\sum\limits_{d|n} f(d)g(\dfrac{n}{d})$$=\sum\limits_{d|n} d^2\varphi(i)g(\dfrac{n}{d})$我们发现，令 $g(n)=n^2$，就能消掉一个 $d^2$，原式继续变成：$=\sum\limits_{d|n} n^2\varphi(i)$ （注意 $g(\dfrac{n}{d})$ 头顶上还有一个 $n$，乘出来变成 $n^2$）=$n^2\sum\limits_{d|n} varphi(d)=n^3$ 所以说， $h(n)=f\times (g(n)=n^2)=(n^3)$ 然后用杜教筛的传统艺能就行了。 总复杂度非常恐怖，但是的确能通过 $n=10^10$ 的数据。一定注意处处取膜 代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 20000007ll #define mod 1000000007ll #define i6 166666668ll #define i2 500000004ll #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) int I() &#123; int x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1)?x:-x); &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123;int* x=va_arg(args,int*);(*x)=I();&#125; va_end(args); &#125; bitset&lt;N&gt; notp; int primes[N/5]; int phi[N]; void Init() &#123; int n=2e7; notp[1]=1; phi[1]=1; int &amp;cnt=primes[0]; F(i,2,n) &#123; if (!notp[i]) &#123;primes[++cnt]=i; phi[i]=i-1;&#125; for(int j=1;j&lt;=cnt and i*primes[j]&lt;=n;++j) &#123; int u=primes[j]; notp[i*u]=1; if (i%u==0)&#123;phi[i*u]=phi[i]*u; break;&#125; else phi[i*u]=phi[i]*phi[u]; &#125; &#125; F(i,1,n) phi[i]=(phi[i-1]+1ll*phi[i]*i%mod*i%mod)%mod; &#125; int n; void Input() &#123; n=I(); &#125; map&lt;int,int&gt; rec; int S1(int n) &#123;n%=mod; return 1ll*n%mod*(n+1)%mod*i2%mod;&#125; int S2(int n) &#123;n%=mod; return 1ll*n%mod*(n+1)%mod*(2ll*n+1)%mod*i6%mod;&#125; int S3(int n) &#123;n%=mod; return 1ll*S1(n)*S1(n)%mod;&#125; // 我就是这里没取膜，调了两小时 int f(int n) //杜教筛求 f(n)=n^2*phi(n) 的前缀和 &#123; if (n&lt;=2e7) return phi[n]; if (rec[n]) return rec[n]; int ans=0; for(int l=2,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); ans=(ans+f(n/l)*(S2(r)-S2(l-1)))%mod; &#125; n%=mod; return rec[n]=(S1(n)*S1(n)-ans)%mod; &#125; void Soviet() &#123; int ans=0; for(int l=2,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); ans=(ans+S1(n/l)*(f(r)-f(l-1))%mod*i2%mod)%mod; &#125;// 整除分块+杜教筛 printf("%lld\n",((2ll*ans+S1(n))%mod+mod)%mod); &#125; #define Flan void Flan IsMyWife() &#123; Init(); Input(); Soviet(); &#125; #undef int //long long&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>数论函数</tag>
        <tag>毒瘤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libreoj 137 最小瓶颈路 加强版 题解]]></title>
    <url>%2F2020%2F03%2F15%2Flibreoj-137-%E6%9C%80%E5%B0%8F%E7%93%B6%E9%A2%88%E8%B7%AF-%E5%8A%A0%E5%BC%BA%E7%89%88-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定 $n$ 个点 $m$ 条边的无向连通图，边带权。$q$ 次询问，每次问你 $u,v$ 之间的所有路径中，边权最大值最小是多少。 $n\le 7\times10^4,m\le 10^5,q\le 10^7$ （询问会用种子生成方式给你，具体见原题，不会影响输入时间） 思路首先跑一遍 Kruskal 最小生成树的重构树，$u,v$ 的最小瓶颈路就是 $u,v$ 的路径最大值。 然后在 Kruskal 中，$u,v$ 路径的最大值，就是第一次 （当然，也是唯一一次）把 $u,v$ 两个点从不连通变成联通的那条边的边权。 那么我们在合并 $u,v$ 的时候，就可以开一个临时的点 $x$ ，把 $u$ 和 $v$ 都接到 $x$ 下面，变成 $x$ 的儿子。然后 $x$ 的点权，就是 $u$ 到 $v$ 的边权。 那这样求生成树之后， $u$ 到 $v$ 的路径最大值，就相当于 $u,v$ 的 $LCA$ 的点权。 用 $ST$ 表 $O(1)$ 求 $LCA$ 即可。 代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 455555 #define mod 1000000007 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class DSU &#123; public: int Fa[N],Cnt[N]; void Init() &#123;F(i,0,N-1) Fa[i]=i,Cnt[i]=1;&#125; int Find(int u)&#123;return u==Fa[u]?u:Fa[u]=Find(Fa[u]);&#125; bool Merge(int u,int v) &#123; // int au=Find(u),av=Find(v); // if (au==av) return false; // if (Cnt[au]&lt;Cnt[av]) Cnt[av]+=Cnt[au],Fa[au]=av; // else Cnt[au]+=Cnt[av],Fa[av]=au; // return true; Fa[Find(v)]=u; return true; &#125; &#125;D; class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[N&lt;&lt;1]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; struct node&#123;int u,v,w;&#125;E[N]; bool operator&lt;(node a,node b)&#123;return a.w&lt;b.w;&#125; int n,m; void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,1,m) R1(E[i].u),R1(E[i].v),R1(E[i].w); &#125; int val[N]; int seq[N],first[N],deep[N],Time=0; void DFS(int u,int f) &#123; seq[++Time]=u; first[u]=Time; deep[u]=(u==f)?1:deep[f]+1; Tra(i,u) if (v!=f) &#123; DFS(v,u); seq[++Time]=u; &#125; &#125; int Minp[N][22],lg[N]; void InitST() &#123; F(i,2,4e5) lg[i]=lg[i&gt;&gt;1]+1; F(i,1,Time) Minp[i][0]=seq[i]; F(j,1,20) F(i,1,Time-(1&lt;&lt;j)+1) &#123; int a=Minp[i][j-1],b=Minp[i+(1&lt;&lt;(j-1))][j-1]; Minp[i][j]=(deep[a]&lt;deep[b])?a:b; &#125; &#125; int LCA(int u,int v) &#123; int l=first[u],r=first[v]; if (l&gt;r) swap(l,r); int k=lg[r-l+1]; int a=Minp[l][k],b=Minp[r-(1&lt;&lt;k)+1][k]; return (deep[a]&lt;deep[b])?a:b; &#125; void Soviet() &#123; sort(E+1,E+m+1); int cnt=n; G.clear(); D.Init(); F(i,1,m) if (D.Find(E[i].u)!=D.Find(E[i].v)) &#123; ++cnt; G.AddEdge(cnt,D.Find(E[i].u)); G.AddEdge(cnt,D.Find(E[i].v)); D.Merge(cnt,E[i].u); D.Merge(cnt,E[i].v); val[cnt]=E[i].w; &#125; DFS(cnt,cnt); InitST(); register int q,a,b,c,p; Rd(5,&amp;q,&amp;a,&amp;b,&amp;c,&amp;p); int ans=0; F(i,1,q) &#123; int u=(a=(a*b+c)%p)%n+1,v=(a=(a*b+c)%p)%n+1; ans=(ans+val[LCA(u,v)])%mod; &#125; printf("%d\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>思维</tag>
        <tag>生成树</tag>
        <tag>并查集</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 5308 [COCI2019] Quiz 题解]]></title>
    <url>%2F2020%2F03%2F15%2F%E6%B4%9B%E8%B0%B7-5308-COCI2019-Quiz-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述有 $n$ 个人，$k$ 轮比赛。每次如果淘汰了 $x$ 个人，还剩下 $m$ 个人，得分增加 $\dfrac{x}{m}$ 的奖金。。假设你能控制每次淘汰多少人，最大化得分。 思路设 $dp[i]$ 表示现在还剩下 $i$ 个人的最优方案 （先不考虑轮数）。 那么 $dp[i]=max(dp[j]+\dfrac{i-j}{i})$，其中 $0\le j&lt;i$ 显然能斜率优化。 觉得不显然的小伙伴们看一下：点击 斜率优化式子：若 $j\ge k$ 且 $j$ 优于 $k$，那么$dp[j]+\dfrac{i-j}{i}&gt;dp[k]+\dfrac{i-k}{i}$$dp[j]-\dfrac{j}{i}&gt;dp[k]-\dfrac{k}{i}$$dp[j]-dp[k]&gt;\dfrac{j-k}{i}$由于 $j\ge k$，所以 $j-k&gt;0$，直接除$\dfrac{dp[j]-dp[k]}{j-k}&gt;\dfrac{1}{i}$ 也就是 $slope(k,j)&gt;\dfrac{1}{i}$ 时，$k$ 就没用了。 而如果每一个时刻 $k$ 没用了，后面 $i$ 更大，$\dfrac{1}{i}$ 更小，$k$ 更不可能有用。这个是弹队首的条件。 其次可以看出来，这个队列是斜率单调递减的。这个就是加入队尾的条件。 然后我们就发现一个问题：$k$ 的限制怎么办？ 上 $wqs$ 二分： 对于每个转移过来的 $j$，我们给他加上一个附加权值 $x$。显然，$x$ 加的越多，选的段数越少。转移的时候记录一下段数，二分即可。 最后的答案是 $ans-x\times k$，一定要记住了，是 $k$。 代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define EPS 1e-12 #define real long double #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int n,k; void Input() &#123; Rd(2,&amp;n,&amp;k); &#125; real dp[N]; int cnt[N]; real slope(int x,int y)&#123;return (dp[x]-dp[y])/(1.0*x-1.0*y);&#125; int Q[N]; bool cxk(real mid) &#123; int head=1,tail=1; Q[1]=0; F(i,1,n) &#123; while(head+1&lt;=tail and slope(Q[head+1],Q[head])-1.0/i&gt;EPS) ++head; int j=Q[head]; dp[i]=dp[j]+(1.0*i-1.0*j)/(1.0*i)-mid; cnt[i]=cnt[j]+1; while(head&lt;=tail-1 and slope(Q[tail-1],Q[tail])-slope(Q[tail],i)&lt;-EPS) --tail; Q[++tail]=i; &#125; return cnt[n]&gt;=k; &#125; void Soviet() &#123; real l=0.00,r=1e6; F(i,1,100) &#123; real mid=(l+r)/2.0; if (cxk(mid)) l=mid; else r=mid; &#125; cxk(l); cout&lt;&lt;fixed&lt;&lt;setprecision(9)&lt;&lt;dp[n]+k*l&lt;&lt;endl; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>wqs二分</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1252K Addition Robot 题解]]></title>
    <url>%2F2020%2F03%2F15%2FCodeforces-1252K-Addition-Robot-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述你有一个字符串，仅由 A,B 两种字符构成。长度 $n\le 10^5$。维护 $Q$ 次操作，格式为：1 L R 区间 $[L,R]$ 中，$A$ 变成 $B$，$B$ 变成 $A$。2 L R A B 你有两个数，初始是 $A$ 和 $B$。从 $L$ 遍历到 $R$ ，如果这一位是字符 A，那么 $A=A+B$，否则 $B=A+B$，输出最后 $A$ 和 $B$ 变成什么样。 思路 [A+B,B]= [A,B]\times \begin{bmatrix} 1 & 0\\ 1 & 1 \end{bmatrix} [A,A+B]= [A,B]\times \begin{bmatrix} 1 & 1\\ 0 & 1 \end{bmatrix}线段树区间维护矩阵积，然后用 $[A,B]$ 左乘这个矩阵积，就能得到最后的 $A,B$。 关于交换操作：我们维护矩阵积的时候，维护取反后的矩阵积 （就是把 $A$ 变成 $B$ ，把 $B$ 变成 $A$ 后的矩阵积）。交换的时候，把两个矩阵积换一下，然后下传标记即可。 代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define mod 1000000007 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class Matrix //矩阵 &#123; #define S 5 private: int a[S][S]; public: int n; Matrix() &#123; memset(a,0,sizeof(a)); n=0; &#125; Matrix(int _n) &#123; memset(a,0,sizeof(a)); n=_n; &#125; Matrix(int _n,int _x) &#123; n=_n; for(int i=0;i&lt;S;++i) &#123; for(int j=0;j&lt;S;++j) &#123; a[i][j]=_x; &#125; &#125; &#125; int* operator[](int i) &#123; return *(a+i); &#125; void Identity() &#123; memset(a,0,sizeof(a)); for(int i=0;i&lt;S;++i) &#123; a[i][i]=1; &#125; &#125; #undef S //5 &#125;A(2,1),B(2,1),I(2,0); // A: A=A+B 的变换矩阵 // B: B=A+B 的变换矩阵 // I: 单位矩阵 Matrix operator*(Matrix x,Matrix y) //并不需要用到快速幂的操作,于是我没写 &#123; Matrix ans(x.n,0); int n=ans.n; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) &#123; if (x[i][j]) &#123; for(int k=1;k&lt;=n;++k) &#123; ans[i][k]=(ans[i][k]+1ll*x[i][j]*y[j][k]%mod)%mod; &#125; &#125; &#125; &#125; return ans; &#125; char a[N]; class SegmentTree &#123; public: struct node&#123;int l,r; bool c; Matrix w[2];&#125;tree[N&lt;&lt;2]; #define ls index&lt;&lt;1 #define rs index&lt;&lt;1|1 #define L tree[index].l #define R tree[index].r #define W tree[index].w #define C tree[index].c #define lL tree[ls].l #define lR tree[ls].r #define lW tree[ls].w #define lC tree[ls].c #define rL tree[rs].l #define rR tree[rs].r #define rW tree[rs].w #define rC tree[rs].c void Update(int index=1) &#123; W[0]=lW[0]*rW[0]; W[1]=lW[1]*rW[1]; &#125; void Build(int l,int r,int index=1) &#123; L=l,R=r; if (l==r) &#123; if (a[l]=='A') &#123;W[0]=A; W[1]=B;&#125; // W[0] 维护当前矩阵，W[1] 维护取反后的矩阵 else &#123;W[0]=B; W[1]=A;&#125; // 这个边界显然吧... return; &#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,ls); Build(mid+1,r,rs); Update(index); &#125; void FlipOne(int index=1) &#123;C^=1; swap(W[0],W[1]);&#125; // 交换一下 W[0] 和 W[1] void PushDown(int index=1) //记得下传标记 &#123; if (C) &#123; FlipOne(ls); FlipOne(rs); C=0; &#125; &#125; void Flip(int l,int r,int index=1) //区间反转 &#123; if (l&gt;R or L&gt;r) return; if (l&lt;=L and R&lt;=r) return FlipOne(index); PushDown(index); Flip(l,r,ls); Flip(l,r,rs); Update(index); &#125; Matrix Query(int l,int r,int index=1) //注意：区间矩阵积返回的是一个矩阵 &#123; if (l&gt;R or L&gt;r) return I; if (l&lt;=L and R&lt;=r) return W[0]; PushDown(index); return Query(l,r,ls)*Query(l,r,rs); &#125; &#125;T; int n,m; void Input() &#123; Rd(2,&amp;n,&amp;m); scanf("%s",a+1); A[1][2]=0; B[2][1]=0; I.Identity(); /* A= [1 0] [1 1] B= [1 1] [0 1] */ T.Build(1,n); &#125; void Soviet() &#123; F(i,1,m) &#123; int o;R1(o); if (o==1) &#123;int l,r;Rd(2,&amp;l,&amp;r); T.Flip(l,r);&#125; if (o==2) &#123; int l,r,a,b; Rd(4,&amp;l,&amp;r,&amp;a,&amp;b); a%=mod; b%=mod; Matrix Trans(2,0); Trans=T.Query(l,r); // 转移纠正 Matrix Init(2,0); Init[1][1]=a; Init[1][2]=b; // 初始矩阵就是 [A,B] Init=Init*Trans; printf("%d %d\n",Init[1][1],Init[1][2]); &#125; &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>矩阵乘法</tag>
        <tag>转换思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libreoj 10069 「一本通 3.1 练习 4」Tree 题解]]></title>
    <url>%2F2020%2F03%2F15%2Flibreoj-10069-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-1-%E7%BB%83%E4%B9%A0-4%E3%80%8DTree-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述一个图有 $n$ 个点 $m$ 条边，每个边是白色或黑色。生成一棵树使得白边的数量恰好是 $k$，并且边权和最小。输出最小的边权和。 $1\le n,m\le 10^5$，边权在 $[1,100]$ 之间 思路我们在跑朴素的 Kruskal 的时候，把每个白边都调的贵一点，或者便宜一点。把白边弄便宜的时候，就会多选几个白边，反之就会少选几个白边。 所以我们二分一个附加权值 $x$，可正可负。每个白边的权值都 +=x 。如果这样选出来的白边数量 $\le k$，那么 $x$ 应该更小一点（整便宜点，让我们可以多选几个），否则 $x$ 应该更大一点（同理）。 那么最后的答案就是 $sum-k\times x$。 （$sum$ 为附加值为 $x$ 时的最小生成树）注意！是 $sum-k\times x$，而不是 $sum-white\times x$ （其中 $white$ 为选出的白边的数量） 代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class DSU //并查集 &#123; public: int Fa[N],Cnt[N]; void Init() &#123;F(i,0,N-1) Fa[i]=i,Cnt[i]=1;&#125; int Find(int u) &#123;return u==Fa[u]?u:Fa[u]=Find(Fa[u]);&#125; bool Merge(int u,int v) &#123; int au=Find(u),av=Find(v); if (au==av) return false; if (Cnt[au]&lt;Cnt[av]) Cnt[av]+=Cnt[au],Fa[au]=av; else Cnt[au]+=Cnt[av],Fa[av]=au; return true; &#125; &#125;D; struct Edge&#123;int u,v,w,c;&#125;E[N]; //存边 bool operator&lt;(Edge a,Edge b)&#123;return a.w&lt;b.w or (a.w==b.w and a.c&lt;b.c);&#125; int n,m,k; void Input() &#123; Rd(3,&amp;n,&amp;m,&amp;k); F(i,1,m) &#123;int u,v,w,c; Rd(4,&amp;u,&amp;v,&amp;w,&amp;c); ++u,++v; E[i]=(Edge)&#123;u,v,w,c&#125;;&#125; &#125; int sum=0,white=0; void MST(int delt) //delt为附加权值 &#123; sum=white=0; F(i,1,m) if (E[i].c==0) E[i].w+=delt; //每个白边权值都加上delt D.Init(); sort(E+1,E+m+1); int cnt=0; F(i,1,m) if (D.Find(E[i].u)!=D.Find(E[i].v)) &#123; D.Merge(E[i].u,E[i].v); sum+=E[i].w; white+=(E[i].c==0); ++cnt; if (cnt==n-1) break; &#125; F(i,1,m) if (E[i].c==0) E[i].w-=delt; //记得改回来 &#125; void Soviet() &#123; int l=-1000,r=1000; int ans; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; MST(mid); if (white&gt;=k) ans=sum-k*mid,l=mid+1; //答案是sum-k*mid，而不是sum-white*mid else r=mid-1; &#125; printf("%d\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>生成树</tag>
        <tag>wqs二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治 笔记]]></title>
    <url>%2F2020%2F03%2F15%2F%E7%82%B9%E5%88%86%E6%B2%BB-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[算法概述点分治用来统计树上满足某种条件的路径个数，一般具有可合并答案的性质（比如是否存在路径长度 $=k$等）。 算法步骤首先我们考虑经过根节点的满足条件的路径有多少。那比如我们就拿长度为 $k$ 举例，先从根节点 $DFS$ 一遍，求出每个节点的 $dis$。然后对于一个节点的 $dis[i]$，统计 $k-dis[i]$ 是否存在即可。如果存在，那么就有。 当然，并不是所有的路径都经过根节点。那么，不经过根节点的路径，一定经过根节点子树中的某个点。 那么我们把根节点的每个子树都分治一遍（递归），不就能求出答案了吗？ 但是我们发现这样太慢了，复杂度为 $O(n\times C)$，其中 $C$ 为递归的次数。但是很显然，树为一条链的时候，$C=n$，复杂度变成 $O(n^2)$。 如何优化这个算法呢？也很简单，我们都有 $DFS$ 一遍的时间，顺便把每颗子树的重心都求出来好了。 然后对于每个子树，我们递归这个子树的时候，以重心为根。 这样，容易证明，递归次数 $C\le\log n$。 模板题洛谷 3806：给一颗树，多组询问是否存在长度为 $k$ 的路径。$n\le 10^4,m\le 100$ 解法：每次点分治的时候，维护一个 $bool$ 数组 $cxk$，$cxk[i]$ 表示是否存在 $dis[k]=i$。分治的时候，遍历每个询问 $k$，如果 $cxk[k-dis[i]]$，那么这个询问答案变成 $true$ （题目要求输出 AYE） 总的复杂度是 $O(nm\log n)$ 模板题代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define K 100000007 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class Graph // 图 &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[N&lt;&lt;1]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; int n,m; int q[N]; void Input() &#123; Rd(2,&amp;n,&amp;m); G.clear(); F(i,1,n-1) &#123;int u,v,w;Rd(3,&amp;u,&amp;v,&amp;w); G.Add2(u,v,w);&#125; F(i,1,m) &#123;R1(q[i]);&#125; &#125; bool vis[N]; bitset&lt;K&gt; cxk,test; // cxk[i] 表示是否存在 dis[k]=i // test[i] 表示第 i 个询问的答案 int size[N],bal[N]; int root,sum; // 这些是求重心的 void GetBal(int u,int f) &#123; size[u]=1; bal[u]=0; Tra(i,u) if (v!=f and !vis[v]) &#123; GetBal(v,u); size[u]+=size[v]; bal[u]=max(bal[u],size[v]); &#125; bal[u]=max(bal[u],sum-size[u]); if (bal[u]&lt;bal[root]) root=u; &#125; int rec[N],dis[N]; void GetDis(int u,int f) // 这个 DFS 用来求 dis，顺便把所有的 dis 数组记录在一个数组 rec 里 // 由于是 1 编号，不用的 rec[0] 就用来存长度 &#123; rec[++rec[0]]=dis[u]; Tra(i,u) if (v!=f and !vis[v]) &#123; dis[v]=dis[u]+G.Label(i); GetDis(v,u); &#125; &#125; void calc(int u) // 计算以 u 为根的答案 &#123; vector&lt;int&gt; d; Tra(i,u) if (!vis[v]) &#123; rec[0]=0; dis[v]=G.Label(i); GetDis(v,u); D(j,rec[0],1) F(k,1,m) if (q[k]&gt;=rec[j]) // 注意 q[k]&gt;=rec[j] &#123; test[k]=test[k]|cxk[q[k]-rec[j]]; &#125; D(j,rec[0],1) &#123;d.p_b(rec[j]); cxk[rec[j]]=1;&#125; &#125; F(i,0,sz(d)-1) cxk[d[i]]=0; &#125; void DFS(int u) &#123; vis[u]=cxk[0]=1; calc(u); // 计算以 u 为根的答案 Tra(i,u) if (!vis[v]) &#123; sum=size[v]; bal[root=0]=0x3f3f3f3f; GetBal(v,v); DFS(root); //求出重心，递归子树 &#125; &#125; void Soviet() &#123; sum=bal[root=1]=n; GetBal(1,1); DFS(root); F(i,1,m) puts(test[i]?"AYE":"NAY"); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces 916E Jamie and Tree 题解]]></title>
    <url>%2F2020%2F03%2F15%2Fcodeforces-916E-Jamie-and-Tree-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个 $n\le 10^5$ 个点带权的树，初始根为 $1$。支持三种操作：1 r 把根换成 $r$2 u v x 把 $LCA(u,v)$ 的子树整体加 $x$3 u 查询 $u$ 的子树点权和 操作数$\le 10^5$。每个点权 $\le 10^8$ 。 思路如果没有 $1$ 操作，那 $2,3$ 操作显然就是一个板子。 但是现在有了 $1$ 操作。 那么我们就要考虑几个问题： 如何求 LCA 如何知道子树是哪一块 （对其进行求和或加值） 当然，无根树肯定是不好讨论的。我们先假定 $1$ 为根。 然后判断以 $r$ 为根的子树长什么样。 为了不混淆，设：$LCA(u,v,r)$ 表示以 $r$ 为根，$u,v$ 的 $LCA$。$SUB(u,r)$ 表示以 $r$ 为根，$u$ 的子树。 路径不需要重新定义，因为路径是唯一确定的，和根无关。 求LCA假设我们要求 $LCA(u,v,r)$。 如果当前的根 $r$ 在 $u,v$ 的路径上，那么显然 $LCA(u,v,r)=r$。 否则，设 $L=LCA(u,v,1)$。 如果当前的根在 $SUB(L,1)$ 外，那么 $LCA(u,v,r)=L$，就不会有影响 再否则，$LCA(u,v,r)$ 就是 $u,v$ 路径上的某个点了。稍微想一下，这个点是 $LCA(u,r,1)$ 或者 $LCA(v,r,1)$ 中的一个。 再仔细想想，似乎是选深的那一个（以 $1$ 为根）。那么如果同样深怎么办呢？继续想想，$LCA(u,r,1)$ 和 $LCA(v,r,1)$ 肯定一个是 $LCA(u,v,1)$ ，一个是 $LCA(u,v,r)$。如果深度相同，那就说明 $LCA(u,r,1)=LCA(v,r,1)=LCA(u,v,1)$ 。这个时候选哪个也无所谓了，反正都是对的。 求某个子树假设我们要求 $SUB(u,r)$ $u=r$。 最简单的情况，子树就是整棵树 （但是不能忘记特判！） $r$ 在 $SUB(u,1)$ 之外。 这也很显然，$SUB(u,r)=SUB(u,1)$。 关键问题就是 $r$ 在 $SUB(u,1)$ 之内的情况咋整。 我们画一张图： 很明显，此时 $SUB(u,r)$ 就等于整棵树中减去 $SUB(k,1)。（这张图有一个没画全的地方，就是 $u$ 上面可能还有别的点） 而 $k$ 的值，也就是 $r$ 在 $u$ 的哪个子树里面，这个可以用倍增求。 总结我们发现，最后的操作，只有子树加减，和单点求和的操作。甚至不用写树链剖分。这个用 $DFS$ 序维护就能解决。 代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 255555 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[N&lt;&lt;1]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; class SegmentTree //线段树 区间加 区间求和 &#123; public: struct node&#123;int l,r,s,a;&#125;tree[N&lt;&lt;2]; #define ls index&lt;&lt;1 #define rs index&lt;&lt;1|1 #define L tree[index].l #define R tree[index].r #define S tree[index].s #define A tree[index].a #define lL tree[ls].l #define lR tree[ls].r #define lS tree[ls].s #define lA tree[ls].a #define rL tree[rs].l #define rR tree[rs].r #define rS tree[rs].s #define rA tree[rs].a void Update(int index=1) &#123; S=lS+rS; &#125; void Build(int l,int r,int index=1) &#123; L=l,R=r;S=A=0; if (l==r) &#123;return;&#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,ls); Build(mid+1,r,rs); Update(index); &#125; void AddOne(int x,int index=1) &#123; A+=x; S+=(R-L+1)*x; &#125; void PushDown(int index=1) &#123; if (A) &#123;AddOne(A,ls); AddOne(A,rs); A=0;&#125; &#125; void Add(int l,int r,int x,int index=1) &#123; if (l&gt;R or L&gt;r) return; if (l&lt;=L and R&lt;=r) return AddOne(x,index); PushDown(index); Add(l,r,x,ls); Add(l,r,x,rs); Update(index); &#125; int Query(int l,int r,int index=1) &#123; if (l&gt;R or L&gt;r) return 0; if (l&lt;=L and R&lt;=r) return S; PushDown(index); return Query(l,r,ls)+Query(l,r,rs); &#125; &#125;T; int n,m; int a[N]; void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,1,n) R1(a[i]); G.clear(); F(i,1,n-1) &#123;int u,v;Rd(2,&amp;u,&amp;v); G.Add2(u,v);&#125; &#125; int In[N],Out[N],Time=0; int fa[N][22],deep[N]; void DFS(int u,int f) &#123; In[u]=++Time; deep[u]=(u==f)?0:deep[f]+1; fa[u][0]=f; F(i,1,20) fa[u][i]=fa[fa[u][i-1]][i-1]; Tra(i,u) if (v!=f) &#123; DFS(v,u); &#125; Out[u]=Time; &#125; int FindSon(int u,int f) //求 u 在 f 的哪个子树里 （u相对于f的k值） &#123; D(i,20,0) if (deep[fa[u][i]]&gt;deep[f]) u=fa[u][i]; return u; &#125; bool IsFa(int u,int f) //这个判断f是否是u的祖先 &#123; if (deep[u]&lt;deep[f]) return false; if (u==f) return true; return fa[FindSon(u,f)][0]==f; &#125; //upd: 傻了，这个直接DFS序判断即可 int LCA(int u,int v) &#123; if (deep[u]&lt;deep[v]) swap(u,v); D(i,20,0) if (deep[fa[u][i]]&gt;=deep[v]) u=fa[u][i]; if (u==v) return u; D(i,20,0) if (fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; return fa[u][0]; &#125; //非常正常的LCA bool OnPath(int u,int v,int k) &#123; int l=LCA(u,v); if (l==k) return true; return !IsFa(l,k) and (IsFa(u,k) or IsFa(v,k)); &#125; //判断k是否在u,v路径上 void SubtAdd(int u,int x)&#123;T.Add(In[u],Out[u],x);&#125; //子树加 int SubtSum(int u) &#123;return T.Query(In[u],Out[u]);&#125; //子树求和 void Soviet() &#123; DFS(1,1); T.Build(1,n); F(i,1,n) T.Add(In[i],In[i],a[i]); //初始化 int root=1; //这个别忘了 F(i,1,m) &#123; int o;R1(o); if (o==1) &#123; int u;R1(u); root=u; //非常简单的换根操作 &#125; if (o==2) &#123; int u,v,x;Rd(3,&amp;u,&amp;v,&amp;x); int l=LCA(u,v); if (OnPath(u,v,root)) &#123; //特判: 如果root在u,v路径上，那么LCA(u,v,root)==root，直接加整个树 T.Add(1,n,x); &#125; else if (In[root]&lt;In[l] or Out[l]&lt;In[root]) &#123; //如果root不在x子树内，那么没有影响，和根为1情况一样 SubtAdd(l,x); &#125; else &#123; T.Add(1,n,x); //整个加 if (deep[LCA(root,u)]&lt;deep[LCA(root,v)]) swap(u,v); int k=FindSon(root,LCA(root,u)); //找到k SubtAdd(k,-x); //把k的子树减掉 &#125; &#125; if (o==3) &#123; int u;R1(u); //这个和上面类似的 if (root==u) &#123; printf("%lld\n",T.Query(1,n)); &#125; else if (In[root]&lt;In[u] or Out[u]&lt;In[root]) &#123; printf("%lld\n",SubtSum(u)); &#125; else &#123; int k=FindSon(root,u); printf("%lld\n",T.Query(1,n)-SubtSum(k)); //整棵树-k的子树 &#125; &#125; &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>树形结构</tag>
        <tag>倍增</tag>
        <tag>DFS序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libreoj 125 除数函数求和2 题解]]></title>
    <url>%2F2020%2F03%2F14%2Flibreoj-125-%E9%99%A4%E6%95%B0%E5%87%BD%E6%95%B0%E6%B1%82%E5%92%8C2-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定 $n$，求 $\sum\limits_{i=1}^{n} 2\sigma_2(i)+3\sigma_1(i)+5\sigma_0(i)$ $n&lt;=1e9$ 其中 $\sigma_k(x)=x$ 所有因数的 $k$ 次方和。 思路我们反过来想，枚举每个因数对答案产生了多少贡献。 显然，一个因数 $d$ 对答案产生的贡献就是 $2d^2+3d+5$。 那么有多少 $i$ 算到了这个 $d$ 呢？只要是 $d$ 的倍数，都能算到，所以一共有 $\lfloor \dfrac{n}{d}\rfloor$ 个。 答案变成了 $\sum\limits_{d=1}^{n} (2d^2+3d+5)\lfloor \dfrac{n}{d}\rfloor$ 整除分块，一次 $O(\sqrt{n})$ 代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define int long long #define mod 998244353 #define i2 499122177 #define i6 166374059 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int n; void Input() &#123; R1(n); &#125; int s1(int x) &#123;x%=mod; return x*(x+1)%mod*i2%mod;&#125; int s2(int x) &#123;x%=mod; return x*(x+1)%mod*(2*x+1)%mod*i6%mod;&#125; int S(int x) &#123;return 5*x%mod+3*s1(x)%mod+2*s2(x)%mod;&#125; void Soviet() &#123; int ans=0; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); ans+=(n/l)%mod*(S(r)-S(l-1)+mod)%mod; ans%=mod; &#125; printf("%lld\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libreoj 6029 「雅礼集训 2017 Day1」市场 题解]]></title>
    <url>%2F2020%2F03%2F03%2Flibreoj-6029-%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD-2017-Day1%E3%80%8D%E5%B8%82%E5%9C%BA-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个长度为 $n\le 10^5$ 的序列，初始值$\le 10^9$，支持：1 l r x 区间 $[l,r]$ 每个数加上 $x$ 。 $|x|&lt;=10^4,1\le l\le r\le n$2 l r x 区间 $[l,r]$ 每个数除以 $x$ （下取整），$2\le x\le 1e9,1\le l\le r\le n$3 l r 求 $[l,r]$ 中的最小值4 l r 求 $[l,r]$ 的和询问数 $\le 10^5$ 思路显然线段树。 我们把区间除法分解成区间内每个数都减去某个数。设 $d(a,x)$ 表示 $a$ 除以 $x$ 下取整的变化量，也就是 $a-a/x$。那么 $a\leftarrow a/x$ 的操作，就等价于 $a\leftarrow a-d(a,x)$。显然，当 $x$ 相同的时候， $d$ 函数单调不减。具体的说，如果 $a&lt;b$，则 $d(a,x)\le d(b,x)$ ，对于所有正整数 $x$。 那么对于一段区间，如果 $d(Max,x)=d(Min,x)$，那么这个区间中，所有数的变化量都一样了，直接上区间减法来解决。 否则我们继续把这个区间分成左右两个部分，直到这个区间满足上述条件即可。 分析复杂度那么这个算法的复杂度是多少呢？看起来每次的最坏情况是暴力的 $O(r-l+1)$ ，但是我们注意到，加法操作中的 $x$ 最大才加 $10000$，但是一次除法操作每次至少除以 $2$。 那比如我是毒瘤出题人，我要卡我的代码，那肯定是要尽量多的加法操作（因为会减慢除法操作），但是也不能少了除法操作（因为看起来很慢）。那假设数据里有 $5\times 10^4$ 个加法操作，还有 $5\times 10^4$ 个除法操作。然后每个数一开始都是 $10^9$ 的规模（不一定恰好是 $10^9$ ，全部相同反而会加快除法操作）。 那加完之后每个数都是 $1.5\times 10^9$ 左右。那么我们把它除个 $31$ 次就全部变成 $0$ 了，那肯定变化量相同，就是能用 $O(log)$ 的减法操作实现了。 那总共就相当于 $O(n \log n \log a)$ ，其中 $a$ 是初始的值域，$\log a$ 大约要到 $32$ 了。 代码 (今天测试一下展开功能)点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class SegmentTree &#123; public: struct node&#123;int l,r,s,m,x,a;&#125;tree[N&lt;&lt;2]; #define ls index&lt;&lt;1 #define rs index&lt;&lt;1|1 #define L tree[index].l #define R tree[index].r #define S tree[index].s #define M tree[index].m #define X tree[index].x #define A tree[index].a #define lL tree[ls].l #define lR tree[ls].r #define lS tree[ls].s #define lM tree[ls].m #define lX tree[ls].x #define lA tree[ls].a #define rL tree[rs].l #define rR tree[rs].r #define rS tree[rs].s #define rM tree[rs].m #define rX tree[rs].x #define rA tree[rs].a void Update(int index=1) &#123; S=lS+rS; M=min(lM,rM); X=max(lX,rX); &#125; void Build(int l,int r,int index=1) &#123; L=l,R=r; A=0; if (l==r) &#123;R1(S);M=X=S;return;&#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,ls); Build(mid+1,r,rs); Update(index); &#125; void AddOne(int x,int index=1) &#123; A+=x; M+=x; X+=x; S+=(R-L+1)*x; &#125; void PushDown(int index=1) &#123; if (A) &#123; AddOne(A,ls); AddOne(A,rs); A=0; &#125; &#125; void Add(int l,int r,int x,int index=1) &#123; if (l&gt;R or L&gt;r) return; if (l&lt;=L and R&lt;=r) return AddOne(x,index); PushDown(index); Add(l,r,x,ls); Add(l,r,x,rs); Update(index); &#125; int fld(int a,int b) &#123; int aa=abs(a),bb=abs(b); if ((a&gt;0)^(b&gt;0)) return -(aa+bb-1)/bb; else return aa/bb; &#125; void Div(int l,int r,int d,int index=1) &#123; if (l&gt;R or L&gt;r) return; if (l&lt;=L and R&lt;=r) &#123; int dmax=X-fld(X,d),dmin=M-fld(M,d); if (dmax==dmin) &#123; AddOne(-dmax,index); return; &#125; &#125; PushDown(index); Div(l,r,d,ls); Div(l,r,d,rs); Update(index); &#125; int QueryMin(int l,int r,int index=1) &#123; if (l&gt;R or L&gt;r) return 0x3f3f3f3f3f3f3f3fll; if (l&lt;=L and R&lt;=r) return M; PushDown(index); return min(QueryMin(l,r,ls),QueryMin(l,r,rs)); &#125; int QuerySum(int l,int r,int index=1) &#123; if (l&gt;R or L&gt;r) return 0; if (l&lt;=L and R&lt;=r) return S; PushDown(index); return QuerySum(l,r,ls)+QuerySum(l,r,rs); &#125; &#125;T; int n,m; void Input() &#123; Rd(2,&amp;n,&amp;m); T.Build(1,n); &#125; void Soviet() &#123; F(i,1,m) &#123; int o,l,r;Rd(3,&amp;o,&amp;l,&amp;r); ++l,++r; if (o==1) &#123; int x;R1(x);T.Add(l,r,x); // F(i,1,n) printf("%lld ",T.QuerySum(i,i)); putchar('\n'); &#125; if (o==2) &#123; int d;R1(d);T.Div(l,r,d); // F(i,1,n) printf("%lld ",T.QuerySum(i,i)); putchar('\n'); &#125; if (o==3) &#123; printf("%lld\n",T.QueryMin(l,r)); &#125; if (o==4) &#123; printf("%lld\n",T.QuerySum(l,r)); &#125; &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noi.ac 357 partner 题解]]></title>
    <url>%2F2020%2F03%2F03%2Fnoi-ac-357-partner-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述（数据结构做傻了系列）给你一列数，求有多少对$(i,j)$满足 $0.9a_j\le a_i\le a_j$。 思路框架显然先排序，设 $b_i=0.9a_i$ （double型即可），然后每次 $lower_bound$找一下即珂。 像这样的水题我居然会想用树状数组做…我也是数据结构做傻了 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 255555 #define int long long #define real double #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int n,a[N]; void Input() &#123; R1(n); F(i,1,n) R1(a[i]); sort(a+1,a+n+1); &#125; real b[N]; void Soviet() &#123; F(i,1,n) b[i]=a[i]*0.9; int ans=0; F(i,1,n-1) &#123; int p2=upper_bound(b+i+1,b+n+1,(real)a[i])-b-1; int p1=lower_bound(a+i+1,a+p2,a[i])-a; ans+=p2-p1+1; &#125; printf("%lld\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
        <tag>思维</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BSGS算法 笔记]]></title>
    <url>%2F2020%2F03%2F02%2FBSGS%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[算法概述BSGS，全名叫Big Step Giant Step算法，在中国被称为“拔山盖世算法”，或者叫“北上广深”算法。 它用来求解最小的 $x$ 满足 $A^x \equiv B \pmod{p}$，你可以认为是数论意义下的开 $\log$。 我们这里只讨论 $p$ 为质数的情况。 算法步骤$BSGS$ 的精髓在于，我只求一部分答案，就能很快的求另一部分答案。 首先 $A^{x-1} \equiv 1 \pmod{p}$。那么我们的 $x$ 只要在 $[0,p-1]$ 内枚举即珂。 首先特判 $B=1$，则 $x=0$。 假设现在有一个 $m$ ，我们知道了 $x=[1,m]$ 时 $A^x$ 的值（存在map&lt;&gt;里面），如果满足条件的 $x\le m$，就直接得结果了。 否则，我们假设满足条件的 $x=m+i$（$1\le i\le m$）。那么 $A^m\times A^i \equiv B \pmod{p}$。 则 $A_i=B\times A^{-m} \pmod{p}$。由于 $1\le i\le m$ 这一段中 $A^x$ 的值我们记录过了，我们只要在map里面找是否存在 $B\times A^{-m}$ 即珂。 然后这样我们就求出了 $m+1,m+2…2m$ 间有没有解，只用了一次 map 的查询。 同理，我们假设满足条件的 $x=km+i$，$1\le i\le m$，就能进而求出 $[1,p]$ 中的所有解了。 这个算法的复杂度是 $O(min\{m\log m,\dfrac{p}{m}\log m\})$。 显然， $m=\sqrt{p}$ 的时候，这个式子最小，等于 $O(\sqrt{p} \log \sqrt{p})$。 模板题洛谷 4028（洛谷上没有BSGS的板子，只有exBSGS，那个我不会） 代码（仅BSBS部分）1234567891011121314151617181920212223242526272829303132#define F(i,l,r) for(int i=l;i&lt;=r;++i)int qpow(int a,int b,int m)&#123; int r=1; while(b) &#123; if (b&amp;1) r=r*a%m; a=a*a%m,b&gt;&gt;=1; &#125; return r;&#125;map&lt;int,int&gt; x;map&lt;int,bool&gt; vis;int BSGS(int a,int b,int p) //a^x=b (mod p)&#123; x.clear(); vis.clear(); a%=p; b%=p; if (a==0) &#123;return -1;&#125; int m=(sqrt(p+0.5)); int ia_m=qpow(a,p-2,p); ia_m=qpow(ia_m,m,p); //ia_m=a^-m int cur=1; F(i,0,m-1) &#123;x[cur]=(!vis[cur])?i:min(x[cur],i);vis[cur]=1;cur=cur*a%p;&#125; if (vis[b]) return x[b]; cur=1; F(i,1,p/m) &#123; int tmp=b*qpow(ia_m,i,p)%p; //tmp=b*a^(-mi) if (vis[tmp]) return i*m+x[tmp]; &#125; return -1;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>数论</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 2472 [SCOI2007]蜥蜴 题解]]></title>
    <url>%2F2020%2F03%2F02%2F%E6%B4%9B%E8%B0%B7-2472-SCOI2007-%E8%9C%A5%E8%9C%B4-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述(这题超套路…)有一个 $n\times m$ 的矩阵，其中一些位置上有蜥蜴。每个位置上有一个石柱，给你他们初始的高度 $a_{i,j}$。一个蜥蜴可以从一个石柱，跳到直线距离 $\le k$ 的另一个石柱上。当一只蜥蜴从一个石柱上离开的时候，这个石柱的高度就会减少 $1$ 。如果蜥蜴跳到了矩阵外面，就是逃离了。请你求最少有多少只不能逃离（其实就是最多能逃离几只）。 $1&lt;=n,m&lt;=20$，$k&lt;=4$。 【附】直线距离：从 $(x1,y1)$ 到 $(x2,y2)$ 的直线距离为： $\sqrt{(x1-x2)^2+(y1-y2)^2}$ 思路框架显然建网络流。首先我们把矩阵展开，就是把 $(i,j)$ 位置的点编号为 $(i-1)m+j$。 每个石柱上只能通过定量的蜥蜴，这显然是一个点限流。套路拆点，每个位置变成 $In(i,j)$ 和 $Out(i,j)$。设源点为 $S$ ，汇点为 $T$。 对于每个点 $(i,j)$： $In(i,j) \xrightarrow[a_{i,j}]{} Out(i,j)$ （一个石柱上只能通过 $a_{i,j}$ 个蜥蜴）$S \xrightarrow[1]{} In(i,j)$ （一个石柱上只能有一个蜥蜴）$Out(i,j) \xrightarrow[inf]{} T$ （跳出终点就随便了） 对于点 $(i,j)$ 和点 $(u,v)$ 满足 $(i,j)$ 到 $(u,v)$ 直线距离 $\le k$：$Out(i,j) \xrightarrow[inf]{} In(u,v)$ （点之间跳是不限的）$Out(u,v) \xrightarrow[inf]{} In(i,j)$ 这样跑一个最大流即珂。 Q：为什么点到点，点到 $T$ 之间都是 $inf$ 的边呢？怎么就“随便”了？A：其实并不是随便，我们知道，网络流上一个流能流过的值是其路径上的最小值。那么既然 $In(i,j)$ 到 $Out(i,j)$ 的时候，已经限过了一次 $a_{i,j}$ ，那我们从 $Out(i,j)$ 到 $In(u,v)$ 的时候，再限一次也没有必要了。当然，你如果实在要限这条边流量为 $a_{i,j}$，没有任何问题。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1333 #define INF 0x3f3f3f3f #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class Graph //这些是板子 &#123; public: int EdgeCount; int head[N]; struct Edge &#123; int To,Label; int Next; &#125;Ed[200100]; void clear() &#123; MEM(head,-1); MEM(Ed,-1); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w) &#123; ++EdgeCount; Ed[EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void AddFlow(int u,int v,int w) &#123; AddEdge(u,v,w); AddEdge(v,u,0); &#125; int Source,Sink; int deep[N]; queue&lt;int&gt;Q,EmptyQ; bool BFS() &#123; Q=EmptyQ; FK(deep); Q.push(Source); deep[Source]=1; do &#123; int u=Q.front();Q.pop(); for(int i=head[u];~i;i=Ed[i].Next) &#123; int v=Ed[i].To; if (deep[v]==0 and Ed[i].Label&gt;0) &#123; deep[v]=deep[u]+1; Q.push(v); &#125; &#125; &#125;while(!Q.empty()); if (deep[Sink]==0) return 0; return 1; &#125; int DFS(int u,int MinFlow) &#123; if (u==Sink) return MinFlow; for(int i=head[u];~i;i=Ed[i].Next) &#123; int v=Ed[i].To; if (deep[v]==deep[u]+1 and Ed[i].Label!=0) &#123; int d=DFS(v,min(MinFlow,Ed[i].Label)); if (d&gt;0) &#123; Ed[i].Label-=d; Ed[i^1].Label+=d; return d; &#125; &#125; &#125; return 0; &#125; int Dinic() &#123; int ans=0; while(BFS()) &#123; int d; while(d=DFS(Source,0x3f3f3f3f)) &#123; ans+=d; &#125; &#125; return ans; &#125; &#125;Nt; #define S Nt.Source #define T Nt.Sink #define id(i,j,x) (x*n*m+(i-1)*m+j) //(x,y,0): In //(x,y,1): Out int n,m,k; int cnt; int a[N][N]; char t[N]; void Input() &#123; Rd(3,&amp;n,&amp;m,&amp;k); F(i,1,n) F(j,1,m) scanf("%1d",&amp;a[i][j]); Nt.clear(); S=2*n*m+1,T=2*n*m+2; F(i,1,n) &#123; scanf("%s",t+1); F(j,1,m) if (t[j]=='L' and a[i][j]&gt;0) //如果一开始石柱就没了，我们就忽略这个蜥蜴 &#123; ++cnt; Nt.AddFlow(S,id(i,j,0),1); &#125; &#125; &#125; void Soviet() &#123; F(i,1,n) F(j,1,m) Nt.AddFlow(id(i,j,0),id(i,j,1),a[i][j]); //建In(i,j)到Out(i,j)的边 F(i,1,n) F(j,1,m) if (i-k&lt;1 or j-k&lt;1 or i+k&gt;n or j+k&gt;m) &#123; Nt.AddFlow(id(i,j,1),T,INF); //建立到终点的边 &#125; F(i,1,n) F(j,1,m) F(u,max(i-k,1),min(i+k,n)) F(v,max(j-k,1),min(j+k,m)) if (a[i][j] and a[u][v]) &#123; if (i==u and v==j) continue; if ((i-u)*(i-u)+(j-v)*(j-v)&lt;=k*k) //直线距离&lt;=k &#123; Nt.AddFlow(id(i,j,1),id(u,v,0),INF); Nt.AddFlow(id(u,v,1),id(i,j,0),INF); //建边 &#125; &#125; printf("%d\n",cnt-Nt.Dinic()); //蜥蜴的数量-最大的能逃脱的数量，就是最少的不能逃脱的数量 &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>水题</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 5242 [USACO19FEB]Cow Dating P 题解]]></title>
    <url>%2F2020%2F03%2F02%2F%E6%B4%9B%E8%B0%B7-5242-USACO19FEB-Cow-Dating-P-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[noi.ac 41 最短路 题解]]></title>
    <url>%2F2020%2F02%2F27%2Fnoi-ac-41-%E6%9C%80%E7%9F%AD%E8%B7%AF-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给你一个 $n$ 个点的边带权的树，还有 $m$ 个新增的修建计划，以及 $Q$ 个询问。每一个询问的格式是：给定 $s,t,l,r$ ，问你，如果动用 $[l,r]$ 之间的修建计划，从 $s$ 到 $t$ 的路径中，边权异或和最小是多少？ 询问之间是独立的，在某一个询问里加入的修建计划，询问完就会拆掉。并且修建计划保证不是树上原来就有的边。 $n,m,q\le 3\times 10^5$，所有的边权（树上和修建计划） $\le 10^9$。对于每个询问，$1\le s,t\le n$，并且$1\le l\le r\le m$。 思路由 bzoj 2115 的结论得，一张图上从 $s$ 到 $t$ 的路径的异或和，可以由另外一条路径的异或和，异或上几个环的异或和得到。 然后我们珂以先取初始值为 $s$ 到 $t$ 树上路径的异或和，然后在把所有环的异或和放到线性基里，求最小异或和。 本题还限制了只能动用 $[l,r]$ 之间的修建计划。那就按 $r$ 排个序，对于每个位置 $i$ ，记录所有 $r=i$ 的询问。然后在插入线性基的时候，顺便维护上修建计划的编号。对于每个询问，我们只考虑 $[1,r]$ 的修建计划，不用考虑动用 $&gt;r $的修建计划的问题，只要满足修建计划的编号 $\ge l$ 即珂。线性基求最小异或和的时候，顺便维护下即珂。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 355555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[N&lt;&lt;1]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; int n,m,q; void Input() &#123; Rd(3,&amp;n,&amp;m,&amp;q); G.clear(); F(i,1,n-1) &#123; int u,v,w;Rd(3,&amp;u,&amp;v,&amp;w); G.Add2(u,v,w); &#125; &#125; int d[N]; void DFS(int u,int f) //先预处理出每个点到根的异或和：d[i] &#123; Tra(i,u) &#123;int v=__v; if (v!=f) &#123; d[v]=d[u]^G.Label(i); DFS(v,u); &#125; &#125; &#125; int w[N]; int l[N],r[N]; int p[32],id[32]; //p是线性基，id是线性基顺便维护的修建计划编号 vector&lt;int&gt; pos[N]; int ans[N]; void Soviet() &#123; DFS(1,1); F(i,1,m) &#123; int u,v,len;Rd(3,&amp;u,&amp;v,&amp;len); w[i]=d[u]^d[v]^len; //第i个修建计划从u到v，那就会产生一个环，这个环的异或和为：u到v树上路径的异或和，再以后上修建计划的边权 &#125; F(i,1,q) &#123; int s,t;Rd(2,&amp;s,&amp;t); ans[i]=d[s]^d[t]; //初始答案就是s到t的树上路径异或 Rd(2,&amp;l[i],&amp;r[i]); pos[r[i]].p_b(i); //离线，按r排序，把r相同的询问一块考虑 &#125; F(t,1,m) &#123; int x=w[t],r=t; D(i,30,0) if ((x&gt;&gt;i)&amp;1) &#123; if (!p[i])&#123;p[i]=x;id[i]=r;break;&#125; if (id[i]&lt;r) swap(p[i],x),swap(id[i],r); x^=p[i]; &#125; //插入线性基的时候顺便维护编号 F(k,0,sz(pos[t])-1) &#123;int v=pos[t][k]; D(i,30,0) &#123; if (id[i]&gt;=l[v]) ans[v]=min(ans[v],ans[v]^p[i]); //在考虑编号&gt;=l的情况下，求最小异或和 &#125; &#125; &#125; F(i,1,q) printf("%d\n",ans[i]); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>图论</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 3073 [USACO13FEB]Tractor S 题解]]></title>
    <url>%2F2020%2F02%2F27%2F%E6%B4%9B%E8%B0%B7-3073-USACO13FEB-Tractor-S-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个 $n\times n$ 的矩阵 $a$，两个相邻的格子之间的代价，就是两个格子 $a$ 值之差的绝对值。请你找到一个联通块，使得它格子数超过 $\lfloor \dfrac{n^2}{2} \rfloor$ ，并且最大的边权最小。 $n\le 1000$，$a_{i,j}\le 10^6$，对于所有$1\le i,j\le n$ 思路框架比较基础的问题，首先“最大值最小”想到二分，然后对于相邻的两个格子，如果 $a$ 值之差的绝对值 $&lt;=mid$ ，就用并查集合并起来这两个点，最后找并查集里有没有 $size&gt;\lfloor \dfrac{n^2}{2} \rfloor$ 的联通块即珂。 注意：并查集是一维的结构，把二维压缩到一维的方法：$(i,j)\rightarrow (i-1)n+j$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1333 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class DSU &#123; public: int Fa[N*N],Cnt[N*N]; void Init(int n)&#123;F(i,1,min(n,N*N-1)) Fa[i]=i,Cnt[i]=1;&#125; // 一定要注意这里是N*N // 我在这里都写的N，然后挂了... int Find(int x)&#123;return x==Fa[x]?x:Fa[x]=Find(Fa[x]);&#125; bool Merge(int u,int v) &#123; int au=Find(u),av=Find(v); if (au==av) return false; if (Cnt[au]&lt;Cnt[av]) Cnt[av]+=Cnt[au],Fa[au]=av; else Cnt[au]+=Cnt[av],Fa[av]=au; return true; &#125; &#125;D; int n,a[N][N]; void Input() &#123; R1(n); F(i,1,n) F(j,1,n) R1(a[i][j]); &#125; #define id(i,j) ((i-1)*n+j) //二维转化成一维 int dx[2]=&#123;1,0&#125;,dy[2]=&#123;0,1&#125;; //为了避免重复枚举，每个点只考虑它正下，正右方的点 bool cxk(int x) &#123; D.Init(n*n); F(i,1,n) F(j,1,n) F(k,0,1) &#123; int nx=i+dx[k],ny=j+dy[k]; if (nx&lt;=n and ny&lt;=n and abs(a[i][j]-a[nx][ny])&lt;=x) //在矩阵内 并且 a值差的绝对值&lt;=mid &#123; D.Merge(id(i,j),id(nx,ny)); //合并这两个点 &#125; &#125; int Max=-1; F(i,1,n*n) Max=max(Max,D.Cnt[D.Find(i)]); return Max&gt;=n*n/2; &#125; void Soviet() &#123; int l=0,r=2e6; while(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; if (cxk(mid)) r=mid; else l=mid+1; &#125; printf("%d\n",l); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
        <tag>水题</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noi.ac 405 bzoj 4403 序列统计 题解]]></title>
    <url>%2F2020%2F02%2F24%2Fnoi-ac-405-bzoj-4403-%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述noi.ac再次蒯题，实锤了… 请你求长度在 $[1,n]$ 范围内，值域在 $[l,r]$ 范围内的序列中，不下降序列有多少个。答案对 $1000003$（是质数）取膜。 多组数据，数组组数 $T\le 100$ ，每组数据 $n,l,r\le 1e9$ ，并且保证$l\le r$ 思路框架首先，在 $[l,r]$ 范围内，和在 $[1,r-l+1]$ 范围内，没有本质上的区别。设 $m=r-l+1$，然后答案就是 $C_{n+m}^{m}-1$ 具体思路我们先求长度固定为 $k$ 的时候，有多少满足条件的序列，然后取遍 $k=1,2\cdots n$ ，求和。 求有多少固定长度非严格上升子序列严格上升怎么做长度为 $k$ 的时候，值域在 $[1,m]$ 内的严格上升序列的格式就是 $C_{m}^{k}$ 。因为我们只要在 $[1,m]$ 内选出来 $k$ 个数，然后把它排一下序，那就能得到一个长度为 $k$ ，值域在 $[1,m]$ 内的一个严格上升序列了。 如何转化成非严格上升我们在选严格上升序列的时候，假设我们当前选到的数为 $x$，那么下一个位置珂以是 $x+1,x+2…m$，有 $m-x$ 种选择。而选非严格上升序列的时候，却有 $m-x+1 $种选择。 那这个时候，我们只要把 $m$ 变成 $m+1$ ，那答案就和严格上升的时候一样了！！ 序列的长度为 $k$ ，那么我们在选第 $[1,k-1]$这些位置的时候，都要把 $m$ 变成 $m+1$。那一共就是变成 $m+k-1$。 总结一下，长度为 $k$ 值域在 $[1,m]$ 之间的非严格上升序列个数为 $C_{m+k-1}^{k}$ 优化求和我们要求 $\sum\limits_{i=1}^{n} C_{m+i-1}^{i}=C_{m}^1+C_{m+1}^2+C_{m+2}^3…+C_{m+n-1}^{n}$ 显然，$C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}$ 那也就是说，我们珂以用两个相邻的 $C_{n}^{xxx}$ 得到一个 $C_{n+1}^{xxx}$。 那么我们考虑给第一项加上一个 $C_{m}^{0}$，也就是 $1$，然后最后减掉一个 $C_{m}^{0}$。 那我们开始推式子了，系好安全带（为了方便理解，我拆开$\Sigma$）：原式$=C_{m}^{0}+C_{m}^{1}+C_{m+1}^{2}+C_{m+2}^3…+C_{m+n-1}^n-1$$=C_{m+1}^{1}+C_{m+1}^{2}+C_{m+2}^3+…+C_{m+n-1}^n-1$$=C_{m+2}^{2}+C_{m+2}^{3}+….+C_{m+n-1}^n-1$$=C_{m+n-1}^{n-1}+C_{m+n-1}^{n}-1$$=C_{m+n}^{n}-1$ 所以答案就是 $C_{m+n}^{n}-1$。预处理阶乘（逆元）+Lucas定理。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define mod 1000003 #define N (mod&lt;&lt;1) #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int fac[N],ifac[N]; //阶乘，和阶乘的逆元 void Init() &#123; fac[0]=1; F(i,1,mod-1) fac[i]=fac[i-1]*i%mod; ifac[mod-1]=mod-1; //mod是质数，那么(mod-1)! %mod=mod-1，这个是Wilson定理 //然后mod-1的逆元，显然是mod-1 D(i,mod-2,0) ifac[i]=ifac[i+1]*(i+1)%mod; &#125; int n,l,r; void Input() &#123; Rd(3,&amp;n,&amp;l,&amp;r); &#125; int C(int n,int m) //Lucas定理 &#123; if (m&gt;n) return 0; if (n&lt;mod and m&lt;mod) &#123; return fac[n]*ifac[m]%mod*ifac[n-m]%mod; &#125; return C(n/mod,m/mod)*C(n%mod,m%mod)%mod; &#125; void Soviet() &#123; int len=r-l+1; //len就是m了 printf("%lld\n",(C(n+len,len)+mod-1)%mod); &#125; #define Flan void Flan IsMyWife() &#123; Init(); int t;R1(t); F(i,1,t) &#123; Input(); Soviet(); &#125; &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>思维</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noi.ac 716 答案是整数 题解]]></title>
    <url>%2F2020%2F02%2F23%2Fnoi-ac-716-%E7%AD%94%E6%A1%88%E6%98%AF%E6%95%B4%E6%95%B0-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述求$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}\dfrac{ij}{\gcd (i,j)}$。 对 $998244353$ 取模。$n&lt;=10^7,m&lt;=10^{14}$。 注：空间限制只有64MB，只够开 $10^7$ 的int型数组。 思路基础操作设 $n\le m$，因为 $n,m$ 对称。设 $g=\gcd(i,j)$ （简写）$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m} \dfrac{ij}{g^2}$$\sum\limits_{d=1}^{n}\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d}[g=1]ij$ （枚举$\gcd$）$\sum\limits_{q=1}^{n}\mu(q)\sum\limits_{d=1}^{n}\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d}[q|g]ij$$\sum\limits_{q=1}^{n}\mu(q)\sum\limits_{d=1}^{n}\sum\limits_{i=1}^{n/dq}\sum\limits_{j=1}^{m/dq}iq\times jq$$\sum\limits_{q=1}^{n}\mu(q)q^2\sum\limits_{d=1}^{n}\sum\limits_{i=1}^{n/dq}\sum\limits_{j=1}^{m/dq}ij$设 $s(x)=\sum\limits_{i=1}^x i$原式化为：$\sum\limits_{q=1}^n\mu(q)q^2\sum\limits_{d=1}^{n}s(n/dq)s(m/dq)$我们发现， $dq&gt;n$ 时，$s(n/dq)=0$，也就不会有贡献了。那么我们珂以缩小 $d$ 的范围：$\sum\limits_{q=1}^{n}\mu(q)q^2\sum\limits_{d=1}^{n/q}s(n/dq)s(m/dq)$ 整除分块两次，是 $O(n)$ 的（？）。 但是似乎这个复杂度还和 $m$ 有点关系，我不是很清楚…总之，它TLE了，只有 $80$ 分。（亲测） 那么我们考虑枚举 $q\times d$，设为 $T$。它的贡献就是 $s(n/T)s(m/T)$ 。而它被算到的此时，显然， $T=dq$ 是 $q$ 的倍数，所以 $q$ 是 $T=dq$ 的因数。那 $dq=T$ 被算到的次数就是 $\sum\limits_{q|T} \mu(q)q^2$。将这个值设为 $f(T)$。 式子化一下，变成：$\sum\limits_{T=1}^{n}f(T)\times s(n/T)\times s(m/T)$。 那么问题就在于我们怎么筛这个 $f(T)$ ，还要严格线性，因为 $n&lt;=10^7$。 如何筛f函数显然，$f(1)=1$，而且当 $p$ 和 $q$ 互质时，$f(p\times q)=f(p)\times f(q)$。这说明它也许能线性筛。 考虑质数情况。当 $p$ 为质数时，$f(p)=1-p^2$。 接着，$f(p^k)=\sum\limits_{d|p^k}\mu(d)d^2$。显然，$p^k$ 的因数只有 $p^0,p^1\cdots p^k$。而对于 $p^j$ （$2\le j \le k$），显然，$\mu(p^j)=0$，也就不会有贡献了。因此，有贡献的只有 $p^0$ 和 $p^1$ 。 那也就是说，$f(p^k)=f(p)$！！！（换句话说，同一个质因子乘多少遍都不会改变 $f$ 的值） 那么我们在线性筛的时候有这样一步：枚举 $i$，找一个质数 $u$。如果 $u$ 不是 $i$ 的因数，那么显然 $i$ 和 $u$ 互质，$f(i\times u)=f(i)\times f(u)$。否则 $u$ 是 $i$ 的质因子，然后我们要计算 $f(i\times u)$ 的值，并 break。 由上面那个性质得，$u$ 是 $i$ 的质因子，而我们又把它乘了一遍，并不会改变 $f$ 的值。也就是 $f(i\times u)=f(i)\times f(u)$。 知道了这些，就能线性筛这个 $f$ 函数了！！！ 线性筛出来了 $f$ 之后，整除分块都不用，直接 $O(n)$ 暴力就能求出原式的值了。而且是很稳的 $O(n)$ 哦！ 极 限 卡 常上面说了，空间限制只有 64MB ，只能开的下一个 $10^7$ 个int数组，两个就不行了。 说的具体点，能开的下 $16 777 216$个 int。 但是我们常见的线性筛，需要一个int primes[1e7]保存质数，还有一个bool notp[1e7]标记是否不是素数，然后才是我们的f数组。这可怎么办呢？ 首先，$[1,n]$ 中的质数个数和 $n$ 绝对不是同一个级别。具体的说，大概是 $\dfrac{n}{\ln(n)}$ 级别的。$[1,1e7]$ 中的质数，经过测试，还不足 $10^6$ 个。那么我们的 primes 数组就珂以开的小一点了。 接着，bool notp[1e7] 珂以用一个 bitset 存储，空间直接少掉 $32$ 倍，你说爽不爽。 然后我们就能卡进空间常数了！nice！ 还有，记得不要全开long long 啊！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 10000007 #define mod 998244353ll #define i6 166374059ll #define i2 499122177ll // 模数，2的逆元，6的逆元 // 只是打个板子，并不是所有的数都有用上 #define ll long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) //并不想用快读，数据小 ll n,m; void Input() &#123; scanf("%lld%lld",&amp;n,&amp;m); &#125; int f[N]; int primes[N/10]; //N/10足够了 bitset&lt;N&gt; notp; //STL万岁 void Init() &#123; int &amp;cnt=primes[0]; int n=1e7; f[1]=notp[1]=1; F(i,2,n) &#123; if (!notp[i]) &#123; f[i]=(mod+1-1ll*i*i%mod)%mod; // 上面说了，i为质数的时候，f[i]=1-i*i // 别忘了取模啊 primes[++cnt]=i; &#125; for(int j=1;j&lt;=cnt and i*primes[j]&lt;=n;++j) &#123; int u=primes[j]; notp[i*u]=1; if (i%u!=0) &#123; f[i*u]=1ll*f[i]*f[u]%mod; //利用积性性质，f[i*u]=f[i]*f[u] &#125; else &#123; f[i*u]=f[i]; //上面特意讲了，此时f[i*u]=f[i] break; &#125; &#125; &#125; &#125; ll s(ll x)&#123;x%=mod;return x*(x+1)%mod*i2%mod;&#125; //计算1+2+3...+x的和，也就是x*(x+1)/2 void Soviet() &#123; if (n&gt;m) swap(n,m); //令n&lt;=m ll ans=0; F(i,1,n) &#123; ans+=1ll*f[i]*s(n/i)%mod*s(m/i)%mod; //每次ans+=f[i]*s(n/i)*s(m/i) //别忘了取模啊！ ans%=mod; &#125; printf("%lld\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Init(); Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>毒瘤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1304E 1-Trees and Queries 题解]]></title>
    <url>%2F2020%2F02%2F21%2FCodeforces-1304E-1-Trees-and-Queries-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述$n$ 个节点的树，每条边权都是 $1$。有 $q$ 个询问，每次给定 $x,y,a,b,k$，表示你在树上加一条边 $(x\leftrightarrow y)$ ，并求从 $a$ 到 $b$ 走 $k$ 条边的最短路。其中每条边和点都允许重复经过。求完询问后，把 $(x\leftarrow y)$ 这条边删掉（即：询问之间都是独立的）。 $n\le 1e5; q\le 1e5; 1\le x,y,a,b \le n; 1\le k \le 1e9$ 思路框架首先倍增LCA维护两点之间的最短路。 由于边能重复经过，参考今年普及 T4 的思路，我们只要找一条长度 $\le k$ 并且和 $k$ 同奇偶的路即可。 原先$a,b$之间的最短路只能有一条。但是加上边 $x,y$ 之后，就多了两条：$a\rightarrow x \rightarrow y \rightarrow b$，长度为 $Q(a,x)+1+Q(y,b)$$a\rightarrow y \rightarrow x \rightarrow b$，长度为 $Q(a,y)+1+Q(x,b)$（其中 $Q(u,v)$ 表示 $u$ 到 $v$ 的最短路，代码里叫PathLen）这三条里面判断一下，哪条能满足：长度 $\le k$ 且长度和$k$同奇偶 有一个就输出YES，否则NO。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[N&lt;&lt;1]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; int n; void Input() &#123; R1(n); G.clear(); F(i,1,n-1) &#123; int u,v;Rd(2,&amp;u,&amp;v); G.Add2(u,v); &#125; &#125; int fa[N][22],deep[N]; void DFS(int u,int f) &#123; deep[u]=(u==f)?0:deep[f]+1; //deep[i] 表示从 i 到根经过的 **边数** //所以 deep[根] 是 0 哦 fa[u][0]=f; F(i,1,20) fa[u][i]=fa[fa[u][i-1]][i-1]; Tra(i,u) &#123;int v=__v; if (v!=f) DFS(v,u); &#125; &#125; int LCA(int a,int b) //求a,b的LCA &#123; if (deep[a]&lt;deep[b]) swap(a,b); D(i,20,0) if (deep[fa[a][i]]&gt;=deep[b]) a=fa[a][i]; if (a==b) return a; D(i,20,0) if (fa[a][i]!=fa[b][i]) a=fa[a][i],b=fa[b][i]; return fa[a][0]; &#125; int PathLen(int a,int b) &#123; return deep[a]+deep[b]-2*deep[LCA(a,b)]; &#125; bool cxk(int path,int k)&#123;return path&lt;=k and (k-path)%2==0;&#125; void Soviet() &#123; DFS(1,1); int q;R1(q); F(i,1,q) &#123; int a,b,x,y,k; Rd(5,&amp;x,&amp;y,&amp;a,&amp;b,&amp;k); int path1=PathLen(a,b); int path2=PathLen(a,x)+1+PathLen(y,b); int path3=PathLen(a,y)+1+PathLen(x,b); //上面讨论的三条路 if (cxk(path1,k) or cxk(path2,k) or cxk(path3,k)) puts("YES"); else puts("NO"); &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125; 后记： 版权问题（不想看就算了）考场上，我想出了这个算法（第一个）。然后我把这个算法告诉了我的好朋友lym。他又把这个算法告诉了他的好朋友zhk。 最近zhk也像我一样搭了一个hexo博客，他就来找我帮他调试博客的功能。然后我发现了他有一篇文章，就是这个的题解，同步发表于洛谷博客的。我一看这思路似乎很眼熟，便去问他你是怎么想出这思路的。 （开始回溯）他说，是lym告诉他的，lym给了他一张截图。 截图： 你们看这个头像和我的是否有几分相像呢（滑稽）。这真是 缘 分 的 天 空 啊。]]></content>
      <tags>
        <tag>思维</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noi.ac 307 洛谷 2391 白雪皑皑(flower) 题解]]></title>
    <url>%2F2020%2F02%2F19%2Fnoi-ac-307-%E6%B4%9B%E8%B0%B7-2391-%E7%99%BD%E9%9B%AA%E7%9A%91%E7%9A%91-flower-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述老铁们，虽然不是同一个题目，但是是一样的题意，今天我来给大家打一个暴力模拟线段树，奥利给 一个长度为 $n$ 的序列，初始全 $0$ 。有 $m$ 次修改操作。给你两个常数 $p,q$，第 $i$ 次操作会把第 $(i\times p+q)\mod n+1$ 和 $(i\times q+p)\mod n+1$ 之间的所有数赋值为 $i$。求出最后$n$个数的状态。 $n\le 10^6,m\le 10^7$。 思路框架这个是不一样的做法，是线段树+一点点思维优化。 （大家似乎都是写的链表做法啊…我不会打链表啊…） 我们发现$(i\times p+q)\mod n+1$这个式子，可以先把$i$对$n$取膜之后再算！！！也就是说，有很多次区间覆盖操作都是覆盖的同一块区间！ 那么本质不同的修改操作就只有$n$个，再加上最后$m\mod n$个除不尽的。 特判$m&lt;n$的情况。 无论哪种情况，复杂度都是$O(n \log n)$的。对于$n\le 10^6$的数据，足够了。 具体思路显然，在同一个同余系里，最后面那次覆盖的颜色是答案。那么我们把$m$次操作，每$n$个分一块（除不尽的先不管）。显然，最后一块的操作可以把前面几块的操作全部都覆盖掉。所以最后一块是唯一有用的一块。 $m$除以$n$，可以画出这样的图： last指针表示最后一块有用的区间前面一个位置，那么最后一块有用的染色操作就是$i=last+1,last+2\cdots last+n$的时候。 容易计算出 last 指针为：$n(\lfloor\dfrac{m}{n}\rfloor-1)$ 最后$m\mod n$个特判掉。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1666666 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class SegmentTree //线段树，区间覆盖，单点求值 &#123; public: struct node &#123; int l,r,c,s; &#125;tree[N&lt;&lt;2]; #define ls index&lt;&lt;1 #define rs index&lt;&lt;1|1 #define L tree[index].l #define R tree[index].r #define S tree[index].s #define C tree[index].c #define lL tree[ls].l #define lR tree[ls].r #define lS tree[ls].s #define lC tree[ls].c #define rL tree[rs].l #define rR tree[rs].r #define rS tree[rs].s #define rC tree[rs].c void Build(int l,int r,int index=1) &#123; L=l,R=r; if (l==r) &#123;S=C=0;return;&#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,ls); Build(mid+1,r,rs); &#125; void ChangeOne(int x,int index=1) &#123; C=S=x; &#125; void PushDown(int index=1) &#123; if (C) &#123; ChangeOne(C,ls); ChangeOne(C,rs); C=0; &#125; &#125; void Change(int l,int r,int x,int index=1) //l到r覆盖上x &#123; if (l&gt;R or L&gt;r) return; if (l&lt;=L and R&lt;=r) return ChangeOne(x,index); PushDown(index); Change(l,r,x,ls); Change(l,r,x,rs); &#125; int Query(int pos,int index=1) //查询第pos个位置的值 &#123; if (pos&lt;L or R&lt;pos) return 0; if (L==R) return S; PushDown(index); return Query(pos,ls)+Query(pos,rs); &#125; &#125;T; int n,m,p,q; void Input() &#123; Rd(4,&amp;n,&amp;m,&amp;p,&amp;q); &#125; void Soviet() &#123; #define ll(i) ((i*p+q)%n+1) #define rr(i) ((i*q+p)%n+1) T.Build(1,n); if (m&lt;n) //m&lt;n直接特判 &#123; F(i,1,m) &#123; int l=ll(i),r=rr(i); if (l&gt;r) swap(l,r); //记得判断l&gt;r的情况 T.Change(l,r,i); &#125; F(i,1,n) printf("%d\n",T.Query(i)); &#125; else &#123; int last=(m/n-1)*n; F(i,1,n) //找到最后一块有用的区间 &#123; int l=ll(i),r=rr(i); if (l&gt;r) swap(l,r); T.Change(l,r,++last); &#125; F(i,last+1,m) //最后m%n个也判掉 &#123; int l=ll(i),r=rr(i); if (l&gt;r) swap(l,r); T.Change(l,r,i); &#125; F(i,1,n) printf("%d\n",T.Query(i)); &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>数论</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 2572 bzoj 1858 [SCOI2010]序列操作 题解]]></title>
    <url>%2F2020%2F02%2F17%2F%E6%B4%9B%E8%B0%B7-2572-bzoj-1858-SCOI2010-%E5%BA%8F%E5%88%97%E6%93%8D%E4%BD%9C-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述你有一个长度为$n$的01序列，支持$m$个操作，操作分五种，形式分别是： 0 l r 从$l$到$r$都变成$0$ 1 l r 从$l$到$r$都变成$1$ 2 l r 从$l$到$r$全部取反（$0$变成$1$，$1$变成$0$） 3 l r 询问$l$到$r$有多少$1$ 4 l r 询问$l$到$r$最长的连续的$1$有多长 思路框架线段树多标记。 具体思路线段树，分几个方面讲 每个节点存什么信息 如何维护这些信息（Update 函数） lazytag 的优先级，以及如何单节点修改，还有如何 PushDown。 节点信息我们按操作顺序考虑。首先是区间覆盖的操作，那么我们就要维护一个标记，设为 $cover$ 标记（简记为 $C$）。由于 $C$ 取 $0/1$ 都是有意义的，那么就只好用 $-1$ 表示没有标记了。 然后还有取反操作。那么我们维护一个 $flip$ 标记（简记为 $F$ ），$F=0/1$ 表示区间被取反了$F$ 次。由于取反两次就相当于没有取反，所以 $F$ 只需要设置为 $0/1$ 即珂。 然后询问有多少个 $1$。显然我们需要维护区间有多少个 $1$ ，设为 $s[1]$ （$s$ 就是 $sum$ 啦）。然后我们发现，取反完之后， $0$ 变成 $1$，$1$ 变成$0$。所以$1$有的标记，$0$ 都要有。所以我们还有维护区间有多少 $0$，设为 $s[0]$。 然后询问连续的 $1$ 。这个是套路：我们维护从左边起最大连续的 $0/1$ ，设为 $lc[0/1]$（就是left consecutive的简写 ），还有从右边起最大连续的 $0/1$，设为 $rc[0/1]$。还有最长的连续 $0/1$，记为$x$。（这个名字是瞎jb取的，因为没有名字了） 如何维护众所周知，update 的时候，lazytag 是不重要的。我们直接将其设置为空标记即珂。 显然，$s[0/1]$ 就直接左子树+右子树即珂。 $lc[0/1]$ 就先设置成左子树的 $lc$。如果发现它占满了整个左子树，那就要跨越到右子树去了。此时再加上右子树的 $lc$ 即珂。$rc$ 同理。 然后 $x$（最长连续的 $0/1$）的维护也很容易，就是左子树连续的 $1$，右子树连续的 $1$，还有左子树的右连续（$rc$）+右子树的左连续（$lc$），三个取 $max$。 （实现小技巧：我们珂以把节点打个 $struct$，然后封装一个加号）先放个代码上来，方便理解12345678910111213141516171819202122struct node&#123;int l,r,f,c,lc[2],rc[2],s[2],x[2];&#125;; //l,r表示当前节点表示的区间//f,c是两个tag//lc,rc,s,x和上面一样，表示左连续，右连续，总计数，最大连续node operator+(node ls,node rs)&#123; node ans; ans.l=ls.l; ans.r=rs.r; //这个不用我讲吧... ans.f=0,ans.c=-1; //标记 for(int i=0;i&lt;2;++i) &#123; ans.lc[i]=ls.lc[i]; if (ls.lc[i]==ls.r-ls.l+1) ans.lc[i]+=rs.lc[i]; //默认直接取左儿子的。如果满了，再加上右儿子的左连续 ans.rc[i]=rs.rc[i]; if (rs.rc[i]==rs.r-rs.l+1) ans.rc[i]+=ls.rc[i]; //rc同理 ans.s[i]=ls.s[i]+rs.s[i]; //总计数比较方便，直接左右加起来即珂 ans.x[i]=max(max(ls.x[i],rs.x[i]),ls.rc[i]+rs.lc[i]); //最长连续要分三种情况讨论 &#125; return ans;&#125; lazytag的优先级&amp;如何维护lazytag单区间修改 覆盖操作：显然，覆盖的优先级绝对大于取反，所以先令 $F=0$。接着，假设我们都覆盖上了$c$，$c=0/1$。然后 $lc[c],rc[c],s[c],x[c]$ 都等于区间长度，而另一个颜色（$c$ 取反）的$lc,rc,s,x$ 都等于$0$。 如果是取反的操作，因为是低优先级的操作，所以直接修改 $F$ 标记即珂。由于取反完之后，$0$ 变成 $1$，$1$ 变成 $0$，所以我们只需要把 $lc,rc,s,x$的$0/1$ 两维交换一下即珂。 PushDownPushDown 的时候，先操作 $C$ 标记，再操作 $F$ 标记。我们下传标记的时候，只对儿子作修改，而不对本身作修改（因为在 PushDown 前面一次单区间修改的时候，应该已经改过了）。所以如果遇到“先覆盖后翻转”的情况，就不会错误地把 $F$ 标记删掉了。而两个儿子也是 $C$ 标记先到，$F$ 后到，所以儿子节点的 $F$ 标记也不会被错删掉。 一个小问题：如何写最长连续1的Query函数（代码中的QueryLen）Query 函数返回一个线段树节点即珂。最后取节点的 $x[1]$ 属性，就是最长连续 $1$ 的长度了。 完整代码（超长）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 // #define F(i,l,r) for(int i=l;i&lt;=r;++i) // 为了不和F标记重名，删掉了这个define #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); for(int i=1;i&lt;=cnt;++i) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; //这些都是次要内容 //以下正片 //============================== struct node&#123;int l,r,f,c,lc[2],rc[2],s[2],x[2];&#125;; //一个线段树节点 node operator+(node ls,node rs) //这一段上面有 &#123; node ans; ans.l=ls.l; ans.r=rs.r; ans.f=0,ans.c=-1; for(int i=0;i&lt;2;++i) &#123; ans.lc[i]=ls.lc[i]; if (ls.lc[i]==ls.r-ls.l+1) ans.lc[i]+=rs.lc[i]; ans.rc[i]=rs.rc[i]; if (rs.rc[i]==rs.r-rs.l+1) ans.rc[i]+=ls.rc[i]; ans.s[i]=ls.s[i]+rs.s[i]; ans.x[i]=max(max(ls.x[i],rs.x[i]),ls.rc[i]+rs.lc[i]); &#125; return ans; &#125; class SegmentTree &#123; public: node tree[N&lt;&lt;2]; #define ls index&lt;&lt;1 #define rs index&lt;&lt;1|1 #define LC tree[index].lc #define RC tree[index].rc #define S tree[index].s #define X tree[index].x #define L tree[index].l #define R tree[index].r #define C tree[index].c #define F tree[index].f #define lLC tree[ls].lc #define lRC tree[ls].rc #define lS tree[ls].s #define lX tree[ls].x #define lL tree[ls].l #define lR tree[ls].r #define lC tree[ls].c #define lF tree[ls].f #define rLC tree[rs].lc #define rRC tree[rs].rc #define rS tree[rs].s #define rX tree[rs].x #define rL tree[rs].l #define rR tree[rs].r #define rC tree[rs].c #define rF tree[rs].f //中二define，让代码简介一点 void Update(int index=1) //这个似乎就很好写了对吧 &#123; tree[index]=tree[ls]+tree[rs]; &#125; void Build(int l,int r,int index=1) &#123; L=l,R=r; if (l==r) &#123; int x; scanf("%d",&amp;x); C=-1;F=0; // 注意: C的空标记为-1 S[x]=LC[x]=RC[x]=X[x]=1; x^=1; S[x]=LC[x]=RC[x]=X[x]=0; return; &#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,ls); Build(mid+1,r,rs); Update(index); &#125; void FlipOne(int index=1) &#123; F^=1; //注意: F^=1即珂 swap(LC[0],LC[1]); swap(RC[0],RC[1]); swap(S[0],S[1]); swap(X[0],X[1]); //把0和1对应的属性换一下 &#125; void ChangeOne(int x,int index=1) &#123; F=0; //清空F标记 C=x; S[x]=LC[x]=RC[x]=X[x]=R-L+1; //x的属性全部设置为区间长度,x^1的属性全部为0 x^=1; S[x]=LC[x]=RC[x]=X[x]=0; &#125; //封装单区间修改函数，代码看起来结构清晰些(?) void PushDown(int index=1) &#123; //先传C标记，再传F标记 if (~C) &#123; ChangeOne(C,ls); ChangeOne(C,rs); C=-1; &#125; if (F) &#123; FlipOne(ls); FlipOne(rs); F=0; &#125; &#125; void Change(int l,int r,int x,int index=1) //覆盖[l,r]为x &#123; if (l&gt;R or L&gt;r) return; if (l&lt;=L and R&lt;=r) return ChangeOne(x,index); PushDown(index); Change(l,r,x,ls); Change(l,r,x,rs); Update(index); &#125; void Flip(int l,int r,int index=1) //区间[l,r]翻转 &#123; if (l&gt;R or L&gt;r) return; if (l&lt;=L and R&lt;=r) return FlipOne(index); PushDown(index); Flip(l,r,ls); Flip(l,r,rs); Update(index); &#125; int Query1(int l,int r,int index=1) //询问[l,r]中1的数量 &#123; if (l&gt;R or L&gt;r) return 0; if (l&lt;=L and R&lt;=r) return S[1]; PushDown(index); return Query1(l,r,ls)+Query1(l,r,rs); &#125; node QueryLen(int l,int r,int index=1) //询问[l,r]中连续1的长度 &#123; if (l&lt;=L and R&lt;=r) return tree[index]; //返回一个线段树节点 PushDown(index); int mid=(L+R)&gt;&gt;1; if (r&lt;=mid) return QueryLen(l,r,ls); if (l&gt;mid) return QueryLen(l,r,rs); return QueryLen(l,mid,ls)+QueryLen(mid+1,r,rs); //这样用节点合并就珂以了，是不是很简单呢 &#125; &#125;T; int n,m; void Input() &#123; Rd(2,&amp;n,&amp;m); T.Build(1,n); &#125; void Soviet() &#123; for(int i=1;i&lt;=m;++i) &#123; int o,l,r;Rd(3,&amp;o,&amp;l,&amp;r); ++l,++r; //0编号转1编号 if (o==0) T.Change(l,r,0); if (o==1) T.Change(l,r,1); if (o==2) T.Flip(l,r); if (o==3) printf("%d\n",T.Query1(l,r)); if (o==4) printf("%d\n",T.QueryLen(l,r).x[1]); //取x[1]属性就是答案啦 &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1169E And Reachability 题解]]></title>
    <url>%2F2020%2F02%2F16%2FCodeforces-1169E-And-Reachability-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定$n$个数$a1,a2…an$。如果$i&lt;j$且$a[i]\&amp;a[j]$（$\&amp;$ 是按位与运算）非零，则$i\rightarrow j$连一条有向边。$q$次询问，每次给定$xi$和$yi$，查询$xi$是否能到$yi$。 每个输入的数都&lt;=3e5，并且1&lt;=xi&lt;yi&lt;=n。 思路框架处理$dp[i][j]$表示$i$往后第一个能到并且包含二进制第$j$位的位置。 然后看是否存在$k$使得$dp[x][k]&lt;y$即珂。 具体思路讲讲$nex$如何处理。显然$dp[n+1][x]=n+1$，对于所有$x$。维护$dp$同时维护一个$nex[]$，$nex[j]$表示当前位置往后第一个包含二进制第$j$位的数在哪个位置。 显然，$i\rightarrow nex[j]$是联通的（$\&amp;$一下，至少还有第$j$位）。然后对于一个$i$，枚举$j$如果$i$包含第$j$位，则对于所有$k$，用$dp[nex[j]][k]$更新$dp[i][k]$的最小值。 然后我们不是枚举$i$中包含第$j$位么，更新完$dp$之后，更新$nex$：$nex[j]=i$。然后记得$dp[i][j]=i$。（自己也能到自己） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1666666 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int n,q,a[N]; void Input() &#123; Rd(2,&amp;n,&amp;q);F(i,1,n) R1(a[i]); &#125; int dp[N][22]; int nex[22]; void Soviet() &#123; MEM(dp,0x3f); F(i,0,20) nex[i]=n+1,dp[n+1][i]=n+1; D(i,n,1) F(j,0,20) if (a[i]&amp;(1&lt;&lt;j)) &#123; F(k,0,20) dp[i][k]=min(dp[i][k],dp[nex[j]][k]); dp[i][j]=i; nex[j]=i; &#125; F(i,1,q) &#123; int x,y;Rd(2,&amp;x,&amp;y); bool flag=0; F(j,0,20) &#123; if ((a[y]&amp;(1&lt;&lt;j)) and dp[x][j]&lt;=y) &#123;flag=1;break;&#125; //找到一个就有解 &#125; puts(flag?"Shi":"Fou"); &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 3660 bzoj 4994 Why Did the Cow Cross the Road III 题解]]></title>
    <url>%2F2020%2F02%2F16%2F%E6%B4%9B%E8%B0%B7-3660-bzoj-4994-Why-Did-the-Cow-Cross-the-Road-III-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述（bzoj，十分简洁，直接蒯来了）给定长度为2N的序列，1~N各处现过2次，i第一次出现位置记为ai，第二次记为bi，求满足ai&lt;aj&lt;bi&lt;bj的对数n&lt;=1e5。 思路相当于有$n$个区间$a_i,b_i$，求相交的区间对数。 那么我们把它转化为，对于每个$a_i,b_i$，统计区间里面包含多少其它区间的左端点或右端点，而它的另一个端点不能出现在$[a_i,b_i]$中。 那么能否直接求包含的端点数呢？可以！我们把区间按长度从大到小排序，那么已经考虑的区间肯定比当前的区间长，不珂能出现两个端点同时在里面的情况。然后直接用树状数组统计端点数即珂。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define int long long //记得开long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class BIT &#123; public: int tree[N]; int len; void BuildTree(int _len) &#123; len=_len; FK(tree); &#125; void Add(int pos,int val=1) &#123; for(int i=pos;i&lt;=len;i+=(i&amp;(-i))) &#123; tree[i]+=val; &#125; &#125; int Query(int pos) &#123; int ans=0; for(int i=pos;i&gt;0;i-=(i&amp;(-i))) &#123; ans+=tree[i]; &#125; return ans; &#125; int RQuery(int l,int r)&#123;return Query(r)-Query(l-1);&#125; &#125;T; struct node&#123;int l,r;&#125;a[N]; bool operator&lt;(node a,node b)&#123;return a.r-a.l&gt;b.r-b.l;&#125; //从大到小排序 int n; void Input() &#123; MEM(a,-1); R1(n); F(i,1,2*n) &#123; int x;R1(x); if (a[x].l==-1) a[x].l=i; else a[x].r=i; &#125; //读入的时候顺便求出n个区间的左端点，右端点 &#125; void Soviet() &#123; sort(a+1,a+n+1); int ans=0; T.BuildTree(100000); F(i,1,n) &#123; ans+=T.RQuery(a[i].l,a[i].r); T.Add(a[i].l,1); T.Add(a[i].r,1); &#125; printf("%lld\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>树状数组</tag>
        <tag>枚举顺序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4373 洛谷 5728 算术天才⑨与等差数列 题解]]></title>
    <url>%2F2020%2F02%2F16%2Fbzoj-4373-%E6%B4%9B%E8%B0%B7-5728-%E7%AE%97%E6%9C%AF%E5%A4%A9%E6%89%8D%E2%91%A8%E4%B8%8E%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定给一个序列，每次支持： 单点修改 询问一段区间是否能排列成一个公差为$d$的等差数列（强制在线） 区间长度$3e5$，其它的值域都在$[0,1e9]$之间。 思路框架维护区间和？显然能构造出一种情况卡掉。 那怎么办？维护区间平方和！然后看看是否和等差数列的平方和相等即珂。和很容易相等，但是平方和在$1e9$的范围内，就不太容易相等了。然后为了防止溢出，我们把答案对一个大质数取膜。 然后就是高能线段树+高能数论了。 求等差数列平方和等差数列，首项为$a$，公差为$d$，项数为$n$。 要求$\sum\limits_{i=0}^{n-1} (a+id)^2$。 拆开括号，然后把$d$提出来，套各种公式，得到结果为： $na^2+2ad\times s(n-1)+d^2s2(n-1)$ 其中$s(n)=1+2+3…+n=n(n+1)/2$，$s_2(n)=1^2+2^2+3^2…+n^2=\dfrac{n(n+1)(2n+1)}{6}$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define int long long #define N 555555 #define mod 2305843009213693967ll //这个质数是2^63-1的下一个质数 #define i6 384307168202282328ll //6的逆元 #define i2 1152921504606846984ll //2的逆元 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class SegmentTree &#123; public: struct node &#123; int l,r; int s,mn,mx; &#125;tree[N&lt;&lt;2]; #define ls index&lt;&lt;1 #define rs index&lt;&lt;1|1 #define L tree[index].l #define R tree[index].r #define S tree[index].s #define M tree[index].mn #define X tree[index].mx #define lL tree[ls].l #define lR tree[ls].r #define lS tree[ls].s #define lM tree[ls].mn #define lX tree[ls].mx #define rL tree[rs].l #define rR tree[rs].r #define rS tree[rs].s #define rM tree[rs].mn #define rX tree[rs].mx void Update(int index=1) &#123; M=min(lM,rM); X=max(lX,rX); S=(lS+rS)%mod; &#125; void Build(int l,int r,int index=1) &#123; L=l,R=r; if (l==r) &#123; int x;R1(x);S=(x*x)%mod;M=X=x; return; &#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,ls); Build(mid+1,r,rs); Update(index); &#125; void Change(int pos,int x,int index=1) //单点修改 &#123; if (pos&lt;L or R&lt;pos) return; if (L==R) &#123;S=(x*x)%mod;M=X=x;return;&#125; Change(pos,x,ls); Change(pos,x,rs); Update(index); &#125; int QueryMin(int l,int r,int index=1) &#123; if (l&gt;R or L&gt;r) return mod; //INF if (l&lt;=L and R&lt;=r) return M; return min(QueryMin(l,r,ls),QueryMin(l,r,rs)); &#125; int QueryMax(int l,int r,int index=1) &#123; if (l&gt;R or L&gt;r) return -mod; //-INF if (l&lt;=L and R&lt;=r) return X; return max(QueryMax(l,r,ls),QueryMax(l,r,rs)); &#125; int QuerySum(int l,int r,int index=1) //最小，最大，平方和 &#123; if (l&gt;R or L&gt;r) return 0; if (l&lt;=L and R&lt;=r) return S; return (QuerySum(l,r,ls)+QuerySum(l,r,rs))%mod; &#125; &#125;T; int n,q; void Input() &#123; Rd(2,&amp;n,&amp;q); T.Build(1,n); &#125; int smul(int a,int b) &#123; int r=0; while(b) &#123; if (b&amp;1) r=(r+a)%mod; a=(a&lt;&lt;1)%mod; b&gt;&gt;=1; &#125; return r; &#125; int sqrs(int x)&#123;return smul(i6,smul(x,smul(x+1,2*x+1)))%mod;&#125; //1~x的平方和 int ArethSum(int a1,int d,int n) //首项a1，公差d，项数n的等差数列和 &#123; int ans1=smul(n,smul(a1,a1))%mod; //n*a1^2 int ans2=smul(a1&lt;&lt;1,smul(d,smul(n,smul(n-1,i2))))%mod; //2ad*n*(n-1)/2 int ans3=smul(smul(d,d),sqrs(n-1))%mod; //d^2*sqrs(n-1) return (ans1+ans2+ans3)%mod; &#125; void Soviet() &#123; int yes_cnt=0; F(i,1,q) &#123; int o;R1(o); if (o==1) &#123; int pos,x;Rd(2,&amp;pos,&amp;x); pos^=yes_cnt; x^=yes_cnt; T.Change(pos,x); &#125; if (o==2) &#123; int l,r,d;Rd(3,&amp;l,&amp;r,&amp;d); l^=yes_cnt;r^=yes_cnt;d^=yes_cnt; int Min=T.QueryMin(l,r),Max=T.QueryMax(l,r),s=T.QuerySum(l,r); int len=r-l+1; if (len==1) &#123;puts("Yes");++yes_cnt; continue;&#125; //这个特判下 if (Min+(len-1)*d!=Max) &#123;puts("No"); continue;&#125; //这个项数不对的也要特判下 int ss=ArethSum(Min,d,len); if (ss==s) puts("Yes"),++yes_cnt; else puts("No"); &#125; &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>数论</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1304C Air Conditioner 题解]]></title>
    <url>%2F2020%2F02%2F16%2FCodeforces-1304C-Air-Conditioner-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述你有一个空调（承太郎），初始温度为$m$，有$n$个客人。第$i$个客人会在$t_i$的时间过来，适应的温度在$[l_i,r_i]$之间。每一个时刻，空调珂以让气温升高$1$（制热），减少$1$（制冷），或者不变（关掉空调）。 请问你能否满足所有顾客的适应温度？输出$YES/NO$。 $n&lt;=1e6$，其余输入数据的绝对值都$&lt;=1e9$。 （原来是$n&lt;=100$，但是$n&lt;=1e6$也能做） 思路框架首先，将所有的顾客按$t_i$排序（显然）。 定义两个数$l,r$。初始$l=r=m$。 然后对于每个顾客，$[l,r]$两端都向外扩展$t_i-t_{i-1}$个长度（$l$减去这个数，$r$加上这个数）。然后和$[l_i,r_i]$取一下交集。看看最后$[l,r]$是否非空，如果非空，输出$YES$，否则$NO$。 具体思路如何得到这个算法的（排序肯定是第一个想到的） 一开始我还以为这个是贪心之类的，然后我就在想，从第$i-1$个人到第$i$个人，到底该停留在哪个决策点呢？ 后来我就从能得到的区间开始考虑：初始温度为$x$，经过$t$时刻，能得到的区间是$[x-t,x+t]$。 然后我就有了一个灵感：我们不用具体决策到哪一个点，我们只需要知道能到哪一个区间就珂以了！ 于是就有了下面这个算法。 算法的解释&amp;正确性$[l,r]$表示当前空调在满足所有顾客需求的情况下能调整到的温度范围。初始值为$[m,m]$是显然的（第$0$时刻，空调还没开） 然后从第$i-1$个人到第$i$个人，经过了$t_i-t_{i-1}$个时刻。最小的情况显然是全开制冷，最大的情况显然是全开制热。而且，容易证明，在这段区间中所有的温度都能得到。当然，我们还要考虑上新进来的第$i$个顾客，所以扩展完这个区间还要和$[l_i,r_i]$取一下交集。 然后到最后看看这个范围是否非空即珂。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; struct node&#123;int t,l,r;&#125; a[N]; bool operator&lt;(node a,node b)&#123;return a.t&lt;b.t;&#125; int n,m; void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,1,n) Rd(3,&amp;a[i].t,&amp;a[i].l,&amp;a[i].r); sort(a+1,a+n+1); &#125; void Soviet() &#123; int l=m,r=m; F(i,1,n) &#123; l-=(a[i].t-a[i-1].t); r+=(a[i].t-a[i-1].t); l=max(l,a[i].l); r=min(r,a[i].r); if (l&gt;r) &#123;puts("NO");return;&#125; &#125; puts("YES"); &#125; #define Flan void Flan IsMyWife() &#123; int t;R1(t); F(i,1,t) &#123; Input(); Soviet(); &#125; &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noi.ac 34 洛谷 4656 libreoj 2484 [CEOI2017]Palindromic Partitions 题解]]></title>
    <url>%2F2020%2F02%2F16%2Fnoi-ac-34-%E6%B4%9B%E8%B0%B7-4656-libreoj-2484-CEOI2017-Palindromic-Partitions-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[（noi.ac题面被改过了，题意是一样的） 题意简述给你一个字符串$S$，长度$1e6$。$S$的一个$k$个串的划分$a_1,a_2…a_k$，满足：对于任意的$i$，$a_i=a_{k-i+1}$，这就是$S$的一个“回文划分”，它被分成了$k$块。请你求$S$中被分成的块数最多的一个回文划分，输出这个最多的块数。 比如样例中的“bonobo”这个串，最大的划分就是“bo/no/bo”，3块。 思路框架从两边往中间，每次找最短的串，使得它在前面和后面同时出现（哈希判断）。 到最后，如果$n$为奇数，或者中间一块不能再分了，就把答案$+1$（中间一块单独划分出来）。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1666666 #define hint unsigned long long //自然溢出的哈希 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; char a[N]; int n; void Input() &#123; scanf("%s",a+1); n=strlen(a+1); &#125; void Soviet() &#123; hint base=79; hint s1=0,s2=0,b=1; int ans=0; F(i,1,n/2) &#123; s1=s1*base+a[i]; //在s1后面加入a[i] s2=s2+a[n-i+1]*b; //在s2的前面加入a[i] b*=base; if (s1==s2) &#123;ans+=2;s1=s2=0,b=1;&#125; //找到第一个满足条件就记录答案 &#125; if (n%2 or s1) ++ans; printf("%d\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; int t;R1(t); while(t--) &#123; Input(); Soviet(); &#125; &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>水题</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noi.ac 36 列队 题解]]></title>
    <url>%2F2020%2F02%2F15%2Fnoi-ac-36-%E5%88%97%E9%98%9F-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述有一个$n\times m$的矩阵$a$，每个数是$[1,n\times m]$之间的整数，并且互不相同。然后有$Q$次询问，每次询问给定$x,y$，问你有多少个数满足：它在行中是第$x$大，在列中是第$y$大。 $n,m&lt;=1000,Q&lt;=5e5$。 思路框架设$x[i][j]$表示$a[i][j]$在第$i$行里第几大，$y[i][j]$表示$a[i][j]$在第$j$列第几大。设$ans[i][j]$表示在行里排第$i$大，列里排第$j$大的数有多少。对于所有$i,j$，$ans[x[i][j]][y[i][j]$++。 每次询问输出$ans[x][y]$即珂。$O(nmlog(n+m)+Q)$ $x[i][j]$和$y[i][j]$，您珂以用一个$lower_bound$解决，或者像我一样$sb$的写一个树状数组。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1333 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class BIT &#123; public: int tree[N*N]; int len; void BuildTree(int _len) &#123; len=_len; FK(tree); &#125; void Add(int pos,int val=1) &#123; for(int i=pos;i&lt;=len;i+=(i&amp;(-i))) &#123; tree[i]+=val; &#125; &#125; int Query(int pos) &#123; int ans=0; for(int i=pos;i&gt;0;i-=(i&amp;(-i))) &#123; ans+=tree[i]; &#125; return ans; &#125; &#125;T; int n,m,q; int a[N][N]; void Input() &#123; Rd(3,&amp;n,&amp;m,&amp;q); F(i,1,n) F(j,1,m) R1(a[i][j]); &#125; int line[N][N],col[N][N]; int ans[N][N]; void Soviet() &#123; T.BuildTree(n*m); F(i,1,n) &#123; F(j,1,m) T.Add(a[i][j],1); F(j,1,m) line[i][j]=m-T.Query(a[i][j])+1; F(j,1,m) T.Add(a[i][j],-1); &#125; F(j,1,m) &#123; F(i,1,n) T.Add(a[i][j],1); F(i,1,n) col[i][j]=n-T.Query(a[i][j])+1; F(i,1,n) T.Add(a[i][j],-1); &#125; F(i,1,n) F(j,1,m) ans[line[i][j]][col[i][j]]++; F(i,1,q) &#123; int x,y;Rd(2,&amp;x,&amp;y); printf("%d\n",ans[x][y]); &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>树状数组</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noi.ac 782 【CSP2019模拟 Day 2】a 题解]]></title>
    <url>%2F2020%2F02%2F15%2Fnoi-ac-782-%E3%80%90CSP2019%E6%A8%A1%E6%8B%9F-Day-2%E3%80%91a-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述一个长度为$n&lt;=1e5$的序列，支持两种操作： 等概率随机打乱区间$[l,r]$ 求区间$[l,r]$和的期望值 所有结果（珂能是分数形式）都对$998244353$取膜。 思路打乱区间$[l,r]$相当于把$l,r$中的数都变成$a[l…r]$的平均值。线段树，区间覆盖区间求和，即珂。 具体思路为什么这个思路是对的？ 随机打乱区间$l,r$，对于$[l,r]$中的某一个数$x$，因为是等概率随机打乱，所以它出现在每一个位置的概率都是相等的，都是$\dfrac{1}{r-l+1}$。所以，$[l,r]$被打乱之后，每个位置的期望都是相等的，它都等于$a[l…r]$的平均值。 那至少区间不重叠的时候，这个算法就正确了。 那么如果我们的区间有重叠怎么办呢？重叠了还正确么？ 我们先明确一下期望的概念：$E(x)$表示$x$的期望值，其中$x$是随机变量，而$E(x)$是一个确定的数，表示$x$的期望。 而我们知道，$E(C)=C$，也就是“常数的期望等于本身”。所以$E(E(x))=E(x)$，换句话说，期望套几层都是不变的。 所以我们在期望的基础上求期望，求“期望的期望”，求出来的还是“期望”，不是别的。 所以答案就是正确的了。膜数有点大，记得开$long long$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define mod 998244353 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class SegmentTree //线段树 //Build(l,r): 建树,区间为l,r //Change(l,r,x): 覆盖x在[l,r]上 //Query(l,r): 询问[l,r]的和 //好了，请跳到第106行 &#123; public: struct node &#123; int l,r,s,a; &#125;tree[N&lt;&lt;2]; #define ls index&lt;&lt;1 #define rs index&lt;&lt;1|1 #define L tree[index].l #define R tree[index].r #define S tree[index].s #define A tree[index].a #define lL tree[ls].l #define lR tree[ls].r #define lS tree[ls].s #define lA tree[ls].a #define rL tree[rs].l #define rR tree[rs].r #define rS tree[rs].s #define rA tree[rs].a void Update(int index=1) &#123; S=lS+rS; &#125; void Build(int l,int r,int index=1) &#123; L=l,R=r;A=-1; if (l==r) &#123;R1(S);return;&#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,ls); Build(mid+1,r,rs); Update(index); &#125; void ChangeOne(int x,int index=1) &#123; x%=mod; A=x; S=(x*(R-L+1))%mod; &#125; void PushDown(int index=1) &#123; if (A!=-1) &#123; ChangeOne(A,ls); ChangeOne(A,rs); A=-1; &#125; &#125; void Change(int l,int r,int x,int index=1) &#123; if (l&gt;R or L&gt;r) return; if (l&lt;=L and R&lt;=r) return ChangeOne(x,index); PushDown(index); Change(l,r,x,ls); Change(l,r,x,rs); Update(index); &#125; int Query(int l,int r,int index=1) &#123; if (l&gt;R or L&gt;r) return 0; if (l&lt;=L and R&lt;=r) return S; PushDown(index); return (Query(l,r,ls)+Query(l,r,rs))%mod; &#125; &#125;T; int n,m; void Input() &#123; Rd(2,&amp;n,&amp;m); T.Build(1,n); &#125; int qpow(int a,int b) &#123; int r=1; while(b) &#123; if (b&amp;1) r=r*a%mod; a=a*a%mod,b&gt;&gt;=1; &#125; return r; &#125; int mod_div(int a,int b)&#123;return a*qpow(b,mod-2)%mod;&#125; void Soviet() &#123; F(i,1,m) &#123; int o,l,r;Rd(3,&amp;o,&amp;l,&amp;r); if (o==1) &#123; int s=T.Query(l,r)%mod,c=(r-l+1); T.Change(l,r,mod_div(s,c)); &#125; if (o==2) &#123; printf("%lld\n",T.Query(l,r)%mod); &#125; &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>线段树</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1294E Obtain a Permutation 题解]]></title>
    <url>%2F2020%2F02%2F13%2FCodeforces-1294E-Obtain-a-Permutation-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述有一个$n$行$m$列的矩阵$a$，每次你可以做两个操作： 改变某一个元素的值 对某一列做一次循环位移然后你要使得每个i,j满足$a[i][j]=(i-1)\times n+j$。问最少需要多少次操作$n\times m&lt;=2e5$，元素值域为$[1,2e5]$ 思路框架列之间显然是不影响的。考虑每列单独出来考虑。接下来都是在列里面讨论问题的。 像这种问“循环位移需要多少次操作”的题目，一般要设一个数组$move[i]$表示移动$i$次能有多少匹配。这个很好处理，对于每个数，我们找到它应该在哪个位置，和它实际所在的位置相减去绝对值，设为$d$。那么$move[d]$++。其原因是，当前的这个数移动$d$次就到了它该在的地方，所以就给$move[d]$贡献了一个答案。$O(n)$就能预处理一遍。 然后我们枚举移动了多少下。移动$i$下之后，花费$i$的代价，能匹配上$move[i]$个。但是还剩下$n-move[i]$个，就需要用操作$1$来直接修改，花费的代价就是$n-move[i]$。总代价就是$i+n-move[i]$。然后枚举$i$从$1$到$n$，取最小即珂。 每一列都这样求一遍答案，把答案加起来，就是总答案了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 255555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; vector&lt;int&gt; a[N]; int n,m; void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,0,n-1) &#123; a[i].push_back(0); F(j,1,m) &#123;int x;R1(x);a[i].p_b(x);&#125; &#125; &#125; int move[N]; int calc(int col) //求第col列的答案 &#123; F(i,0,n-1) move[i]=0; //记得清空 //不要用memset，万一n=1，m=1e5，就浪费时间了！ F(i,0,n-1) &#123; int u=a[i][col]-col; //在第col列的满足条件的数有一个共同点，就是它%m==col。 if (u%m==0) if (0&lt;=u/m and u/m&lt;n) ++move[(i-u/m+n)%n]; //先判断它是否珂能属于这一列，然后计算它移动多少步能归位 &#125; int ans=0x3f3f3f3f; F(i,0,n) ans=min(ans,i+n-move[i]); return ans; &#125; void Soviet() &#123; int ans=0; F(i,1,m) ans+=calc(i); printf("%d\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noi.ac 73 道路重建 题解]]></title>
    <url>%2F2020%2F02%2F13%2Fnoi-ac-73-%E9%81%93%E8%B7%AF%E9%87%8D%E5%BB%BA-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述有一个$n$个节点的图，还有$m$条边。找到一颗生成树，使得最大边和最小边之间差最小。 n&lt;=2000，m&lt;=15000，边权&lt;=2e9。 思路框架边按边权排序；枚举最小边，枚举最大边，直到联通为止$break$。并查集维护。 看起来是$O(m^2)$，但实际情况会快很多。 具体思路上面没有细讲的，有一个小优化：我们枚举边$i$，$j$从$i$到$m$枚举最大边。 如果$j=m$了，而且此时图还不连通，就直接整个$break$。因为$i$越大，加入的边越少，就更加不连通了。 而且数据似乎比较水，所以对于每个$i$，往后枚举$n$个$j$左右，图就能完全联通了。所以实际跑起来，复杂度更接近$O(nm)$。 然后这题就水过去了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 34444ll #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; struct node&#123;int u,v,w;&#125;E[N]; bool operator&lt;(node a,node b)&#123;return a.w&lt;b.w;&#125; class DSU &#123; public: int Fa[N],Cnt[N]; void Init(int n)&#123;F(i,1,min(n,N-1)) Fa[i]=i,Cnt[i]=1;&#125; int Find(int u)&#123;return u==Fa[u]?u:Fa[u]=Find(Fa[u]);&#125; bool Merge(int u,int v) &#123; int au=Find(u),av=Find(v); if (au==av) return false; if (Cnt[au]&lt;Cnt[av]) Cnt[av]+=Cnt[au],Fa[au]=av; else Cnt[au]+=Cnt[av],Fa[av]=au; return true; &#125; &#125;D; int n,m; void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,1,m) &#123; int u,v,w;Rd(3,&amp;u,&amp;v,&amp;w); E[i]=(node)&#123;u,v,w&#125;; &#125; sort(E+1,E+m+1); &#125; void Soviet() &#123; int ans=1e18; F(i,1,m) //枚举最小边 &#123; D.Init(n); int pos=-1; F(j,i,m) //枚举最大边 &#123; int u=E[j].u,v=E[j].v; D.Merge(u,v); if (D.Cnt[D.Find(1)]==n) &#123;pos=j;break;&#125; &#125; if (pos==-1) break; else ans=min(ans,E[pos].w-E[i].w); &#125; printf("%lld\n",ans==1e18?-1:ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>生成树</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 1105 第k大的数 题解]]></title>
    <url>%2F2020%2F02%2F13%2F51nod-1105-%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述有两个序列$a$和$b$，长度都是$n&lt;=1e5$，并且$a_i,b_i&lt;=1e9$。然后有一个矩阵$A$，其中$A[i][j]=a_i\times b_j$。找到矩阵中第$k$大的元素$k&lt;=1e9$且$k&lt;=n^2$。 思路二分一个$mid$，然后找$A$中有多少个数大于$mid$。显然，$mid$越大，大于$mid$的个数就越小，满足单调性。 在一个都是整数的集合中，$x$是第$k$大，那么$x$是最小的满足大于$x$的数小于$k$个的。二分即珂。 具体思路主要问题在于，我们如何求$A$中有多少个数比$x$大。 我们把$a$和$b$排一下序。原因是，我们只需要求$A$中第$k$大，只需要知道有哪些数就珂以了，具体的排列顺序不重要。 而排完了序以后，$A$矩阵的递增性应该是从上往下，从左往右的。（就是说，越靠下，右方的数的越大）。那么，$&gt;x$的数所在的区域就是右下角的一片三角形区域。草图大概就长这样： 设$p_i$表示第$i$行第一个满足条件的列号，那么该行满足条件的总数量就是$n-p_i+1$。而且，$p_i$还有单调性！维护一个单调的指针即珂（数组都不用！） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int n,k; int a[N],b[N]; void Input() &#123; Rd(2,&amp;n,&amp;k); F(i,1,n) Rd(2,&amp;a[i],&amp;b[i]); &#125; int big(int x) //求有多少个比x大 &#123; int ans=0; int p=1; //单调指针p D(i,n,1) &#123; while(a[i]*b[p]&lt;=x and p&lt;=n) ++p; //p显然只会往右移 if (p==n+1) break; //记得及时break掉，现在就没有解，往上面数字更小，更加没有解了 ans+=(n-p+1); &#125; //i会右移n次 //p会右移总共n次 //均摊O(n) return ans; &#125; void Soviet() &#123; sort(a+1,a+n+1); sort(b+1,b+n+1); a[n+1]=1e9,b[n+1]=1e9; //放一个边界，防止p越界 int l=0,r=1e18; while(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; if (big(mid)&lt;k) r=mid; //有&lt;k个比mid大，说明mid偏大（或者正好），要减小 else l=mid+1; //否则mid严格偏小 &#125; printf("%lld\n",l); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 6070 [RC-02]GCD 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-6070-RC-02-GCD-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述求$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n} \sum\limits_{p=1}^{n/j} \sum\limits_{q=1}^{n/j} [gcd(i,j)==1][gcd(p,q)==1]$。答案对998244353取膜。 $n&lt;=2e9$。 思路原式$=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n} [gcd(i,j)==1]\sum\limits_{p=1}^{n} \sum\limits_{q=1}^{n} [gcd(p,q)==j]$$=\sum\limits_{i=1}^{n} \sum\limits_{p=1}^{n} \sum\limits_{q=1}^{n} [gcd(i,p,q)==1]$$=\sum\limits_{d=1}^{n}\mu(d) \sum\limits_{i=1}^{n} \sum\limits_{p=1}^{n} \sum\limits_{q=1}^{n} [d|gcd(i,p,q)]$$=\sum\limits_{d=1}^{n}\mu(d) \sum\limits_{i=1}^{n/d} \sum\limits_{p=1}^{n/d} \sum\limits_{q=1}^{n/d} [1|gcd(i,p,q)]$$=\sum\limits_{d=1}^{n} \mu(d)\times (n/d)^3$ 整除分块+杜教筛。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1666666 #define int long long #define mod 998244353ll #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int primes[N],mu[N];bool notp[N]; void Init() &#123; int n=1e6; notp[1]=1; mu[1]=1; int &amp;cnt=primes[0]; F(i,2,n) &#123; if (!notp[i]) primes[++cnt]=i,mu[i]=-1; for(int j=1;j&lt;=cnt and i*primes[j]&lt;=n;++j) &#123; int u=primes[j]; notp[i*u]=1; if (i%u) mu[i*u]=-mu[i]; else &#123;mu[i*u]=0;break;&#125; &#125; &#125; F(i,2,n) mu[i]+=mu[i-1]; &#125; map&lt;int,int&gt; s; int smu(int x) //求mu的和 &#123; if (x&lt;=1e6) return mu[x]; if (s[x]) return s[x]; int ans=1; for(int l=2,r;l&lt;=x;l=r+1) &#123; r=x/(x/l); ans-=(r-l+1)*smu(x/l); &#125; ans=(ans%mod+mod)%mod; return s[x]=ans; &#125; int n; void Input() &#123; R1(n); &#125; int RangeMu(int l,int r)&#123;return (smu(r)%mod-smu(l-1)%mod+mod)%mod;&#125; //求区间[l,r]内mu的和，膜mod int pow3(int x)&#123;return x*x%mod*x%mod;&#125; //求x^3%mod void Soviet() &#123; int ans=0; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); ans+=RangeMu(l,r)*pow3(n/l)%mod; ans%=mod; &#125; printf("%lld\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Init(); Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>数论函数</tag>
        <tag>毒瘤</tag>
        <tag>数论</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 5947 [POI2003]Trinomial 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-5947-POI2003-Trinomial-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述$T$组数据。给定$n,m$，求$(x^2+x+1)^n$中，$x^m$项的系数是多少。答案对$3$取膜。（这个膜数很神奇！注意！突破点就在这！） $T&lt;=1e4$，$n&lt;=1e15$，$m&lt;=2n$。 思路框架答案是$C_{2n}^m\times (m\% 2+1)$，对$3$取膜（写个$Lucas$即可） 具体思路首先，我们分括号讨论。因为是$(x^2+x+1)^n$，所以有$n$个括号，并且每个括号可以出$x^2,x,1$。然后我们要求，有多少种方案使得每个括号中出的数积为$x^m$。 我们开始打草稿：我们把$n$个括号从$1$到$n$顺序编号，每个括号上面有两个复选框。打了几个勾，就是代表出$x$的多少次方。具体来说就是：一个都没打勾，代表出$x^0$（$x^0$就是$1$）；其中一个打了勾，代表出$x$；两个都打了勾，代表出$x^2$。 如图所示是$n=4$的情况： 我们这样勾选： 那就相当于：第一个括号出$x$第二个括号出$x^2$第三个括号出$x$第四个括号出$x$那它就会给$x^5$那一项贡献一种情况。 那么我们现在考虑$x^m$项的系数，换句话说就是有多少种方法凑出$x^m$。 显然，上面的复选框中，我们每打一个勾，乘出来就多一个$x$。（上面打了$5$个勾，乘起来就是$x^5$）然后一共有$2n$个复选框，所以答案就是$C_{2n}^m$。 这就完了？不！这样考虑有重复的！ 假如第$i$个括号出的是$x$，那就相当于在$i$上面两个复选框中，其中一个要打勾。而我们只在意数量，具体打勾打上面那个框还是下面的那个，是一样的。那就会把一个答案算两遍，所以要除以$2$。 假设我们有$k$个括号出的是$x$，那么我们的答案就要除以一个$2^k$。 首先，$k$和$m$肯定是同奇偶的。 稍微证一下（会证跳过）： 有$k$个括号出$x$，那剩下$x^{m-k}$都是由出$1$或$x^2$组成的。$m-k$由若干个$0$和$2$相加而成，所以$m-k$是偶数。所以$m$和$k$同奇偶。 然后，在模三意义下，2的逆元就是其本身！所以，除以一个$2^k$，就相当于乘以一个$2^k$。 还没完，我们继续化。我们发现，$2$的幂除以$3$的余数是：$2,1,2,1,2,1…$。具体点说，$2^k\% 3=(k\% 2)+1$。而$k$和$m$又同奇偶，所以，所有的$k\% 2+1$都等于$m\% 2+1$。 综上，我们的答案就是$C_{2n}^m\times (m\% 2+1)$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int n,m; void Input() &#123; Rd(2,&amp;n,&amp;m); &#125; int c[4][4]; int C(int n,int m) //卢卡斯定理求C(n,m)%3 &#123; if (n==0 and m==0) return 1; return C(n/3,m/3)*c[n%3][m%3]%3; &#125; void Soviet() &#123; c[0][0]=1; c[1][1]=c[1][0]=1; c[2][0]=c[2][2]=1;c[2][1]=2; //预处理&lt;3的组合数 printf("%lld\n",C(2*n,m)*(m%2+1)%3); //用上面的式子 &#125; #define Flan void Flan IsMyWife() &#123; int t;R1(t); F(i,1,t) &#123; Input(); Soviet(); &#125; &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>数论</tag>
        <tag>组合数学</tag>
        <tag>转换思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 5826 【模板】子序列自动机 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-5826-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%AD%90%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[你以为我只是单纯的子序列自动机吗？其实我是是子序列自动机+可持久化数组哒！ 但是我看见一个大神给出了一个特别神仙又巧妙的思路！我不禁要写一篇题解记录下这神奇的思路！ 而且代码贼短哦~比可持久化数组好写到不知道多少倍呢www 题意简述给定一个序列$A$长度&lt;=1e5，还要一些要询问的字符串$B$，长度和$&lt;=1e6$。对于每个$B$，询问其是否是$A$的子序列。序列中的每个值都在$1e5$以内。 思路框架在暴力匹配子序列的时候，用链表（或者vector）记录哪些询问的答案会被更新即珂。复杂度$O(1e6+1e5)$。 具体思路这个思路是洛谷上一个叫“丁文涛2004”的神仙写的一个“链式前向星-子序列自动机”。非常强大。借这篇文章膜一下这个巨佬。 正片开始。我们知道，朴素的子序列的查询是$O(|A|\times |B|)$的。我们大约是这样写的：12int p=1;F(i,1,|A|) if (A[i]==B[p]) ++p; 然后判断是否p==|B|。其中$p$表示我们当前匹配到了哪一个位置。 子序列自动机：设$nxt[i][j]$表示$i$往后第一个值为$j$的出现在哪一个位置。这样的确方便查询，但是这里值域$1e5$，这个做法显然没救了。 考虑优化第一个方法：把所有的询问放到一块来处理。那么，当我们找到一个A[i]的时候，所有满足B[p]==A[i]的p都会执行p++操作。 那么我们只要记录所有B[p]==A[i]的B[p]都在哪些位置就好了。所以，首先要用一个链表（链式前向星），把$B$的值按输入顺序串起来。然后要用一个链表把$B$按值域分类。具体的，记$head[i]$表示$B$中值为$i$的数最后一个出现的位置，$nxt[i]$表示$B$中前一个和$B[i]$相同的。然后我们令$cur=head[xxx]$，不断的令$cur=nxt[cur]$，就珂以找到$B$中所有值为$xxx$的位置了。 然后，我们在把$B$按输入顺序穿起来的时候，对于每个$B$的最后一个字符，我们令它的下一个值为$-i$，其中$i$为这个$B$在输入中的编号。这样， “既判定了匹配到了末尾，又判定了当前所在的字符串（的编号，博主注），可谓一举两得~”（作者原话） 关于如何处理询问：我们以$A$为基准，不断在$B$中找到匹配。对于每个$A[i]$，我们通过遍历前向星找到$B$中值为$A[i]$的位置。如果这个位置是最后一个位置，那么这个$B$就匹配成功，我们标记它是$A$的子序列。否则，我们把原来的指针指向$B[i]$的删掉，连接上$B[i+1]$，就是实现上面的$p++$操作。 然后我们发现，如果匹配成功了，也要删掉指针。那就不如在遍历到$A[i]$的时候，直接全部清空好了。（链式前向星清空很简单，只要令$head[A[i]]=0$即珂。） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1666666 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int type,n,q,m;//type:没什么用，给你骗分用的。满分的代码是不需要骗分的。 int a[N]; void Input() &#123; R1(type);R1(n),R1(q),R1(m); F(i,1,n) R1(a[i]); &#125; int len[N],nxtb[N],valb[N],cntb; //按输入顺序记录B的链表们www //len[i]: 第i个询问中B的长度 //nxtb[i]: 用来把B串起来。记录下标。一般nxt[i]=i+1。如果i到末尾了，那么nxtb[i]=-id。 //id为这个B的编号。这一步的妙处上面说了 //valb[i]: 和nxtb区别，这个是记录B的值。 //cntb: 总共有多少个点。到最后，它的值就等于len[i]的和。 int node[N],head[N],nxt[N],cntval; //按B的值域分类记录的链表们www //node[i]: 记录点在B中的编号,方便求出nxtb //head[i]: 记录B中最后一个值为i的位置(这边的位置是在链表中的位置，而不是B中的位置)。 //nxt[i]: 记录B中下一个和i的值相同的位置。 bool cxk[N]; //cxk[i]: 第i个询问是否是子序列 void Add(int u,int v) //B中值为u的位置添加上一个v &#123; node[++cntval]=v;nxt[cntval]=head[u];head[u]=cntval; &#125; void Soviet() &#123; #define YES (putchar('Y'),putchar('e'),putchar('s'),putchar('\n')) #define NO (putchar('N'),putchar('o'),putchar('\n')) //卡常数,putchar快，比puts快一些呢 cntval=cntb=0; //初始化(没什么用) F(i,1,q) &#123; R1(len[i]); R1(valb[++cntb]);Add(valb[cntb],cntb); //把B串起来，顺便记录值域 F(j,2,len[i]) &#123; nxtb[cntb]=cntb+1;R1(valb[++cntb]); //串起来B &#125; nxtb[cntb]=-i; //好东西，上面讲了 &#125; F(i,1,n) &#123; int cur=head[a[i]];head[a[i]]=0; //删他娘的 for(;cur!=0;cur=nxt[cur]) &#123; int u=node[cur],v=nxtb[u]; if (v&lt;0) cxk[-v]=1; //v&lt;0，说明到了末尾 else Add(valb[v],v); //否则就新加上 &#125; &#125; F(i,1,q) &#123; if (cxk[i]) YES; else NO; &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>思维</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 5631 最小mex生成树]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-5631-%E6%9C%80%E5%B0%8Fmex%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题意简述mex(S)表示集合S中没有出现的最小自然数。给定一个n个点m条边的带权无向图，求生成一颗树，使得边权集合的mex值最小。 n&lt;=1e6,m&lt;=2e6。边权范围是1e5。 思路暴力思路：检验一个值x，把边权不等于x的边权加入，判断是否能生成树 小小优化：先把边按边权排序。然后用分治法，$calc(l,r)$表示：边权在$[l,r]$之间的边没有加入。每次添加$[l,mid]$求$[mid+1,r]$，添加$[mid+1,r]$求$[l,mid]$，递归求解，即珂。可撤销并查集维护。固定范围内的边权，显然具有单调性。传参数的时候再传一个单调指针。这样就不会在找边上浪费时间。 时间复杂度$O(nlogmlogw)$。然鹅完全跑不满，所以能过。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 2000006 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class DSU &#123; public: int Fa[N],Cnt[N]; void Init()&#123;F(i,0,N-1) Fa[i]=i,Cnt[i]=1;&#125; int Find(int x)&#123;return Fa[x]==x?x:Fa[x]=Find(Fa[x]);&#125; int Merge(int u,int v) &#123; int au=Find(u),av=Find(v); if (au==av) return 0; if (Cnt[au]&lt;Cnt[av]) &#123;Cnt[av]+=Cnt[au],Fa[au]=av;return au;&#125; else &#123;Cnt[au]+=Cnt[av],Fa[av]=au;return av;&#125; &#125; void Del(int u)&#123;Cnt[Fa[u]]-=Cnt[u],Fa[u]=u;&#125; //与正常并查集不同，有删除操作 &#125;D; struct node&#123;int u,v,w;&#125;E[N]; bool operator&lt;(node a,node b)&#123;return a.w&lt;b.w;&#125; int n,m; void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,1,m) Rd(3,&amp;E[i].u,&amp;E[i].v,&amp;E[i].w); &#125; void calc(int l,int r,int pos) //pos：单调指针 &#123; if (l==r) //只有一个没有加入 &#123; //能形成生成树 if (D.Cnt[D.Find(1)]==n) &#123;printf("%d\n",l);exit(0);&#125; return; //由于我们是先求[l,mid]，再求[mid+1,r]，所以到l==r的时候，应该是先找到小的，再找到大的（类似线段树） //那么，只要找到第一个就珂以exit(0)了 &#125; int mid=(l+r)&gt;&gt;1; int cur=pos,tmp=0; //加入[mid+1,r]，求[l,mid]的解 vector&lt;int&gt; v; for(;E[pos].w&lt;=r and pos&lt;=m;++pos) //加入[mid+1,r]之间的边 //用一个vector记录我们加入的哪些边（方便撤销） &#123; if (E[pos].w&gt;mid and (tmp=D.Merge(E[pos].u,E[pos].v))) v.p_b(tmp); &#125; calc(l,mid,cur); D(i,sz(v)-1,0) D.Del(v[i]); //记得撤销 v.clear(); pos=cur,tmp=0; //同理，加入[l,mid]的边，求[mid+1,r]的解 for(;E[pos].w&lt;=mid and pos&lt;=m;++pos) &#123; if (tmp=D.Merge(E[pos].u,E[pos].v)) v.p_b(tmp); &#125; calc(mid+1,r,pos); D(i,sz(v)-1,0) D.Del(v[i]); v.clear(); &#125; void Soviet() &#123; sort(E+1,E+m+1); D.Init(); calc(0,E[m].w,1); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>生成树</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 5080 Tweetuzki 爱序列 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-5080-Tweetuzki-%E7%88%B1%E5%BA%8F%E5%88%97-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给一个集合$a$，大小为$n$。请你选出若干个数，按某种顺序排好，对于每个数（除了最后一个），它的下一个数要么是他两倍，要么是它$\dfrac{1}{3}$。你最多能从$a$选出多少个数满足这样的条件？ $n&lt;=1e5$，$1&lt;=a_i&lt;=3e18$。 比如${4,8,16,12,24}$，最多就是选出$4$个数，按$12,24,8,16$的顺序排好。容易验证，这样是最长的。 具体思路我们开一个$map$，记为$pos$。$pos[x]$表示$x$出现的位置。然后$i$向$pos[2\times a[i]]$和$pos[a[i]/3]$连边，如果$pos!=0$。这样我们就建好了一张后继图。图上任意一条路径，就是一个合法的选择方案。（显然） 然后我们讲一下为什么是$DAG$。我们走一条边，要么是乘2，要么是除3，而$2$和$3$是互质的，所以$\dfrac{2^x}{3^y}$不珂能是$1$。也就是说，一个点不会到自己。再换句话，图上没环。 然后就是实现方面的问题了。记得开$longlong$。 精髓总结关键就是要想到图是个DAG！ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 255555 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int n,a[N]; void Input() &#123; R1(n);F(i,1,n) R1(a[i]); &#125; map&lt;int,int&gt; pos; vector&lt;int&gt; nex[N]; int ideg[N],odeg[N]; void Add(int u,int v) &#123;nex[u].p_b(v);++ideg[v],++odeg[u];&#125; int dp[N],pre[N]; queue&lt;int&gt; Q; void PrintPath(int u) &#123; if (pre[u]==-1) &#123;printf("%lld",a[u]);return;&#125; PrintPath(pre[u]);printf(" %lld",a[u]); &#125; void Soviet() &#123; F(i,1,n) pos[a[i]]=i; F(i,1,n) &#123; if (a[i]%3==0 and pos[a[i]/3]!=0) Add(i,pos[a[i]/3]); if (pos[a[i]&lt;&lt;1]) Add(i,pos[a[i]&lt;&lt;1]); &#125; FK(dp); F(i,1,n) if (!ideg[i]) Q.push(i),dp[i]=1,pre[i]=-1; while(!Q.empty()) &#123; int u=Q.front();Q.pop(); F(j,0,sz(nex[u])-1) &#123;int v=nex[u][j]; if (dp[u]+1&gt;dp[v]) &#123; dp[v]=dp[u]+1;pre[v]=u; &#125; --ideg[v]; if (ideg[v]==0) Q.push(v); &#125; &#125; int Maxk=max_element(dp+1,dp+n+1)-dp; printf("%lld\n",dp[Maxk]); PrintPath(Maxk);putchar('\n'); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 5021 & libreoj 2952 赛道修建 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-5021-loj2952-%E8%B5%9B%E9%81%93%E4%BF%AE%E5%BB%BA-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给你一颗树有n(n&lt;=5e4)个点，边权&lt;=1e4。请你选出m(1&lt;=m&lt;n)条链，没有公共边，允许有公共点，使得$m$条链的边权和的最小值最大。 思路二分+树上贪心检验 具体思路首先二分是显然的，“最小值最大”是特点，而且显然有单调性。 关键在于，我们钦定了最小值mid之后，如何检验。其实我们只要能找出&gt;=m条链使得最小值&gt;=mid即珂。我们需要贪心。 （令根节点为1） 贪心策略假设现在考虑以$u$为根的子树。对于$u$的每个儿子$v$，我们选择某一条到叶子节点的不带拐弯的链（后面会讲怎么选）。这条链的长度上传给$u$节点。此外，这个长度还要再加上$u$到$v$的边权长。设这个长度为val[v]。 那么，有两种情况我们能选出来一个满足条件的链： val[v]&gt;=k，这条链不带拐弯 存在v1和v2使得val[v1]+val[v2]&gt;=k，带一个拐弯 对于情况1，直接ans++即珂。 对于情况2，我们把除了情况1以外的val值放到一个multiset里面，记为s[u]。然后我们每次拿出最小的（即123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143如果能找到，先记录答案ans++，然后把这两个从s[u]中删除。 如果找不到怎么办呢？说明这个val即不满足val[v]&gt;=k，也没有v2使得val[v1]+val[v2]&gt;=k。那么，这个val就只能上传给u的父亲。如果最后s[u]中只剩下一个珂供选择，也是同样的道理，要作为选择上传给$u$的父亲。在所有选剩下的节点中，我们显然要选长度最大的那一个给父亲。因为长度越大，越有珂能满足1和2条件中的一个。#### 简略证明正确性（解决几个小问题）1. 会不会有一个val[v1]，能找到匹配，但是直接上传到$u$的父亲比找一个$v2$匹配合算呢？ 答案是不会。因为我们直接上传对答案的贡献也许是1（也许没有），还浪费了一个良好的匹配，也许以后就会匹配不上而导致答案不优；但是找匹配的话，不仅能弄一个1出来，匹配数和上面也是一样的。那就肯定更优。所以，我们的总体策略是对的2. 匹配的问题：取val最小的，然后lowerbound找匹配，这样一定最优吗？ 因为我们还要让失配的上传给$u$的父亲，而且要尽量大。所以我们肯定是省着点用，满足条件的里面选最小的即珂，这样能使留下来的最大，给父亲的就更有珂能找到更多满足条件的链。### 代码```cpp#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[N&lt;&lt;1]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;&apos;0&apos; or c&gt;&apos;9&apos;) f=(c==&apos;-&apos;)?-1:1,c=getchar(); while(c&gt;=&apos;0&apos; and c&lt;=&apos;9&apos;) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int n,m; void Input() &#123; R1(n),R1(m); G.clear(); F(i,1,n-1) &#123; int u,v,w;R1(u),R1(v),R1(w); G.Add2(u,v,w); &#125; &#125; int ans=0; multiset&lt;int&gt; s[N];multiset&lt;int&gt;::iterator it; int DFS(int u,int f,int k) &#123; s[u].clear(); Tra(i,u) if (__v!=f) &#123;int v=__v; int val=G.Label(i)+DFS(v,u,k); if (val&gt;=k) ++ans; //val&gt;=k的直接处理掉情况1 else s[u].insert(val); //否则放到multiset里，处理情况2 &#125; int Max=0;//上传给u的父亲的最长的选剩下的链 while(!s[u].empty()) &#123; if (s[u].size()==1) //只剩一个了，直接处理掉 &#123; return max(Max,*s[u].begin()); &#125; it=s[u].lower_bound(k-(*s[u].begin()));if (it==s[u].begin() and s[u].count(*it)==1) ++it; //找到和它不相等，和&gt;=k，且最小的位置 if (it==s[u].end()) //找不到 &#123; Max=max(Max,*s[u].begin()); s[u].erase(s[u].begin());//那就相当于选剩下的，上传给u的父亲 &#125; else &#123; ++ans;s[u].erase(it);s[u].erase(s[u].begin()); //一个匹配：删掉两个，答案++ &#125; &#125; return Max;//把最大的上传给父亲 &#125; bool cxk(int mid) &#123; ans=0;DFS(1,0,mid); return ans&gt;=m; &#125; void Soviet() &#123; int l=1,r=1e9; while(l&lt;r) &#123; int mid=(l+r+1)&gt;&gt;1; if (cxk(mid)) l=mid; else r=mid-1; &#125; printf(&quot;%d\n&quot;,l); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 5020 货币系统 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-5020-%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述一个货币系统由长度为$n$的正整数序列$a$组成。每个数珂以用无限次。定义两个货币系统是等价的，对于任意一个正整数$x$，要么两个都能凑出$x$，要么两个都不能。 给定一个货币系统$(n,a)$，$n&lt;=100$，$a_i&lt;=25000$，请你求出一个和它等价的货币系统，使得这个货币系统中不同货币的数量最少。输出这个最少的数量。 思路框架如果货币系统中有一个数珂以被别的凑出来，就珂以去掉它。完全背包维护即珂。 具体思路显然$a$的顺序无关紧要，于是排个序。 设$cxk[i]$表示$i$能否被凑出来，$0$表示能，$1$表示不能。 显然答案不会超过$n$，因为显然自己和自己是等价的。初始时，设答案为$n$。 枚举每个$a_i$。如果$cxk[a_i]=1$，说明$a_i$没用，去掉。然后用完全背包更新一下即珂。 实现注意 节省空间，cxk珂以开成bitset类型 注意边界：cxk[0]=1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 122 #define V 255555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n,a[N]; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n);F(i,1,n) R1(a[i]); &#125; bitset&lt;V&gt; cxk; void Soviet() &#123; sort(a+1,a+n+1); int ans=n; F(i,0,V-1) cxk[i]=0; cxk[0]=1; F(i,1,n) &#123; if (cxk[a[i]]) &#123; --ans;continue; &#125; F(j,a[i],a[n]) cxk[j]=cxk[j]|cxk[j-a[i]]; &#125; printf("%d\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; int t;cin&gt;&gt;t; while(t--) &#123; Input(); Soviet(); &#125; &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 4830 Tomoya loves Nagisa]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-4830-Tomoya-loves-Nagisa%2F</url>
    <content type="text"><![CDATA[题意简述某人考试，他女朋友会帮他作弊。只有一个单选题，有n个选项。每次，这个人会选择一个选项，他女朋友帮他排除一个他没选的错误选项。然后他一共有k次更换选项的机会。请你求出，到最后，这个人最大有多少概率蒙对，如果这个人采取最优策略的话。 思路大家知道“三门问题”么？ 参考链接 真正理解了这个问题之后，这题就是一个沙雕变形，随手切。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define mod ((int)1e9+7) #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n,k; void Input() &#123; cin&gt;&gt;n&gt;&gt;k; &#125; int qpow(int a,int b,int m) &#123; int r=1; while(b) &#123; if (b&amp;1) r=r*a%m; a=a*a%m,b&gt;&gt;=1; &#125; return r; &#125; int inv(int x) &#123; return qpow(x,mod-2,mod); &#125; void Soviet() &#123; if (k==0) &#123; printf("%lld\n",inv(n)); &#125; else &#123; --k; int fz=n-1,fm=n; n-=2; while(k) &#123; fm=fm*n%mod; fz=(fm-fz)%mod; --n,--k; &#125; printf("%lld\n",fz*inv(fm)%mod); &#125; &#125; #define Flan void Flan IsMyWife() &#123; while(~scanf("%lld%lld",&amp;n,&amp;k)) &#123; // Input(); Soviet(); &#125; &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>概率</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 4828 Nagisa loves Tomoya 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-4828-Nagisa-loves-Tomoya-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个序列a，长度n]]></content>
      <tags>
        <tag>思维</tag>
        <tag>数学</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 4343 libreoj 2036 bzoj 4590 [SHOI2015]自动刷题机 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-4343-loj-2036-bzoj-4590-SHOI2015-%E8%87%AA%E5%8A%A8%E5%88%B7%E9%A2%98%E6%9C%BA-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述有一个刷题机，记录了这样的信息：有一个长度为$n&lt;=1e5$的序列$a$，表示写（&gt;0）或删（m$之后，你就会自动AC一个题，代码清空。现在已知你AC了$k$个题。求$m$的范围。无解输出-1. 思路很明显，$m$越大$AC$的越少。二分即珂。（话说上海的题怎么这么水） 实现注意我们怎么判断mid是取$(l+r+1)/2$还是$(l+r)/2$呢？ 我刚开始学二分的时候也为这个事情发愁。但是后来我发现一个简单易懂的理解方法。 因为我经常会调试。调试发现，就是$r=l+1$的时候陷入了一个死循环。 我们想想，$r=l+1$的时候，$(l+r)/2$相当于$l$，$(l+r+1)/2$相当于$r$。（换句话说，就是偏左的$mid$和偏右的$mid$）。然后如果我们的条件是$l=mid$，$mid$还取的是$(l+r)/2=l$，那就相当于没有减小，会死循环。所以当条件是$l=mid$，也就是要取最大值的时候，$mid$应该取$(l+r+1)/2$。 同理，当我们要取最小值的时候，也就是$r=mid$的时候，应该$mid=(l+r)/2$，这样才能让区间缩小。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define int long long #define N 155555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int n,k; int a[N]; void Input() &#123; R1(n);R1(k); F(i,1,n) R1(a[i]); &#125; int cnt(int m)//取m时的AC量 &#123; int S=0,C=0; F(i,1,n) &#123; S+=a[i]; if (S&lt;0) S=0; if (S&gt;=m) &#123;C++;S=0;&#125; &#125; return C; &#125; void Soviet() &#123; int l=1,r=1e16; while(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; int C=cnt(mid); if (C&lt;k) r=mid-1;//大了 else if (C==k) r=mid;//正好，但是我们要取最小的，因为这边是求最小值 else if (C&gt;k) l=mid+1;//小了 &#125; if (cnt(l)!=k) &#123;puts("-1");return;&#125; //判一下无解 printf("%lld ",l);//这个时候l==r，所以输出哪个都无妨 //此时l=r=m的最小值 l=1,r=1e16; while(l&lt;r) &#123; int mid=(l+r+1)&gt;&gt;1; int C=cnt(mid); if (C&lt;k) r=mid-1; //大了 else if (C==k) l=mid; //正好，但是我们要取最大的，因为这边是求最大值 else if (C&gt;k) l=mid+1; //小了 &#125; printf("%lld\n",l); //同上 //此时l=r=m的最大值 &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 4296 [AHOI2007]密码箱 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-4296-AHOI2007-%E5%AF%86%E7%A0%81%E7%AE%B1-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定$n$，输出所有的整数$x$满足：$0&lt;x&lt;n$且$x^2=1 (mod n)$。 n&lt;=2e9. 思路以下所有的$=$都表示同余（那个三条横线我不会打…） $x^2=1 (mod n)$$x^2-1=0 (mod n)$$(x-1)(x+1)=0 (mod n)$ 枚举一对$a,b$使得$ab=n$。（按对枚举因数） 然后枚举$x$使得：$x-1$是$a$的倍数且$x+1$是$b$的倍数，或者$x-1$是$b$的倍数且$x+1$是$a$的倍数。用$set$去一下重。 时间复杂度是O(n所有小于$\sqrt{n}$的因数的和，然后乘一个logn)。反正是能过的吧。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int n; void Input() &#123; R1(n); &#125; set&lt;int&gt; ans; void Soviet() &#123; for(int a=1;a*a&lt;=n;++a) if (n%a==0) //枚举a &#123; int b=n/a; //枚举b (b&gt;a) for(int x=1;x&lt;=n;x+=b) if ((x+1)%a==0) ans.insert(x); //case1 (x-1)%b==0 and (x+1)%a==0 for(int x=b-1;x&lt;=n;x+=b) if ((x-1)%a==0) ans.insert(x); //case2 (x-1)%a==0 and (x+1)%b==0 &#125; while(!ans.empty()) &#123; printf("%d\n",*ans.begin()); ans.erase(ans.begin()); &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 4159 bzoj 1297 [SCOI2009]迷路 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-4159-bzoj-1297-SCOI2009-%E8%BF%B7%E8%B7%AF-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[先说一句，矩阵真是太强了，啥玩意都能干。这个题是真的牛逼，做完我仿佛都变成了一个矩阵。 题意简述给定一个图，n]]></content>
      <tags>
        <tag>图论</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 4052 libreoj 10063 bzoj 1030 [JSOI2007]文本生成器 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-4052-loj-10063-bzoj-1030-JSOI2007-%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90%E5%99%A8-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述你要求有多少个字符串，使得： 长度为m 包含至少一个给定的单词。会给定n个单词。 膜1e4+7 思路框架用总共的方案数减去一个单词都不包含的方案数。前面那个是26^n，后面那个在AC自动机上跑DP求解。 具体思路首先，“至少一个”-&gt;“总共减去一个都没有”，是一个经典套路。这个不多说。 然后讲讲如何dp。设dp[i][j]表示，长度为i，匹配到AC自动机的第j个位置。在建立fail然后若合法，那么就从dp[i][j]转移到dp[i+1][son]。最后的答案是所有dp[m][i]的和。 实现注意 AC自动机别写挂了 多开点空间，别怂 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 14444 #define mod 10007 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) bool cxk[N]; class Ah_Chtholly_Automaton &#123; public: int tr[N][26]; int tot; void Init() &#123; FK(tr); tot=0; &#125; int Insert(char s[]) &#123; int pos=0; for(int i=0;s[i];++i) &#123; int c=s[i]-'A'; if (!tr[pos][c]) &#123; tr[pos][c]=++tot; &#125; pos=tr[pos][c]; &#125; cxk[pos]=1; return pos; &#125; int fail[N]; queue&lt;int&gt; Q; void BuildFail() &#123; FK(fail); while(!Q.empty()) Q.pop(); F(i,0,25) &#123; if (tr[0][i]) Q.push(tr[0][i]); &#125; while(!Q.empty()) &#123; int u=Q.front();Q.pop(); F(i,0,25) &#123; if (tr[u][i]) &#123; fail[tr[u][i]]=tr[fail[u]][i]; cxk[tr[u][i]]|=cxk[fail[tr[u][i]]]; //是否合法的判断：如果fail不合法，那我也不合法 Q.push(tr[u][i]); &#125; else tr[u][i]=tr[fail[u]][i]; &#125; &#125; &#125; &#125;AC; int n,m; int id[N]; char tmp[N]; void Input() &#123; scanf("%d%d",&amp;n,&amp;m); AC.Init(); F(i,1,n) &#123; scanf("%s",tmp); id[i]=AC.Insert(tmp); &#125; &#125; int dp[110][N]; int qpow(int a,int b,int m) &#123; int r=1; while(b) &#123; if (b&amp;1) r=r*a%m; a=a*a%m,b&gt;&gt;=1; &#125; return r; &#125; void Soviet() &#123; AC.BuildFail(); dp[0][0]=1; F(i,0,m-1) F(j,0,AC.tot) F(k,0,25) &#123; int ch=AC.tr[j][k]; if (!cxk[ch]) &#123; dp[i+1][ch]+=dp[i][j]; dp[i+1][ch]%=mod; &#125; &#125; int ans=qpow(26,m,mod); F(i,0,AC.tot) &#123; ans=(ans-dp[m][i]+mod)%mod; &#125; printf("%d\n",ans); &#125; void IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 3907 圈的异或 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-3907-%E5%9C%88%E7%9A%84%E5%BC%82%E6%88%96-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个无向图，点数和边数]]></content>
      <tags>
        <tag>图论</tag>
        <tag>异或</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 3736 bzoj 4565 libreoj 2063 [HAOI2016]字符合并 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-3736-bzoj-4565-loj-2063-HAOI2016-%E5%AD%97%E7%AC%A6%E5%90%88%E5%B9%B6-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述长度为n（&lt;=300）的01串，你能合并连续一段长度为k（k&lt;=8）的子串。会合并成什么，得到多少分数，由映射表决定。比如说，映射表是12341 101 100 201 30 就代表123400-&gt;1，得分是1001-&gt;1，得分是1010-&gt;0，得分是2011-&gt;1，得分是30 合理分配合并方案，使得得分最大。 思路框架区间DP+状压DP 具体思路观察到wi都是正的，所以我们肯定是把一段区间合并到不能合并才是最优的。 我们每次拿$k$个换一个（前提是有$k$个），所以每次会减少$k-1$个。区间里总共有r-l+1个，所以应该是最后合并出来的长度len=(r-l+1)/(k-1)。前驱状态长度就是len-1个。这个-1千万要注意了，如果(r-l+1)%(k-1)==0，那len就是-1了。所以，当len&lt;=0的时候，记得给他加上一个k-1。 设dp[l][r][s]表示l到r合并成状态s的最大得分。我们枚举断点mid和前驱状态s’，s’=s/2。但是s的最后一位是0/1需要分类讨论。而且满足[l,mid]合并出来的长度为len。解个方程，mid和r关于k-1同余。 我们把l到mid合并成s’，把mid+1到r合并成0/1，来更新dp[l][r][2s’+0/1]的方案。 你以为这就结束了？如果len==k-1，说明原区间的len=k，即，珂以合并完。那么此时我们就是少考虑一个转移，把这种情况特判上。我们枚举最后合并出的状态，计算得分，更新dp。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define int long long #define N 322 #define S 8 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int a[N]; int n,k; int c[N],w[N]; void Input() &#123; Rd(2,&amp;n,&amp;k); F(i,1,n) scanf("%1lld",&amp;a[i]); F(i,0,(1&lt;&lt;k)-1) Rd(2,&amp;c[i],&amp;w[i]); &#125; int to_2(char s[])&#123;int ans=0;for(int i=0;s[i];++i) ans=((ans&lt;&lt;1)|(a[i])); return ans;&#125; int range_to2(int l,int r)&#123;int ans=0;F(i,l,r) ans=((ans&lt;&lt;1)|(a[i])); return ans;&#125; int dp[N][N][1&lt;&lt;S]; void Soviet() &#123; MEM(dp,0xcf); D(l,n,1) F(r,l,n) &#123; if (l==r) &#123;dp[l][r][a[l]]=0;continue;&#125; //这个是显然的，又是边界 int len=(r-l+1)%(k-1)-1; if (len==-1) len=k-2; if (len==0) len=k-1; //这两句话注意次序，因为k-2珂能等于0。此时我们两个if都要被执行到 Ds(mid,r,l+1,mid-=k-1) F(o,0,(1&lt;&lt;len)-1) &#123; dp[l][r][o&lt;&lt;1]=max(dp[l][r][o&lt;&lt;1],dp[l][mid-1][o]+dp[mid][r][0]); dp[l][r][o&lt;&lt;1|1]=max(dp[l][r][o&lt;&lt;1|1],dp[l][mid-1][o]+dp[mid][r][1]); //区间分两半更新答案 &#125; if (len==k-1) //特判最后还有一次合并的情况 &#123; int g[2];MEM(g,0xcf); //最后剩下0/1分类讨论 F(o,0,(1&lt;&lt;k)-1) //o：合并成什么状态 &#123; g[c[o]]=max(g[c[o]],dp[l][r][o]+w[o]); &#125; dp[l][r][0]=g[0]; dp[l][r][1]=g[1]; &#125; &#125; printf("%lld\n",*max_element(dp[1][n],dp[1][n]+(1&lt;&lt;k))); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>区间DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 3648 bzoj 3675 [APIO2014]序列分割 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-3648-bzoj-3675-APIO2014-%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个长度为n(=g_k+sum[k]\times sum[i]-sum[k]^2\\ \dfrac{(g_j-sum[j]^2)-(g_k-sum[k]^2)}{-sum[j]-(-sum[k])}]]></content>
      <tags>
        <tag>DP</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 3528 libreoj 2170 [POI2011]PAT-Sticks]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-3528-libreoj-2170-POI2011-PAT-Sticks%2F</url>
    <content type="text"><![CDATA[题意简述给你一些木棍，每个木棍有长度和颜色。输出一种方案，选择三个木棍，使得颜色不一样且能拼成一个三角形。开SPJ，多解输出任意一个。 木棍数量n]]></content>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 3507 [POI2010]GRA-The Minima Game 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-3507-POI2010-GRA-The-Minima-Game-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给出n个正整数a_1,a_2,...a_n，AB两个人轮流取数，A先取。每次可以取任意多个数，直到N个数都被取走。每次获得的得分为取的数中的最小值，A和B的策略都是尽可能使得自己的得分减去对手的得分更大。在这样的情况下，最终A的得分减去B的得分为多少。（蒯的，洛谷上的） 思路排序，dp[i]=max(dp[i-1],a[i]-dp[i-1])，输出dp[n]。 具体思路无脑把a数组排序，因为显然答案和给定数字的顺序无关。 其次根据这个推性质。（注意此时我们的a已经是从小到大排好序的）。如果我在玩这个的话，那我肯定会取一段连续的出来，否则就会留下一些大的数给对手，无论如何都不划算。连续取的话，则即能保证我的最小值最大，又能保证对面的最大值最小（在取相同数量的情况下）。但是数量多少，就是我们决策的一个关键点。 关于决策：一看就知道是DP（因为不会做，又和决策有关，所以考虑瞎jbDP）。 设dp[i]表示我们考虑排好序的a中前i个数的最优答案（就是轮流取数后的最大差值）。那么首先我们要枚举上一个人走在了那里，设为j。那么由方程：dp[i]=min\{a[j]-dp[j-1]\}。注意，这里的先后手不是绝对的，是相对的。也就是时候，我们在考虑dp[i]的时候，dp[i]是先手-后手的答案，但是dp[j-1]是后手-先手的答案。而我们要求a[j]+先手-后手，所以转移方程式应该是a[j]-dp[j-1]，即a[j]-(后手-先手)，即a[j]+先手-后手。 然后我们发现这tm转移是O(n^2)的。但是a[j]-dp[j-1]的值是固定的，所以我们珂以用前缀和优化来优化这个题。 然后我们发现，我们算dp[i]需要用到i-1个状态，然后dp[i-1]需要用到i-1个状态。其中有i-1个状态是共有的，表达式都一样，而且值也没有改变。所以我们干脆就直接继承dp[i-1]的答案好了，然后多把j=i的答案a[j]-dp[j-1]给算上，求个max即珂。 转移方程变为：dp[i]=max(dp[i-1],a[i]-dp[i-1])。 实现注意需要long long呢！！！ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1666666 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n,a[N]; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n); F(i,1,n) R1(a[i]); &#125; int dp[N]; void Soviet() &#123; sort(a+1,a+n+1); F(i,1,n) &#123; dp[i]=max(dp[i-1],a[i]-dp[i-1]); &#125; printf("%lld\n",dp[n]); &#125; void IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 3469 & bzoj 1123 [POI2008]BLO-Blockade 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-3469-bzoj-1123-POI2008-BLO-Blockade-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[跟我一起念：poi！poi！poi！ 题意简述1e5个点2e5条边的无向联通图，对于每个点i，输出：删除i之后有多少有序对(x,y)使得x到y不连通，1&lt;=x,y&lt;=n，x,y不一定不等于i。（此题应援bgm：Maxi poi☆poi poi poi！） 思路框架求割点的时候，顺便求出$DFS$树。然后我们知道，一个数组$a$中任意有序选两个不相同数的积的和，即$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}[i!=j]ij$，就等于$(\sum a_i)^2-\sum(a_i^2)$（即：和平方-平方和）。 树上对于点$u$，如果不是割点，令序列$a$=${size[son1],size[son2]…size[sonk],n-size[u],1}$。（即：删掉点$u$后，被划分出的所有部分（包括$u$自成一家）的点的数量的集合）。然后求$a$的平方和-和平方即珂。由于这些东西的和显然是$n$，求出平方和即珂。 简单维护一下。如果发现$u$不是割点，直接把答案变成$2(n-1)$（因为$x,y$都珂以$=u$。） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[2666666]; void clear(int _V=N,int _E=2666666) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int n,m; void Input() &#123; R1(n),R1(m); G.clear(); F(i,1,m) &#123; int u,v;R1(u),R1(v); G.Add2(u,v); &#125; &#125; int DFSid[N],low[N],Time=0;bool Cut[N]; //Cut[i]: i是否是割点 int size[N];int part[N];int s2[N]; //size[i]：子树上有多少点（包括自己） //part[i]: 被分成了多少块，珂以理解为上面说的a序列的长度 //s2[i]： 删掉点i之后a序列的平方和 void Tarjan(int u,int f) //求割点，顺便得到DFS树 &#123; DFSid[u]=low[u]=++Time; size[u]=s2[u]=1; int tmp=0; Tra(i,u) &#123;int v=__v; if (!DFSid[v]) &#123; Tarjan(v,u); size[u]+=size[v]; low[u]=min(low[u],low[v]); if (low[v]&gt;=DFSid[u]) &#123; tmp+=size[v]; Cut[u]=1; ++part[u];s2[u]+=size[v]*size[v]; //维护平方和 &#125; &#125; else if (v!=f) &#123; low[u]=min(low[u],low[v]); &#125; &#125; //tmp:所有儿子的size值之和 //n-tmp-1珂以理解为n-size[u] if (Cut[u] and n-tmp-1!=0) ++part[u],s2[u]+=(n-tmp-1)*(n-tmp-1); //u以上的部分 &#125; void Soviet() &#123; Tarjan(1,1); F(i,1,n) &#123; if (Cut[i]) &#123; printf("%lld\n",n*n-s2[i]); //答案为n^2-s2[i] &#125; else &#123; printf("%lld\n",2*(n-1)); &#125; &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 3065 [USACO12DEC]第一!First!]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-3065-USACO12DEC-%E7%AC%AC%E4%B8%80-First%2F</url>
    <content type="text"><![CDATA[题意简述你珂以修改字母表的顺序，能否使得一个字符串是n个字符串中字典序最小的字符串？（没有重复）对于每个字符串，你都要输出它是否能成为最小的那个。是输出YES，否则输出NO。 n&lt;=30000，长度和&lt;=300000 思路框架开TRIE树，对于每个同一层的节点，连一条有向边。然后跑一遍拓扑排序，看看是否矛盾。 具体思路比如说两个字符串abcc&lt;abcd，那么就表示c要比d在前面。如果还有一个ad&lt;ac，那说明d在c前面。出现了环，所以矛盾了。 我们先把n个字符串都插入到TRIE树上。每个字符串都查询一遍，对于每个点，和它同父亲的不同节点（兄弟节点），假设深度是d，那么其它字符串和这个字符串，第一个不相同的长度就是d。那么我们要求这个字符串是字典序最小的，那么我们从这个点到同一层所有其它节点都要连一条边，表示“小于”。这样才能保证我的字典序是最小的，也就是比任何人都小。 这样建完边，跑一遍拓扑排序。复杂度是O(300000+$26^2n$ )=O(300000+2e7)。能过。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 355555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) class TRIE &#123; public: int tot=0;int ch[N][26],end[N]; void Init()&#123;FK(ch);FK(end);tot=0;&#125; void Insert(string s) //插入 &#123; int p=0; F(i,0,(int)s.size()-1) &#123; int id=s[i]-'a'; if (!ch[p][id]) ch[p][id]=++tot; p=ch[p][id]; &#125; end[p]++; &#125; bool g[26][26];int ideg[26]; queue&lt;int&gt; Q; void TopoSort() //拓扑排序：每次找到入度为0的点，删除这些点，更新新的入度。如果最后有的点入度不是0，那肯定是有环了。 &#123; while(!Q.empty()) Q.pop(); F(i,0,25) if (ideg[i]==0) Q.push(i); while(!Q.empty()) &#123; int u=Q.front();Q.pop(); F(i,0,25) if (g[u][i]) &#123; --ideg[i]; if (ideg[i]==0) Q.push(i); &#125; &#125; &#125; bool Find(string x) &#123; //g[a][b]=1：a小于b int p=0,len=x.size(); FK(g);FK(ideg); F(i,0,len-1) &#123; if (end[p])//这个字符串的一个前缀是其他字符串，那肯定不是最小 &#123; return false; &#125; int id=x[i]-'a'; F(j,0,25) if (j!=id and ch[p][j] and !g[id][j]) //j和id同父亲，j是id的兄弟节点 &#123; g[id][j]=1;// id要是最小的，所有的j都要大于id ++ideg[j]; //加边顺便维护入度 &#125; p=ch[p][id]; &#125; TopoSort(); bool flag=true; F(i,0,25) if (ideg[i]) flag=false; return flag; &#125; &#125;T; int n;string s[N];char t[N]; void Input() &#123; cin&gt;&gt;n; F(i,1,n) cin&gt;&gt;s[i]; &#125; bool cxk[N]; void Soviet() &#123; T.Init(); F(i,1,n) T.Insert(s[i]); int cnt=0; F(i,1,n) &#123; if (T.Find(s[i])) &#123; ++cnt,cxk[i]=1; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; F(i,1,n) if (cxk[i]) cout&lt;&lt;s[i]&lt;&lt;endl; &#125; #define Flan void Flan IsMyWife() &#123; ios::sync_with_stdio(false);cin.tie(0); Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>TRIE</tag>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 2680 运输计划 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-2680-%E8%BF%90%E8%BE%93%E8%AE%A1%E5%88%92-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述$n$个点的边带权树，给$m$条关键的链。把树上一条边的权值变为0，使得$m$条链的和中，最大值最小。 $n,m&lt;=1e5$。 思路二分最大值$k$。现在考虑如何检验一个$k$。 找到所有链和$&gt;k$的链，设这里面最长的链长度为$S$，有$C$条这样的链。用树链剖分找到被所有$C$条链都覆盖的边。设边权为$w$，如果$S-w&lt;=k$，又因为这条边被所有和$&gt;k$的链都覆盖了，所以，将这条边边权设为$0$，就珂以把所有和$&gt;k$的链修♂正回来。那就满足条件了，检验结果为true。 然后就这样二分即珂。 关于如何求被所有链都覆盖的边如果您足够明智，跳过这个部分好了。 开一颗临时的树，所有边权为$0$，树链剖分维护：对于所有和$&gt;k$的链$(a,b)$，在链上的边权都+1。 然后只要找边权$=C$的边即珂。 但是树链剖分维护的是点权，怎么把边权转化成点权呢？只要把一条边的权值，记录在这条边的儿子上即珂。然后我们对于链$(u,v)$作加法操作的时候，记得把$LCA(u,v)$的操作给撤回掉（就是减掉），因为这个是多算的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define int long long #define N 355555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) class Graph //图 &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[N&lt;&lt;1]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; class BIT //树状数组 &#123; public: int tree[N]; int len; void BuildTree(int _len) &#123; len=_len; FK(tree); &#125; void Add(int pos,int val=1) &#123; for(int i=pos;i&lt;=len;i+=(i&amp;(-i))) &#123; tree[i]+=val; &#125; &#125; void RAdd(int l,int r,int val=1) &#123;Add(l,val);Add(r+1,-val);&#125; int Query(int pos) &#123; int ans=0; for(int i=pos;i&gt;0;i-=(i&amp;(-i))) &#123; ans+=tree[i]; &#125; return ans; &#125; &#125;T; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int n,m; int a[N],b[N]; void Input() &#123; R1(n),R1(m); G.clear(); int u,v,w; F(i,1,n-1) R1(u),R1(v),R1(w),G.Add2(u,v,w); F(i,1,m) R1(a[i]),R1(b[i]); &#125; int fa[N],deep[N],size[N],dis[N]; int son[N],val[N]; //val[i]: i和fa[i]之间的边权，就是上面说的，“把边权记录在该边的儿子上” //dis[i]: i到根节点的带权距离（就是经过的所有边权的和） void DFS1(int u,int f) &#123; fa[u]=f; deep[u]=(u==f)?0:deep[f]+1; dis[u]=(u==f)?0:dis[f]+val[u]; size[u]=1; son[u]=-1;int Max=-1; Tra(i,u) &#123;int v=__v; if (v!=f) &#123; val[v]=G.Label(i); DFS1(v,u); size[u]+=size[v]; if (size[v]&gt;Max) &#123;Max=size[v];son[u]=v;&#125; &#125; &#125; &#125; int DFSid[N],top[N],Time=0; void DFS2(int u,int topu) &#123; DFSid[u]=++Time; top[u]=topu; if (son[u]==-1) return; DFS2(son[u],topu); Tra(i,u) &#123;int v=__v; if (v!=fa[u] and v!=son[u]) DFS2(v,v); &#125; &#125; int LCA(int u,int v) //树剖求LCA （真的只是个LCA，没别的） &#123; while(top[u]!=top[v]) &#123; if (deep[top[u]]&lt;deep[top[v]]) swap(u,v); u=fa[top[u]]; &#125; return deep[u]&lt;deep[v]?u:v; &#125; int PathLen(int u,int v)&#123;return dis[u]+dis[v]-2*dis[LCA(u,v)];&#125; //求链&lt;u,v&gt;的带权长度 void PathAdd(int u,int v,int w=1) &#123; while(top[u]!=top[v]) &#123; if (deep[top[u]]&lt;deep[top[v]]) swap(u,v); T.RAdd(DFSid[top[u]],DFSid[u],w); u=fa[top[u]]; &#125; if (deep[u]&gt;deep[v]) swap(u,v); T.RAdd(DFSid[u],DFSid[v],1); //常规树剖操作 int L=LCA(u,v); T.RAdd(DFSid[L],DFSid[L],-1); //把多算的减掉 &#125; int Maxlen; bool cxk(int k) &#123; T.BuildTree(n); int cnt=0; F(i,1,m) if (PathLen(a[i],b[i])&gt;k) //如果这条边权值过大 &#123; ++cnt; PathAdd(a[i],b[i],1); &#125; F(i,1,n) &#123; if (T.Query(DFSid[i])==cnt and Maxlen-val[i]&lt;=k) // T.Query(DFSid[i])==cnt表示i和fa[i]这条边被所有的该修正的边覆盖了 //Maxlen-val[i]&lt;=k表示，我能修正所有该修正的边 &#123; return true; //所以这个时候把(i,fa[i])这条边权值设为0，就满足条件了。 &#125; &#125; return false; &#125; void Soviet() &#123; DFS1(1,1); DFS2(1,1); Maxlen=-1; F(i,1,m) Maxlen=max(Maxlen,PathLen(a[i],b[i])); //Maxlen珂以提前求，少掉一个m T.BuildTree(n); int l=0,r=1e9; //注意：l=0（我一开始就是这样写的，没WA过，但是我猜写l=1会WA几个点） while(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; if (cxk(mid)) r=mid; else l=mid+1; &#125; printf("%lld\n",l); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>二分答案</tag>
        <tag>思维</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 2647 最大收益 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-2647-%E6%9C%80%E5%A4%A7%E6%94%B6%E7%9B%8A-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定n(]]></content>
      <tags>
        <tag>思维</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 2480 bzoj 1951 [SDOI2010]古代猪文 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-2480-bzoj-1951-SDOI2010-%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这题是个毒瘤题。你基本上要把你知道的数论算法都写上才能过。 题意简述求g^{\sum\limits_{i|n} C_{n}^{i}}\%999911659，其中n,gZoom\ Trigger->Hover） 思路用扩展：Lucas定理暴力求上面的sigma，枚举因数是根号的，Lucas是带log的，所以能过。然后无哦们用欧拉降幂对质数取膜。取膜完发现这tm还不是个质数，所以要用中国剩余定理合并答案。 具体思路step.1 假设我们能算上面那个sigma我们发现那个膜数是个质数。那么它的phi值就是999911658。 然后我们把它分解，它=2\times 3\times 4679\times 35617。我们只要以这四个数作为膜数，分别求出答案，然后用中国剩余定理合并一下即珂。就相当于求出四个答案a_1,a_2,a_3,a_4，然后解方程： x \% 2=a_1\\ x \% 3=a_2\\ x \% 4679=a_3\\ x \% 35617=a_4\\这个方程很容易解。珂是如何求上面那个sigma呢？ step.2 上面那个sigma枚举i的话是O(\sqrt{n})，但是我们还要快速的求组合数。考虑扩展卢卡斯定理： C_{n}^{m}\%p=C_{n/p}^{m/p}*C_{n\%p}^{m\%p}\%p。然后对于后面那个C_{n\%p}^{m\%p}，我们只要预处理出$1,p$之间阶乘和阶乘的逆元即珂。然后这个预处理不是每次都要预处理的，每次算之前预处理一下即珂。复杂度之和是O(2+3+4679+35617)，珂以忽略不计。然后这样递归求的话，大概总的复杂度是O(\sqrt{n}*log(n)+2+3+4679+35617)。是能过的。 好了，就到这里了，很短。但是要写很多东西。 step.3 快速幂 略实现细节 特判g=999911659的情况，输出0（要不然你就会95到自闭） 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define P 44444 #define mod 999911658 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n,g; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n),R1(g); &#125; int fac[P],ifac[P];//预处理阶乘和阶乘的逆元 int qpow(int a,int b,int m)//快速幂 &#123; int r=1; while(b) &#123; if (b&amp;1) r=r*a%m; a=a*a%m,b&gt;&gt;=1; &#125; return r; &#125; int C1(int n,int k,int p)//求一个组合数 &#123; if (n&lt;k) return 0; if (k==0 or k==n or n==0) return 1; return fac[n]*ifac[k]%p*ifac[n-k]%p; //仅限n,k&lt;=p的情况，要不然有一个是0就除爆了 &#125; int C(int n,int k,int p) &#123; if (n&lt;k) return 0; if (k==0 or k==n or n==0) return 1; return C(n/p,k/p,p)*C1(n%p,k%p,p)%p;//Lucas定理 &#125; int calc(int n,int p) &#123; fac[0]=1; F(i,1,p) fac[i]=fac[i-1]*i%p; ifac[p-1]=qpow(fac[p-1],p-2,p); D(i,p-2,1) ifac[i]=ifac[i+1]*(i+1)%p;//预处理 int ans=0; for(int i=1;i*i&lt;=n;++i)//枚举因数 &#123; if (n%i==0) &#123; int a=i; ans+=C(n,a,p);//暴力计算 ans%=p; if (i*i!=n)//别忘了判这个 &#123; int b=n/i; ans+=C(n,b,p);//暴力计算 ans%=p; &#125; &#125; &#125; return ans; &#125; int a[5],b[5]; int CRT() &#123; int ans=0; F(i,1,4) &#123; ans=(ans+a[i]*(mod/b[i])%mod*qpow(mod/b[i],b[i]-2,b[i]))%mod; &#125; return ans;//扩展中国剩余定理 &#125; void Soviet() &#123; if (g%(mod+1)==0)//会导致你WA掉的特判 &#123; puts("0"); return; &#125; b[1]=2,b[2]=3,b[3]=4679,b[4]=35617;//四个膜数 F(i,1,4) &#123; a[i]=calc(n,b[i]);//算出四个答案 &#125; printf("%lld\n",qpow(g,CRT(),mod+1)%(mod+1)); //别忘了最后输出g^CRT，而且膜数是mod+1,我令mod= &#125; void IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>中国剩余定理</tag>
        <tag>卢卡斯定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 2384 最短路 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-2384-%E6%9C%80%E7%9F%AD%E8%B7%AF-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述N&lt;=1000个点，M&lt;=1000000条边。一条路径的权定义为：所有边权的积。请你求出最短路的边权9987（先最短，再膜） 思路把边权改为$ln$边权，然后就珂以将乘法变为加法了。但是这样你会WA最后一个点，因为乘的太多爆double了。解决方案是， 正解： 每个点记录从哪个点转移过来的，即记录路径。然后用整数运算，边乘边膜，求得答案。 非正解：这样的数据只有一个点，下载数据发现答案是3922。面向数据编程即珂。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//非正解的，正解写不动了#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define real double #define N 1333 #define E 2.71828182845904523536028747135 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To;real Label;int Next; &#125;Ed[N*N&lt;&lt;1]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,real w=0.00) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,real w=0.00) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; real Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int n,m; void Input() &#123; R1(n),R1(m); G.clear(); F(i,1,m) &#123; int u,v,w;R1(u),R1(v),R1(w); G.Add2(u,v,log(1.0*w)); &#125; &#125; struct node&#123;int v;real w;&#125;;bool operator&lt;(node a,node b)&#123;return a.w&gt;b.w;&#125; bool vis[N];real dis[N];priority_queue&lt;node&gt; Q; void Dijkstra() &#123; FK(vis); F(i,2,n) dis[i]=1e18; dis[1]=0.00; Q.push((node)&#123;1,0.00&#125;); while(!Q.empty()) &#123; node Min=Q.top();Q.pop(); int u=Min.v; if (vis[u]) continue; vis[u]=1; Tra(i,u) &#123;int v=__v; if (!vis[v] and dis[v]&gt;dis[u]+G.Label(i)) &#123; dis[v]=dis[u]+G.Label(i); Q.push((node)&#123;v,dis[v]&#125;); &#125; &#125; &#125; &#125; void Soviet() &#123; Dijkstra(); if (dis[n]&gt;4580) puts("3922"); //数据过大直接面向数据。 else printf("%.0f\n",fmod(pow(E,dis[n]),9987)); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 2343 宝石管理系统 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-2343-%E5%AE%9D%E7%9F%B3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个序列，维护两种操作，加入一个数，求第k大的数。 思路很明显这个题目珂以用平衡树做。但是，有一个引人深思的问题：你会写平衡树么？ 但是， 颤抖吧，我可是会写STL的男人！我可是有STL的男人，会怕你这sb题？！所以我们考虑用vector做这个问题。插入的时候，我们只要lower_bound一下找到一个正确的位置，然后插入进去即珂。这样保证了每次插入完之后的序列都是升序的。然后我们只要找到$v.end()-k$的位置，就是第k大了（由于我们是从小到大排，所以要找第k大要从后面找）。 那么问题来了，如何插入？ insert()函数。等等。。。它不是O(n)的么？但是只要你真诚的向珂朵莉祈祷，珂朵莉就会放你过的。 你们当刚强壮胆，不要害怕，也不要畏惧他们，写他娘的STL，因为珂朵莉你的神和你同去。他必不卡掉你，也不会让你WA。 ——珂学圣经 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u);~i;i=G.Next(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) class Balance_Tree &#123; public: vector&lt;int&gt; v; void Init() &#123; v.clear(); &#125; int Rank(int i) &#123; return *(v.begin()+i); &#125; int rRank(int i) &#123; return *(v.end()-i); &#125; #define LB lower_bound(v.begin(),v.end(),x) #define RB upper_bound(v.begin(),v.end(),x) void Insert(int x) &#123; v.insert(LB,x); &#125; &#125;T; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input_Soviet() &#123; int n,q; R1(n),R1(q); T.Init(); F(i,1,n) &#123; int x;R1(x); T.Insert(x); &#125; F(i,1,q) &#123; int c;R1(c); int x;R1(x); if (c==1) &#123; printf("%d\n",T.rRank(x)); &#125; else if (c==2) &#123; T.Insert(x); &#125; &#125; &#125; void IsMyWife() &#123; Input_Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 2278 bzoj 1276 [HNOI2003]操作系统 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-2278-bzoj-1276-HNOI2003-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述你有一个CPU和若干（&lt;=15000）个进程。每个进程有四个参数：代号，到达时间，运行时间，优先级。输入顺序保证按照到达时间排序。你会先处理先到达的任务。但是当你处理一个任务到一半的时候，来了一个优先级更高的任务，那么你会把刚刚那个任务放一半，处理优先级高的任务，再回来继续处理刚刚那个任务。这时候如果再被打断，那就要在搁置一会。 就这样操作下去。按照结束时间的顺序，输出每个任务的代号，以及它结束的时间。 思路框架开优先队列维护。先处理掉时间不冲突的任务，然后把时间冲突的任务分成两半，把后面一半再放会优先队列里面。由于时间自然有序，优先队列要先比较优先级，再比较开始时间。 具体思路我们记录一个时间戳T，表示当前考虑到的时间。那么如果我们发现某个任务完成了，那么它的结束时间就是T了。输出即珂。 我们在线做，也就是说，我们不断输入进程，不断做。不实际保存。 对于新输入的进程a，我们不断找优先级最大并且在a之前就结束掉的任务。我们把它完成，并计算出它的结束时间。输出即珂（没错，边输入边输出）。 如果这个时候还有任务在队列中留着，那么我们把它和a重叠的部分单独切出来，然后重新入一次队列。删除原来那个任务。 关于如何切出来这个任务：设这个任务是t。一张丑图:其中黄色的部分就是我们t被a占用的，切出来留着后面处理的部分。它的长度是T+t.len-a.st。其它的保持不变就好了。 输入完之后，肯定还有被我们切出来的任务还没有处理。我们按优先级处理它们就好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define lovelive long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) struct task &#123; int id,st,len,pri; bool operator&lt;(const task &amp;a) const &#123; if (pri==a.pri) return st&gt;a.st; else return pri&lt;a.pri; &#125; &#125;; void Input() &#123; //none &#125; priority_queue&lt;task&gt; Q; void Soviet() &#123; lovelive Time=0; //时间戳 task a; while(~scanf("%d%d%d%d",&amp;a.id,&amp;a.st,&amp;a.len,&amp;a.pri)) //在线做 &#123; while(!Q.empty() and Time+Q.top().len&lt;=a.st) &#123; task tmp=Q.top();Q.pop(); Time+=tmp.len; printf("%d %lld\n",tmp.id,Time); &#125; if (!Q.empty()) &#123; task tmp=Q.top();Q.pop(); //去掉原来的 tmp.len=tmp.len+Time-a.st; Q.push(tmp); //切出来的重新入队列 &#125; Q.push(a); Time=a.st; //更新一下时间戳 &#125; while(!Q.empty()) //处理切出来的部分 &#123; task tmp=Q.top();Q.pop(); Time+=tmp.len; printf("%d %lld\n",tmp.id,Time); &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 1966 libreoj 2069 火柴排队 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-1966-loj-2069-%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定两个数列a,b，长度均为n(]]></content>
      <tags>
        <tag>思维</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 1841 [JSOI2007]重要的城市]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-1841-JSOI2007-%E9%87%8D%E8%A6%81%E7%9A%84%E5%9F%8E%E5%B8%82%2F</url>
    <content type="text"><![CDATA[题意简述给你一个联通的无向简单图，请你求出有多少个点满足：删除之后，存在两点最短路增长了。点数]]></content>
      <tags>
        <tag>图论</tag>
        <tag>floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 1801 黑匣子_NOI导刊2010提高（06） 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-1801-%E9%BB%91%E5%8C%A3%E5%AD%90-NOI%E5%AF%BC%E5%88%8A2010%E6%8F%90%E9%AB%98%EF%BC%8806%EF%BC%89-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个序列，支持插入一个数，或者查询第i小的数。i随着询问不断$+1$，初始为$0$。查询会给定一个序列$u$，表示当你插入到第$u_i$个数的时候就要来一次询问。$u$珂能有重复。那么你就要重复询问多次。 思路首先考虑最基础的问题：如何插入 写一颗平衡树（vector）即珂。插入的时候，就用$lowerbound$。 那么如何处理重复的询问呢？ 再写一颗平衡树（map），维护每个位置需要询问多少次。 然后对于一个位置，用一个for循环不断询问即珂。 注意我们还要用一个整形内存块（int）来维护那个随着询问不断$+1$的变量$i$。 还要写两个随机线性表（数组）来维护插入的数，和序列$u$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 255555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n,m; int a[N],q[N];//随机线性表 void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n),R1(m); F(i,1,n) R1(a[i]); F(i,1,m) R1(q[i]); &#125; map&lt;int,int&gt; cnt;//平衡树1 vector&lt;int&gt; T;//平衡树2 #define LB(x) lower_bound(T.begin(),T.end(),x) #define UB(x) upper_bound(T.begin(),T.end(),x) void Soviet() &#123; F(i,1,m) cnt[q[i]]++; int k=0;//整形内存块 F(i,1,n) &#123; T.insert(LB(a[i]),a[i]);//插入操作 //你以为我是O(n)，其实我是O(1)哒！ F(j,1,cnt[i]) //你以为我是O(n^2)，其实我是均摊O(n)哒！ &#123; printf("%d\n",T[k]); ++k; &#125; &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 1783 海滩防御 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-1783-%E6%B5%B7%E6%BB%A9%E9%98%B2%E5%BE%A1-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述平面直角坐标系上有$m(&lt;=800)$个点，每个点的$x$坐标都在$[1,n]$之内，$n&lt;=1000$，$y$坐标$&lt;=1e5$。每个点珂以设一个半径为$r$的攻击塔（攻击范围包含边界）。$x$轴上$[1,n]$的区域是敌人的进攻线，请你在每个位置都设置一些防御塔，使得敌人无法在$y$坐标上无限增大（敌人珂以各种绕路），并且$r$的最大值最小。 思路简述抽象成图。边权为两个点之间的距离/2。设置起点S，S到一个点的距离为这个点的$x$坐标。设置终点T，T到一个点的距离为n-这个点的$x$坐标。从S到T跑最短路，路径的长度定义为路径上所有边权的最大值。 具体思路如果我们的最大半径为$r$，那么肯定每个点都要设置半径$r$。反正半径又不花钱，那肯定往大里放啊。 然后对于一个点$u,v$，设距离为$d$。那么，两边都设置半径为$d/2$就能覆盖$u,v$之间的部分了。 当然，我们的目的是封锁$y$轴。稍微转化一下，就是要从左到右完美的封锁出“一条”来。“一条”珂以是曲线，看起来还很粗，只要不空出来即珂。因为敌人走位随便走，你只要一点空出来，敌人钻过去，就珂以无限向$y$轴延伸了。 所以，我们还要建立两个点，表示左边界和右边界。就是上面说的S和T。要说几何意义，就是S:直线x=0，T:直线x=n。然后S到一个点显然需要半径为这个点的x坐标值，才能封锁这个点到S的范围。T同理。 然后，对于我们从S到T，也就是从左到右，选择的一条链上，一个空位也不能有，也就是每个空都要完美的守住。所以这条链的长度就是最长边的值。 这样跑一遍最短路即珂。记得边权是实数，而不是整数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define real double #define N 1333 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) class Graph &#123; public: int head[N*N]; int EdgeCount; struct Edge &#123; int To;real Label;int Next; &#125;Ed[N*N&lt;&lt;1]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,real w=0.0) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,real w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; real Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int n,m; real x[N],y[N]; void Input() &#123; R1(n),R1(m); F(i,1,m) scanf("%lf%lf",&amp;x[i],&amp;y[i]); &#125; real d(int dx,int dy)&#123;return sqrt(dx*dx+dy*dy);&#125;//求距离 struct node&#123;int v;real w;&#125;;bool operator&lt;(node a,node b)&#123;return a.w&gt;b.w;&#125; bool vis[N];real dis[N]; priority_queue&lt;node&gt; Q; void Dijkstra(int s) &#123; F(i,1,m+2) dis[i]=1e18; Q.push((node)&#123;s,0.00&#125;);dis[s]=0.00; while(!Q.empty()) &#123; node Min=Q.top();Q.pop(); int u=Min.v; if (vis[u]) continue; vis[u]=1; Tra(i,u) &#123;int v=__v; if (dis[v]&gt;max(dis[u],G.Label(i))) &#123; dis[v]=max(dis[u],G.Label(i)); Q.push((node)&#123;v,dis[v]&#125;); &#125; &#125; &#125; &#125;//Dijkstra算法（堆优化） void Soviet() &#123; int s=m+1,t=m+2; G.clear(); F(i,1,m) &#123; G.Add2(i,s,x[i]); G.Add2(i,t,(n-x[i])); &#125;//S和T的边 F(i,1,m) F(j,1,i-1) &#123; G.Add2(i,j,d(x[i]-x[j],y[i]-y[j])/2); &#125;//两点之间的边，边权为距离/2 Dijkstra(s); printf("%.2f\n",dis[t]); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 1503 鬼子进村 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-1503-%E9%AC%BC%E5%AD%90%E8%BF%9B%E6%9D%91-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个长度为n(]]></content>
      <tags>
        <tag>STL</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 1462 通往奥格瑞玛的道路 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-1462-%E9%80%9A%E5%BE%80%E5%A5%A5%E6%A0%BC%E7%91%9E%E7%8E%9B%E7%9A%84%E9%81%93%E8%B7%AF-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述$n$个点$m$条边的无向图，点边均有权。给定$b$。请你找到一个从1到n的路使得边权和&lt;=b且点权的最大值最小。 思路二分+最短路。对于一个mid，把所有点权&lt;=mid的点之间连边，跑最短路，看是否&lt;=b即珂。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(G,i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[N&lt;&lt;1]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G,Tmp; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int n,m,b; int val[N]; void Input() &#123; R1(n),R1(m),R1(b); F(i,1,n) R1(val[i]); Tmp.clear(); F(i,1,m) &#123; int u,v,w;R1(u),R1(v),R1(w); Tmp.Add2(u,v,w); &#125; &#125; struct node&#123;int v,w;&#125;;bool operator&lt;(node a,node b)&#123;return a.w&gt;b.w;&#125; priority_queue&lt;node&gt; Q; int dis[N],vis[N]; void Dijkstra() &#123; while(!Q.empty()) Q.pop(); MEM(dis,0x3f);FK(vis); Q.push((node)&#123;1,0&#125;);dis[1]=0; while(!Q.empty()) &#123; node Min=Q.top();Q.pop(); int u=Min.v; if (vis[u]) continue; vis[u]=1; Tra(G,i,u) &#123;int v=__v; if (!vis[v] and dis[v]&gt;dis[u]+G.Label(i)) &#123; dis[v]=dis[u]+G.Label(i); Q.push((node)&#123;v,dis[v]&#125;); &#125; &#125; &#125; &#125; bool cxk(int mid) &#123; G.clear(); F(u,1,n) Tra(Tmp,i,u) &#123;int v=__v; if (val[u]&lt;=mid and val[v]&lt;=mid) &#123; G.Add2(u,v,Tmp.Label(i)); &#125; &#125; Dijkstra(); return dis[n]&lt;=b; &#125; void Soviet() &#123; if (!cxk(1e18)) &#123; puts("AFK");return; &#125; int l=0,r=1e15; while(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; if (cxk(mid)) r=mid; else l=mid+1; &#125; printf("%lld\n",l); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 1345 [USACO5.4]奶牛的电信Telecowmunication 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7-1345-USACO5-4-%E5%A5%B6%E7%89%9B%E7%9A%84%E7%94%B5%E4%BF%A1Telecowmunication-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给你一个无向图，还有源点（S）和汇点（T）。求最少删除多少个点使得源点和汇点不连通。 点数n&lt;=100，边数m&lt;=600 思路框架把每个点$u$拆成出点和入点，设为$Out(u)$和$In(u)$。 对于每个$u$，建流$In(u)\to_1 Out(u)$。 对于每个无向边，我们把它拆成两个有向边。 对于一条有向边$u\to v$，建流$Out(u)\to_{\infty}In(u)$ 从$Out(S)$到$In(T)$跑最小割（最大流），就是答案了。 具体思路这里讲讲我们是如何想到上面的拆点建图的。 原本我们的图是这样的： 这是一个点，它有入边和出边。 变成这样：（蓝边流量为1，黑边流量为正无穷） 那么我们按照这样去建图，把一个点转化成一条边，删掉边就相当于删掉点。这样，我们就珂以把求最小割点的问题，转化成求最小割边的问题了。 然后由于原图上，我们只能删除点，不能删除边。我们只要把原图上的边权都变成无穷大，就不会割掉原边了（显然不是最优解啊）。 然后，由最小割=最大流，跑一遍Dinic就完了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define INF 0x3f3f3f3f #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class Graph //这一段是裸的Dinic，会的直接跳到112行。 /* 简述函数功能 BFS/DFS：内部实现函数，会Dinic应该知道 AddFlow(u,v,w)：u到v建流，流量为w Dinic()：主求解函数，求从Source到Sink的最大流 Source和Sink珂以在外面修改 */ &#123; public: int EdgeCount; int head[N]; struct Edge &#123; int To,Label; int Next; &#125;Ed[200100]; void clear() &#123; MEM(head,-1); MEM(Ed,-1); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w) &#123; ++EdgeCount; Ed[EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void AddFlow(int u,int v,int w) &#123;AddEdge(u,v,w);AddEdge(v,u,0);&#125; int Source,Sink; int deep[N]; queue&lt;int&gt;Q,EmptyQ; bool BFS() &#123; Q=EmptyQ;FK(deep); Q.push(Source); deep[Source]=1; do &#123; int u=Q.front();Q.pop(); for(int i=head[u];~i;i=Ed[i].Next) &#123; int v=Ed[i].To; if (deep[v]==0 and Ed[i].Label&gt;0) &#123; deep[v]=deep[u]+1; Q.push(v); &#125; &#125; &#125;while(!Q.empty()); return deep[Sink]; &#125; int DFS(int u,int MinFlow) &#123; if (u==Sink) return MinFlow; for(int i=head[u];~i;i=Ed[i].Next) &#123;int v=Ed[i].To; if (deep[v]==deep[u]+1 and Ed[i].Label!=0) &#123; int d=DFS(v,min(MinFlow,Ed[i].Label)); if (d&gt;0) &#123; Ed[i].Label-=d; Ed[i^1].Label+=d; return d; &#125; &#125; &#125; return 0; &#125; int Dinic() &#123; int ans=0; while(BFS()) &#123; int d; while(d=DFS(Source,INF)) ans+=d; &#125; return ans; &#125; &#125;Nt; int n,m,s,t; #define In(x) (x+n) #define Out(x) (x) //拆点 void Input() &#123; Rd(4,&amp;n,&amp;m,&amp;s,&amp;t); Nt.clear(); F(i,1,n) Nt.AddFlow(In(i),Out(i),1); F(i,1,m) &#123; int u,v;Rd(2,&amp;u,&amp;v); Nt.AddFlow(Out(u),In(v),INF); Nt.AddFlow(Out(v),In(u),INF); &#125; //上面说的建图 &#125; void Soviet() &#123; Nt.Source=Out(s),Nt.Sink=In(t); //注意是从Out(s)到In(t)，要不然答案不对 printf("%d\n",Nt.Dinic()); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>转换思维</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 3594 [POI2015]WIL-Wilcze doły]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7%20%5BPOI2013%5DLUK-Triumphal%20arch%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最喜欢POI的题目了poi！（注意两个POI含义的区别，不懂百度） 题意简述给定一个长度为n的序列，你有一次机会选中一段连续的长度不超过d的区间，将里面所有数字全部修改为0。请找到最长的一段连续区间，使得该区间内所有数字之和不超过p。 同样是蒯的能蒯，为什么要自己写 思路分析几个性质。 当右端点往右移的时候，左端点不会往左。因为我们发现，$w_i$都是正的。所以在右移的时候，和会变大，如果左端点能往左，那么我右端点在右移之前的时候，为什么不能再往左一点呢？所以，这就有了单调性（这单调性的关键就在于$w_i$是正的） 如果要我们把连续的$d$个位置删掉，那么我们肯定会删和最大的一段。 那么此时我们就有了一个初步的思路：枚举右端点，然后记录上一次的左端点，从这个记录的值开始检查一段区间是否合法。 珂是我们如何检查这段区间是否合法呢？我们发现这个东西珂以用单调队列优化。维护前缀和，设$t[i]$表示从$i$往前$d$个数的和。然后维护一个单调队列，维护的方式： 考虑到我们要求最大的和，令单调队列中的$t[i]$值单调递减（那么队列的头就是最大值了）。 当然，也要去掉一些不合法的区间。如果区间的左端点在上一次的左端点前面，那么就不满足性质2.，也就是不满足单调性，肯定是不合法的答案，舍弃。 接着就检查是否清除掉最大能清除的区间后，和$\le p$。如果这个不满足，也要舍弃掉答案。在维护3.的时候不要忘了维护2. 然后就能得到最长的区间长度了，更新答案即珂。 对单调队列不是很熟悉，讲的不好的话，珂以看看别的奆佬的博客哦~ 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandle_Scarlet&#123; #define N 2123456 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u);~i;i=G.Next(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n,p,d; int a[N]; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n);R1(p);R1(d); F(i,1,n) R1(a[i]); &#125; int s[N],t[N]; int Q[N];int head,tail; void Soviet() &#123; F(i,1,n) &#123; s[i]=s[i-1]+a[i]; if (i&gt;=d) t[i]=s[i]-s[i-d]; &#125; head=tail=1; int ans=d; Q[tail++]=d; int last=1;//注意，[1,d]也是一个解（绝对是的，和为0） F(i,d+1,n)//枚举右端点 &#123; while(head&lt;tail and t[Q[tail-1]]&lt;t[i]) --tail; Q[tail++]=i; //维护第1部分：区间和单调递减 while(head&lt;tail and Q[head]-d+1&lt;last) ++head; //维护第2部分：满足单调性质2. while(head&lt;tail and s[i]-s[last-1]-t[Q[head]]&gt;p)//计算清楚之后的和 &#123; ++last; while(head&lt;tail and Q[head]-d+1&lt;last) ++head;//不要忘了第2部分继续维护 &#125; //维护第3部分：检查清楚之后的和 ans=max(ans,i-last+1); &#125; printf("%d\n",ans); &#125; #define FlandreScarlet void FlandreScarlet IsMyWife() &#123; if (0) &#123; freopen("","r",stdin); freopen("","w",stdout); &#125; Input(); Soviet(); &#125; #undef int //long long&#125;;int main()&#123; Flandle_Scarlet::IsMyWife(); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 2679 子串 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7%202679%20%E5%AD%90%E4%B8%B2%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定两个字符串A,B，保证A比B长，在A中取出k个不重叠的子串，使得顺序拼起来能得到B，有多少不同的方案？（相同的子串从不同的位置被取出来也是不同的方案）。 PS：复杂度最高是O(A*B^2)，因为这个值约等于4*10^8，所以不能带log。 思路很明显要DP，因为计数题的方法也没几个， DP 数据结构优化暴力 组合数学 显然，2. 不行（至今没有数据结构能维护这个），3. 不会（太难了，像我会一样），只能考虑一下1。1虽然很难，但是从可做性来讲，只有这个了。 那么如何设状态呢？（千万不要怂，尽管开空间，到时候会优化的） 考虑设dp[i][j][k]表示A中前i个位置，匹配到B的前j个位置，用了k个子串。那么我们有转移： dp[i][j][k]=dp[i-1][j-1][k-1]+dp[i-1][j-1][k]$$。 解释： 分两种情况。 1. 如果我们废掉$$A[i]$$，让它去混前面$i-1$的饭吃，那么前面就需要拼好$$k$$个，然后$$A[i]$$就被抛弃了。这种情况就是$$dp[i-1][j-1][k]$$。） 2. $$A[i]$$自力更生，那么前面只有弄好$$k-1$$个，然后我们自己拼一个即可。这样是$$dp[i-1][j-1][k-1]珂是我们发现，这样少算了A[i]和前面某一个子串合并的情况。 所以我们再加一维0/1，0表示没选A[i]，1表示选了。然后推一下式子： 也就是A[i]被扔掉了。所以i-1要凑好j个位置，转移：dp[i][j][k][0]=dp[i-1][j][k][0]+dp[i-1][j][k][1]。 选了A[i]，首先就是A[i]要能和B[j]匹配，要不然这个选择是不合法的。此时我们珂以A[i]单独出来，或者A[i]继承了以前选的某个子串。单独的方程：=dp[i-1][j-1][k-1][0,1]继承的方程：=dp[i-1][j-1][k][1]。 然后最后的答案就是dp[len(A)][len(B)][k]。 注意边界。每次枚举了i之后都要求一下边界。其中边界条件为： dp[i][1][1][0]=[1,i-1]的匹配数，其中那个匹配数珂以在求下面那个转移的时候顺便统计一下。 若A[i]==B[1]，则dp[i][1][1][1]=1 细节问题：由于循环里面也要用k，所以代码里面那个k被称为c 还有一个细节：时间够的，但是空间开不下，要用滚动数组。不过我认为，您能来做这个题，肯定会滚动数组（如果不会赶紧去补！马上NOIP了！！！（现改名CSP认证。。。）） 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1123 #define M 212 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u);~i;i=G.Next(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define mod (1000000007) //不要少打一个0（我还真干过。。。） char a[N],b[M]; int n,m,c; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n),R1(m),R1(c); scanf("%s",a+1); scanf("%s",b+1); &#125; int dp[2][M][M][2]; int sum3(int a,int b,int c) &#123; return ((a+b)%mod+c)%mod; &#125; void Soviet() &#123; int cur=0,pre=1; int s=0; #define NOW dp[cur] #define PRE dp[pre] F(i,1,n) &#123; swap(cur,pre); NOW[1][1][0]=s;//匹配数s if (a[i]==b[1]) NOW[1][1][1]=1,++s;//s就是顺便统计的匹配数 F(j,2,m) F(k,1,c) &#123; if (a[i]==b[j]) &#123; NOW[j][k][1]=sum3( PRE[j-1][k-1][1], PRE[j-1][k][1], PRE[j-1][k-1][0] ); &#125; NOW[j][k][0]=(PRE[j][k][0]+PRE[j][k][1])%mod; &#125; FK(PRE);//别忘了清空 &#125; printf("%d\n",(NOW[m][c][0]+NOW[m][c][1])%mod); &#125; void IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); // while(1); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 1099 树网的核 题解]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%B4%9B%E8%B0%B7%201099%20%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[第一次写这种大模拟题呢。。。觉得很考验码力和阅读理解能力，就写上了。 题意简述给定一个带权的树，定义： 点x到路径P的距离：P中离x最远的点的到x的距离 一条路径P的偏心距为：树上离路径P最远的点到P的距离 请找到一个路径P，使得: P的所有点在这个树的直径上 P中的边权和S，那么及时break，不要继续搜了（一个大优化） 适当使用STL以减少代码量，增加准确率（STL赛高！） 不要出现低级错误！！！（像我就写反了i,j，还好我机智，要不然肝没了） 代码（与以前的题目不同，这个题目在于读代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandle_Scarlet&#123; #define N 11234 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u);~i;i=G.Next(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) class Graph//存图 &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[N&lt;&lt;3]; void clear() &#123; memset(head,-1,sizeof(head)); memset(Ed,-1,sizeof(Ed)); EdgeCount=0; &#125; void AddEdge(int u,int v,int w=1) &#123; ++EdgeCount; Ed[EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123; AddEdge(u,v,w);AddEdge(v,u,w); &#125; int Start(int u) &#123; return head[u]; &#125; int To(int u) &#123; return Ed[u].To; &#125; int Label(int u) &#123; return Ed[u].Label; &#125; int Next(int u) &#123; return Ed[u].Next; &#125; &#125;G; int n,s; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; G.clear(); R1(n),R1(s); F(i,1,n-1) &#123; int u,v,w; R1(u),R1(v),R1(w); G.Add2(u,v,w); &#125; &#125; int dis[N],fa[N]; void DFS(int u,int f)//非常普通的DFS &#123; if (u==f) dis[u]=0,fa[u]=-1; else fa[u]=f; Tra(i,u) &#123; int v=G.To(i); if (v!=f) &#123; dis[v]=dis[u]+G.Label(i); DFS(v,u); &#125; &#125; &#125; int dis2[N];//注意：这个要新开一个dis数组用，因为上面那个dis数组要用来判断路径长度是否&lt;=S bool In[N]; void DFS2(int u,int f) &#123; Tra(i,u) &#123; int v=G.To(i); if (!In[v] and v!=f)//注意：判断!In[v]是为了只考虑路径外面的点 &#123; dis2[v]=dis2[u]+G.Label(i); DFS2(v,u); &#125; &#125; &#125; void Soviet() &#123; int l,r;//直径的两端 DFS(1,1); l=max_element(dis+1,dis+n+1)-dis;//max_element:返回区间内最大值出现的第一个位置// min_element同理，返回区间内最小值出现的第一个位置 DFS(l,l); r=max_element(dis+1,dis+n+1)-dis;// printf("diameter: %d %d\n",l,r);// 直径的求法：从1开始找到最远的点，就是第一个端点。再从这个端点跑到最远的点，就是第二个端点。 int ans=0x3f3f3f3f; for(int i=r;~i;i=fa[i]) &#123; for(int j=i;~j;j=fa[j])//枚举路径上的两个点 &#123; if (dis[i]-dis[j]&lt;=s)//注意，此处的dis是以r为根的意义下算的，但是fa数组是以// l为根的意义下算的，所以j是在i的下面的，而不是上面，所以我这里i和j写反了，大家千万不要再犯这个错误了T_T &#123;// printf("i=%d j=%d\n",i,j); FK(In); for(int k=i;k!=j;k=fa[k]) &#123; In[k]=1; &#125; In[j]=1;//标记路径上的点 for(int k=i;k!=j;k=fa[k]) &#123; dis2[k]=0; DFS2(k,k); &#125; dis2[j]=0;DFS2(j,j);//更新最小距离 ans=min(ans,*max_element(dis2+1,dis2+n+1)); //更新答案 &#125; else break;//注意及时break &#125; &#125; printf("%d\n",ans); &#125; #define FlandreScarlet void FlandreScarlet IsMyWife() &#123; if (0) &#123; freopen("","r",stdin); freopen("","w",stdout); &#125; Input(); Soviet(); &#125;&#125;;int main()&#123; Flandle_Scarlet::IsMyWife(); return 0;&#125;]]></content>
      <tags>
        <tag>树形结构</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斜率优化 笔记]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[说道斜率优化，我就想起今年下半年 湖南2008年的一个题。相信大家也不陌生（如果您是第一次学斜率优化，那估计挺陌生的）。题目叫：HNOI2008 玩具装箱TOY。题意大概是这个样子： 题意简述给你一个序列a_{[1,n]}和一个常数k。请你把这个序列分成若干段。定义：一个段[l,r]需要占用的空间X就等于r-l+\sum\limits_{i=l}^{r} a_i，然后需要的花费就是(X-k)^2。其中这个X没有限制，珂以无限长（只不过不是最优就是了）。请求出所有段的花费的最小值。 暴力思路如果您来看斜率优化的话，相信您也不难退出这个题的暴力dp。设dp[i]表示前i个数分成一些段使得总花费最小。那么，dp[i]=min{dp[j]+cost(j+1,i)}。其中cost(j+1,i)表示从j+1到i这些数在一段的花费。为了稍微快一点，设sum表示a的前缀和。那么cost(j+1,i)就等于[(i-j-1+sum[i]-sum[j])-l]^2。 但是这个dp是O(n^2)的。能不能再快一点呢？（严格来讲，你必须要再快一点，要不然这个时间就卡不过去） 正片开始：斜率优化把关于i的项和关于j的项单独提出来。变成： 设a(x)=x+sum[x],b(x)=x+sum[x]+l+1。那么原式等于$(a(i)-b(j))^2$。 稍稍改变j的定义，令j是满足条件中最优的j。 那么：（推式子警告） dp[i]=dp[j]+(a(i)-b(j))^2\\ dp[i]=dp[j]+a(i)^2-2a(i)b(j)+b(j)^2\\ dp[i]+2a(i)b(j)-a(i)^2=dp[j]+b(j)^2把这个式子放到平面直角坐标系上，以b(j)为x，dp[j]+b(j)^2为y。 对于每个j来说，点(b(j),dp[j]+b(j)^2)就是一个决策点了。 而且，显然这是一个直线的关系，它的斜率就是2a(i)，截距是dp[i]-a(i)^2。我们把直线向上平移a(i)^2，就是最小的dp[i]。由于a(i)^2的值是确定的（我们在找j的过程中，i是不会变的），所以在同一个i里面，我们相当于要让截距最小。 这样，对于每个i（注意，和上面不一样，不在同一个i里面了），珂能作为最优点选择出来的点应该组成一个下凸包（因为a(i)是单调递增的，所以斜率单调递增，即组成下凸包）。 （a(i)的单调递增性我就不讲了） 为啥？考虑这种情况：（A，B，C是珂供选择的三个决策点） 当前的话，如果A还没滚蛋，应该是A比B优的。如图 随着斜率的增加，也许会出现C比A和B都优的情况。如图： 容易证明，C此时一枝独秀，A和B都珂以滚蛋了。这两种情况有一个共同点，就是B都不能再优了。anyway，滚蛋吧。 还有一种情况（肯定还有，只有刚刚那一个是没法保证正确性的），就是最前面两个元素还要满足一个条件：第一个点和第二个点之间的斜率要>=2a(i)，否则第一个就再也不珂能作为最优解出现了，因为此时随着斜率的单调递增，后面的斜率肯定会更大，在当下的2a(i)的斜率中第二个都比第一个优，后面的话就不知道优到哪里去了。所以第一个就再起不能，滚了。 如图： 还是刚刚那张图，不过是另一种滚蛋方法。此时红色直线的斜率=2a(i)=20。当红色直线斜率为20的时候，A就没有B优了。如果再高一点，显然，还是没有B优。所以以后这个A都不珂能比B更优了。A就珂以滚蛋了。 说道这里，我们发现，这个东西珂以用一个单调队列维护。维护完一个正确的队列之后，Q[head]就是最优解。 设队列为Q，首尾分别叫head,tail。 总结一下，就是要维护两个关系： 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 112345 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u);~i;i=G.Next(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n,l; int c[N]; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n),R1(l); F(i,1,n) R1(c[i]),c[i]+=c[i-1]; &#125; int Q[N]; int dp[N]; int a(int i)&#123;return c[i]+i;&#125; int b(int i)&#123;return c[i]+i+l+1;&#125; int x(int i)&#123;return b(i);&#125; int y(int i)&#123;return dp[i]+b(i)*b(i);&#125; int slope(int i,int j)//计算斜率 &#123; return (y(i)-y(j))/(x(i)-x(j)); &#125; void Soviet() &#123; int head=1,tail=1; F(i,1,n) &#123; while(head&lt;tail and slope(Q[head],Q[head+1])&lt;2*a(i)) ++head; //垃圾决策点出队列 dp[i]=dp[Q[head]]+(a(i)-b(Q[head]))* (a(i)-b(Q[head])); //Q[head]就是最优的决策点。 while(head&lt;tail and slope(i,Q[tail-1])&lt;slope(Q[tail-1],Q[tail])) --tail; Q[++tail]=i; //把i加入队列 &#125; printf("%lld\n",dp[n]); &#125; void IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125; 还有一些答疑时间（根据作者自身出现的理解问题编写，以后支持评论功能之后珂能会根据评论区中的问题编写。） Q：既然Q[head]是最优的，为啥还要存着后面的点呢？A：后面的点虽然现在不是最优的，但是它们很有潜力，等以后斜率上去之后，也许Q[head]就滚蛋了，后面那些点就变成了最优。注意上面，我们说的是珂能成为最优的点，而不是现在最优的点。要为未来着想。]]></content>
      <tags>
        <tag>DP</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契循环节 笔记]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BE%AA%E7%8E%AF%E8%8A%82-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这篇是比较具体的吧…很多证明网络上别的博客是没有的，只有一个结论。还有一篇博客用了很多复杂的东西里证明，虽然我能勉强看懂，但是很多人珂能看不懂。这篇也许算一个适中的了，容易理解些，但是证明少些。 如果您有更好的证明，或者能补全我没有的证明，也很感谢了。 正片开始关于斐波那契数列，大家应该都不陌生。$f_1=1,f_2=1,f_n=f_{n-1}+f_{n-2}$。斐波那契循环节，就是求斐波那契数列膜一个数的循环节长度。假设这个膜数为$m$。那么以下的式子，如果没有说明，都是膜$m$意义下的。 一些简单的变换设斐波那契数列膜$m$的循环节长度为$l(m)$。形式化地，$m$为最小的满足$f_i=0,f_{i+1}=1$的正整数。而且，如果存在$n$满足$f_n=0,f_{n+1}=1$，那么$n$是$m$的正整数倍。我们管这个叫珂朵莉的定义式。 我们把$m$质因数分解成$a_1^{p_1}a_2^{p_2}a_3…a_k^{p_k}$的形式。对于一个$a^p$，满足$l(a^p)$=$l(a)\times a^{p-1}$。然后$l(m)$，是每个$l(a^p)$的最小公倍数的因数。我们管这个叫珂朵莉第一定理。 那么接下来的部分，我们都是在求膜一个质数的循环节长度。 膜质数$p$的循环节长度特殊说明来了：以下的式子，如果没有第二个特殊说明，都是膜$p$意义下的。 我们知道斐波那契数列有通项公式，你可以用特征方程，或者百度，必应和谷歌等方式证明这个公式：设$\sqrt{5}=q$，则$f_i=\dfrac{1}{q}[(\dfrac{1+q}{2})^i-(\dfrac{1-q}{2})^i]$。 分类讨论$5$模$p$的二次剩余情况。 0. 特判如果$p=2,3,5$，直接判掉，因为后面的式子仿佛都要$p&gt;5$。顺便说一句，此时$l(p)$的值分别是$3,8,20$。 1. $5$膜$p$有二次剩余 （p=1或4 膜5）此时，$q$是存在的，满足$q^2=5 (mod p)$。然后，根据费马小定理，循环节的长度就一定是$p-1$的倍数，具体是哪个，就暴力验证一下即珂。因为因数最多$\sqrt{p}$个，一次验证（矩阵快速幂）是$O(log)$的，顶多$O(\sqrt{p}logp)$。一般这也就够了… 2. $5$膜$p$没有二次剩余 (p=2或3 膜5)由勒让德记号（自行百度）的特征得知，$5^{\dfrac{p-1}{2}}=-1$。 考虑$({1+q})^p$这个式子。由于$p$是质数，所以$C_p^i (0&lt;i&lt;p)=\dfrac{p(p-1)(p-2)…(p-i+1)}{i!}$中，$i!$和$p$肯定是互质的，所以最后的结果肯定等于$p$乘以一大堆式子。又因为这个组合数肯定是整数，所以后面一大堆式子也就是整数了。换句话说，$C_p^i$肯定是$p$的倍数。 然后我们用二项式定理拆开$(1+q)^p$这个式子，中间有一些项，膜$p$肯定都是$0$，只剩下$1+q^p=1+5^{\dfrac{p-1}{2}}q$。 然后因为$5^{\dfrac{p-1}{2}}=-1$，所以$(1+q)^p=1-q$。 又因为$p&gt;5$，所以显然满足$2^{(p-1)}=1$ 所以$(\dfrac{1+q}{2})^p=(\dfrac{1-q}{2})$。 带入$i=2p+2$到$f_i$，直接上通项公式。把$(\dfrac{1+q}{2})^{2p+2}$代换一下，变成$(\dfrac{1+q}{2})^2(\dfrac{1-q}{2})^2$。同理，后面的$(\dfrac{1-q}{2})^{2p+2}$变成$(\dfrac{1-q}{2})^2(\dfrac{1+q}{2})^2$。相等，然后把它们相减，为$0$。 然后我们带入$i=2p+3$进去，自己推一下，它等于$1$。 由珂朵莉的定义式知，此时循环节长度是$2p+2$的倍数。 这上面三个东西，我们得到一些结论： p=2,3,5,l(p)=3,8,20 p=1,4 (mod 5)，l(p)|p-1 p=2,3 (mod 5)，l(p)|2p+2 （珂朵莉：这个暴力算就好了） 我们管这个叫珂朵莉第二定理。 总结求循环节的步骤： 质因数分解求每个质因子的循环节，然后用珂朵莉第一定理合并答案对于每个质因子，用珂朵莉第二定理求出循环节长度然后你就求出了循环节。求出了循环节之后，您就珂以做一些奇妙的题目，比如这个： 求$f_i\%p$，其中$i&lt;=10^{30000000}$，$p&lt;=1e9$。（洛谷4000） （先求循环节，然后直接算） 这个的代码（用了$vector$，比较好理解，但是常数巨大）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 30000007 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) class Matrix//这是一个矩阵，这个实现自己写就好了，不需要阅读 &#123; #define NN 5 private: int a[NN][NN]; public: int n; Matrix() &#123; memset(a,0,sizeof(a)); n=0; &#125; Matrix(int _n) &#123; memset(a,0,sizeof(a)); n=_n; &#125; Matrix(int _n,int _x) &#123; n=_n; for(int i=0;i&lt;NN;++i) &#123; for(int j=0;j&lt;NN;++j) &#123; a[i][j]=_x; &#125; &#125; &#125; int* operator[](int i) &#123; return *(a+i); &#125; void Set(int x) &#123; for(int i=0;i&lt;NN;++i) &#123; for(int j=0;j&lt;NN;++j) &#123; a[i][j]=x; &#125; &#125; &#125; void Identity() &#123; memset(a,0,sizeof(a)); for(int i=0;i&lt;NN;++i) &#123; a[i][i]=1; &#125; &#125; #undef NN //5 &#125;; Matrix Times(Matrix x,Matrix y,int mod) //两个矩阵%mod的积 &#123; Matrix ans(x.n,0); int n=ans.n; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) &#123; if (x[i][j]) &#123; for(int k=1;k&lt;=n;++k) &#123; ans[i][k]+=(x[i][j]*y[j][k])%mod; ans[i][k]%=mod; &#125; &#125; &#125; &#125; return ans; &#125; Matrix Qpow(Matrix x,int p,int mod) //x^p %mod &#123; Matrix ans(x.n,1); ans.Identity(); while(p) &#123; if (p&amp;1) ans=Times(ans,x,mod); x=Times(x,x,mod),p&gt;&gt;=1; &#125; return ans; &#125; //以上为矩阵 int Fib(int x,int mod) //求f[x] % mod &#123; Matrix Trans(3,0); Trans[1][1]=Trans[1][2]=Trans[2][1]=1; if (x==0) return 0; if (x==1 or x==2) return 1; Matrix Ans=Qpow(Trans,x-1,mod); return Ans[1][1]; &#125; int p;char a[N]; void Input() &#123; scanf("%s%lld",a,&amp;p); &#125; struct node&#123;int fac,pow,sum;&#125;; //这是一个因式，它等于fac^pow，sum记录fac^pow的值，方便后面求fac^(pow-1) （珂朵莉第一定理的式子） vector&lt;node&gt; Factor(int x) // 把x分解成很多个node &#123; vector&lt;node&gt; ans;ans.clear(); for(int i=2;i*i&lt;=x;++i) &#123; if (x%i==0) &#123; node cur;cur.fac=i;cur.pow=0;cur.sum=1; while(x%i==0) &#123; cur.sum*=i; x/=i; ++cur.pow; &#125; ans.push_back(cur); &#125; &#125; if (x&gt;1) &#123; ans.push_back((node)&#123;x,1,x&#125;); &#125; return ans; &#125; int Get1(int p) //珂朵莉第二定理求f[i]%p的值 &#123; if (p==2) return 3; if (p==3) return 8; if (p==5) return 20; // 特判 int len; //l(p)是len的因数 if (p%5==1 or p%5==4) len=p-1; //有二次剩余的情况 else len=2*(p+1); //没有 // 你在这里直接return len也不是没有问题，因为这题你只要求斐波那契数列的值。至于你求的是最小的循环节，还是它的某一个倍数，这不重要 vector&lt;int&gt; fac; //保存因数 for(int i=1;i*i&lt;=len;++i) &#123; if (len%i==0) &#123; fac.push_back(i); if (i*i!=len) fac.push_back(len/i); &#125; &#125; sort(fac.begin(),fac.end()); //排个序，以便求最小的 F(i,0,(int)fac.size()-1) &#123;int v=fac[i]; if (Fib(v,p)==0 and Fib(v-1,p)==1) &#123; return v; //找到第一个就返回吧 &#125; &#125; return len;//这句没什么用... &#125; int lcm(int a,int b)&#123;return a*b/__gcd(a,b);&#125; int GetLen(int x) //用珂朵莉第一定理合并 &#123; vector&lt;node&gt; fac=Factor(x); int ans=1; F(i,0,(int)fac.size()-1) &#123;node u=fac[i]; int cur=Get1(u.fac)*u.sum/u.fac; ans=lcm(ans,cur); &#125; return ans; //严格上来说，l(x)应该是ans的因数，而不一定是ans。但是，和上面类似的道理，我懒的写了，直接返回ans。 &#125; void Soviet() &#123; int mod=GetLen(p); //求循环节 int aa=0,la=strlen(a); F(i,0,la-1) &#123; aa=(aa*10+a[i]-'0')%mod; &#125; //取一下膜 printf("%lld\n",Fib(aa,p)); //然后直接做即珂 &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>数论</tag>
        <tag>斐波那契</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学文章 关于圆锥体积公式的证明]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%95%B0%E5%AD%A6%E6%96%87%E7%AB%A0-%E5%85%B3%E4%BA%8E%E5%9C%86%E9%94%A5%E4%BD%93%E7%A7%AF%E5%85%AC%E5%BC%8F%E7%9A%84%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[我们大约在小学四年级的时候学过圆锥的体积=等底等高圆柱的体积除以3 有人问了：怎么是除以3呢？我觉得应该是2鸭。。。（我当时就是这么想的） 也很好想，圆锥是由一个三角形转出来的，圆柱是一个长方形转出来的，三角形的面积是对应长方形的一半，那么转一圈之后，体积应该也是一半鸭？ 很简单，三角形是长方形面积一半，是因为面是线叠加起来的，也就是$[0,h]$中$f(x)=\dfrac{rx}{h}$的积分。 但是体积是$f(x)=(\dfrac{rx}{h})^2\times \pi$的积分。一次的时候是两倍关系，但是现在是二次。所以就不一定是两倍了。 然后现在我们就来求$f(x)=(\dfrac{rx}{h})^2\pi$的积分。显然，$\pi(\dfrac{r}{h})^2$是常数，提出来。然后剩下$x^2$。先求不定积分得$\dfrac{1}{3}x^3$（这里已经出现$\dfrac{1}{3}$了，所以，体积公式的$\dfrac{1}{3}$是积分的时候得到的）然后用牛顿-莱布尼茨公式（说$OI$话，就是前缀和相减），$f(x)=(\dfrac{rx}{h})^2\times \pi$的定积分为代入$x=h$时的不定积分-代入$x=0$时的不定积分，也就是$\pi(\dfrac{r}{h})^2 \times \dfrac{1}{3}h^3+C-C=\dfrac{1}{3}\pi \dfrac{r^2 h^3}{h^2}=\dfrac{1}{3} \pi r^2 h$。证毕。]]></content>
      <tags>
        <tag>纯数学</tag>
        <tag>纯数学-微积分</tag>
        <tag>纯数学-立体几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文自动机 笔记]]></title>
    <url>%2F2020%2F02%2F10%2F%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天日常给同学@CollinGao 写奥♂义。讲到了这个东西，还是挺有用的，就是有点毒瘤？仿佛没什么人知道的亚子。。。 不是很难理解的算法，我在期中考试考场上就直接yy出了一个来。虽然马上CSP了，但是我还是准备来颓废，写写这篇奥♂义。 基础题型给你一个字符串，对于每个前缀，求该前缀中有多少前缀不同的回文子串。定义一个回文子串的权值为：长度乘以出现次数。对于每个前缀，也请你求出最大的回文子串的权值是多少。 回文自动机（又名回文树）是干啥的大家都知道TRIE树（知道即珂，但是如果连听说都没听说过，那劝退了）。在TRIE树上，每个节点表示一个字符串，字符记录在边权上。连一条边表示在这个字符串后面加上一个字符。 那么，回文自动机是怎么弄的的？连一条边，表示在这个字符串前后各加上一个字符。比如某个父亲的字符串为”aba”，连了一条权值为’c’的边到儿子，儿子的字符串就是”cabac”。 然后要注意一点，回文自动机有两个根。其原因很显然，因为一个父亲以下的字符串长度的奇偶性不会改变。所以，两个根分别记录奇数长度和偶数长度的回文串，名字就叫奇根和偶根。偶根很好理解，表示一个空串，其长度为$0$。那么，奇根怎么办呢？仔细一推，单个字符长度为$1$，其父亲的长度为其长度$-2$，也就是说，奇根表示的字符串长度为$-1$？！ 没事，$-1$就$-1$，只不过是为了方便计算罢了。实际实现中，考虑到空间问题，我们并不会实际记录表示的字符串，只是记录一个长度$len$。那么，只要让这个点的$len=-1$即珂，一点问题都没有。 fail指针精髓（准确来讲，是每个自动机的精髓）。对于一个节点，它的$fail$指针是指：除了自己之外，LPS（Longest Palindrome Suffix，最长回文后缀）所对应的点。如果你仔细咀嚼了这句话，那么你会想这样一个问题：除了自己之外的最长回文子串一定在树上能找到吗？ 证明fail一定在树上能找到（如果您能自己证明，请跳过这段）设当前节点表示字符串$s$，$fail$指向的节点所对应为$f$，$f^t$表示把$f$反过来，$|f|$表示$f$的长度，如图所示。 由于$S$是回文串（根据定义），$S$的前缀$|f|$个字符串和后缀$|f|$。$S$和$f$都是回文的，非常容易证明，$S$的$|f|$个前缀和这么长的后缀是一样的。那么，$f$在后面出现一遍，就说明在前面也出现了一遍。由于我们是从前往后加入到树上的，所以这个串一定能找到。 证毕 $\blacksquare$如何构建上面讲了一下，我们是按照从前往后的顺序插入$s$的每个字符的。对于插入第$i$个位置，我们的任务是找到其$LPS$，并把它插入到树上的正确位置。那么，如何找到呢？ 等价一下，这个节点满足： 它是i-1位置的一个回文后缀 它左右字符相等，都是$s[i]$ 对于满足条件1，我们记录一个$last$，表示$i-1$插入在了树上哪个位置。（当我们插入完$i$的位置的时候，我们令它为我们找到的位置，即珂维护） 然后$last$显然就是$i-1$的一个回文后缀。但是我们要找到所有的回文后缀，那没问题，我们不断的跳$fail$即珂。 然后还要满足条件2。设现在我们跳到了点$cur$，这个点上的长度值为$len(cur)$。只要判断$s[i]==s[i-len(cur)-1]$即珂。如果满足就退出，不满足就$cur=fail(cur)$，继续循环。 关于$fail$的维护：很简单，和上面找到父亲的过程只差一个$cur$初始值的区别。因为$fail$指针要满足不等于自己，所以，$cur$的初始值，不是$father$，而是$fail(father)$。和找到父亲的步骤还有一点点不同，就是最后找到一个$cur$满足$s[i]==s[i-len(cur)-1]$的时候，返回的不是$cur$而是$cur$的边权为$s[i]$的儿子。这里还有一个至关重要的细节要注意，先求出fail指针，才能连边。代码中会提到。 那么我们来举一个例子。我们要构建的字符串s=”bilibili”。 初始化，构建奇根和偶根。红色是奇根，绿色是偶根。特殊地（忘了讲了），奇根和偶根的$fail$指针（黄色）互相指向对方。 第一步，插入位置$1$。默认是插入到$0$上，失败了再跳$fail$。我们发现，$s[1]!=s[1-len(0)-1]$，于是跳了$fail(0)=1$，然后显然满足了。我们还发现，此时还没有节点，便新建一个节点（编号为$2$），把它接在奇根（$1$）下面。跳一下$fail$，发现$fail$是$0$（显然）。由于很多节点的$fail$都是$0$，这些边我就不连了（为了看起来美观）。效果图： 时间关系，我们不仔细看每一个位置的插入过程，直接跳到第$5$个位置的插入。这之前的图建出来长这样： 然后我们大喊一声：King Crimson！ 第五步，插入位置$5$，此时前缀为$bilib$。默认插入在$last$上，也就是编号$5$的位置。我们一下就满足了条件，所以我们的确要接在$last$下面。求一下$fail$指针，先到$fail(5)=3$试一下，发现，不行。然后跳到$fail(3)=0$试一下，还不行，跳到$fail(0)=1$再试一下，行了，返回$1$的边权为$si$的儿子，也就是编号为$2$的节点。完成之后，图长这样： 让我们再大喊一声：King Crimson! 最终完成图： 然后我们这就构建好了一个回文自动机。 附：“我的讲义，能抄下来么？”“能抄一点。”“让我康康！”“你看，这个fail边，应该连在儿子这里的。尽管你这样画很好看，但这个fail边就是这样连的，你不能改变它”我心里还是有点不服气。图还是我画的好，至于这条边到底连在哪里，我自然是知道的。 —— 选自 鲁迅《藤野先生》 实现（你们最想要的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Palindrome_Tree //我喜欢写面向对象&#123;public: char s[N]; struct node &#123; int len,fail; int ch[26]; &#125;t[N];//保存一个节点 node&amp; operator[](int id)&#123;return *(t+id);&#125; int last; int cnt=1;//上一次插入在哪 void Init(char ss[N]) &#123; FK(t); strcpy(s+1,ss+1); t[0].len=0;t[0].fail=1; t[1].len=-1;t[1].fail=0;//len=-1!!!!! //注意:fail是互相指的 last=0;//开始默认接在0上,后来就接在last上,不行就跳fail &#125; int Getfail(int fa,int pos) &#123; int cur=t[fa].fail; for(;s[pos]!=s[pos-t[cur].len-1];cur=t[cur].fail); //不行就跳fail int id=s[pos]-'a';return t[cur].ch[id];//返回fail的儿子，记住藤野先生的话 &#125; void Insert(int pos) &#123; // printf("Insert %d\n",pos); // 方便理解用 int cur=last;//注意初始值 while(s[pos-t[cur].len-1]!=s[pos]) &#123; cur=t[cur].fail; &#125;//同上，不行就跳fail的过程 int id=s[pos]-'a';//当前字符 if (t[cur].ch[id]==0) //如果还不存在这个节点 &#123; ++cnt;//新加一个节点 t[cnt].len=t[cur].len+2;//len+=2，显然 t[cnt].fail=Getfail(cur,pos);//求出fail t[cur].ch[id]=cnt;//次序关键！先求fail，再连边 // printf("fail[pos]=%d\n",t[cnt].fail); &#125; last=t[cur].ch[id]; &#125;&#125;T; 应用我们讲了这么多，来解决些实际问题。 本质不同的回文串个数每个点（除了奇根和偶根）都一一对应一个本质不同的回文串。只要输出$cnt-1$即珂。（应该是点数-2，但是由于我是从0开始算点的，所以-1才是正确的） 每个回文串的个数每个点维护一个值$cnt$（重名了，但是因为命名空间不一样，写在struct里，所以不会报错）。然后插入一个点时，找到它所在的树上位置，该点上$cnt++$。最后再$cnt[fail(i)]+=cnt[i]$，i从$n$到$1$。和$KMP$中计算每个前缀出现的次数是类似的原理。 尝试一下： 洛谷 板子 （5496） 洛谷 5555 bzoj 3676 终于不是板子的：CF17E]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>字符串</tag>
        <tag>回文自动机</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈论(van♂游戏) 笔记]]></title>
    <url>%2F2020%2F02%2F10%2F%E5%8D%9A%E5%BC%88%E8%AE%BA-van%E2%99%82%E6%B8%B8%E6%88%8F-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言会持续更新的呢，毕竟博弈论是个毒瘤啊。 其实不要以为博弈论很变态，它是很有趣的。能理解透的话，一点都不难。其实，博弈论的本质，就是教你van♂游戏啊！ 从一个简单的问题（Nim）入手有n堆石子，你每次珂以从某一堆中取出若干个石子。先后手轮流操作。如果某个人把石子取完了，那就赢了。换句话说，如果某个人没有石子取了，那就输了。先手有必胜策略么？ 我们遇到什么问题，也不要怕，暴力的面对它！消除AC的最好办法就是爆搜！加油，TLE！最强的数据是$n&lt;=1e5$，石子数$&lt;=1e18$。而我们只需要两三行代码就能解决问题。爆搜都没有这么短。 我们考虑把每一堆石子的数量二进制拆分。（为什么是二进制？因为二进制只有$0$和$1$，没有系数，方便考虑）比如$7$就变成$4+2+1$。 我们把它变成一个$n$行$loga$列的矩阵。比如$a={3,4,7}$，变成：1230 1 11 0 01 1 1 考虑先手必败的情况：每一列上的数和都是偶数时，必败。（珂朵莉第一博弈定理） 证明：每一列和均为偶数时，先手必败对于某个$a_i$，我们把它减去某个数，就相当于把$a_i$某一些位置上的0/1变成了1/0。那么我们找一个最高位不低于$a_i$的$a_j$，把相同的位置上的0/1也变成1/0。（由于每一列的和都是偶数，所以我们肯定能找到一个最高位不低于$a_i$的$a_j$）这样一波操作，每一列的和肯定还都是偶数。先手能操作，后手就一定能操作。后手操作到最后一步，先手就没了。而且先手肯定赢不了。 证毕所以除了这样以外，肯定是先手必胜。也能想象出必胜策略：把某一堆石子拿掉一些，让剩下的局面变成必败型，然后留给后手下。根据上面的“珂朵莉第一博弈定理”，后手必败，所以先手必胜。 组合游戏都尼玛是定理。自己查资料，或者参考刘汝佳的《算法竞赛入门经典——训练指南》（小蓝书）。要电子稿的联系3348064478@qq.com，我会友情赞助的。 把别的游戏转化成Nim游戏Nim游戏的精髓在于几个关键词： “减少” 没了就赢了 这里，减少打上了引号。因为减少，珂以是各种你想不到的形式，比如说把某个数变成它的一个因数，也是一种“减少”。（本质就是，把它分解质因数，然后减少了几个项的指数）。当然，减少了什么变量，也是一个珂以转化的点。举几个刘汝佳书上的例子罢。 翻棋子游戏有一个n行m列的01矩阵。每次珂以选一个为1的位置(x,y)，把它和同一行/列上，且在严格左/上方位置的一个位置，同时翻转（异或1）。不能操作就输了。先手还是后手必胜。 解法把一个为1的位置上的(x,y)看成两堆大小为x和y的石子。原因：同一行/列，就是告诉你只能改变x，y中的一个。严格左/上方告诉你必须要是减小。好的，到这一步就能理解为什么这样能转化成Nim了。 除法游戏n行m列的矩阵，每一行有一些正整数。先后手轮流操作。每次选择同一行中，若干个元素，把这些数都变成它们的某个真因子（就是不等于自己，而且是自己的因数）。不能操作的输。 （PS：1没有真因子） 解法把每一行的所有数的质因数的指数和相加。原因：真因子相当于减少某一项质因数的指数。同一行只是唬你的幌子。只要把同一行的加起来就珂以了。]]></content>
      <tags>
        <tag>博弈论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA11997 K Smallest Sums 题解]]></title>
    <url>%2F2020%2F02%2F10%2FUVA11997-K-Smallest-Sums-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述一个大小为$n$的方阵，每行都选一个数，得到一个和。一共能得到$n^n$个和。求出最小的前$n$个。重复的算多次。$n&lt;=700$。 思路框架每两行都来一个多路归并即珂。 具体思路今天去看了刘汝佳的小蓝书。感谢刘汝佳，让我知道优先队列原来还能这么用。 首先，每行里面顺序不重要，先排序再说。 前置知识：n路归并问题我们应该都知道“二路归并”问题：两个有序的序列，要合并成一个有序的序列。解法很简单，维护两个指针，哪个小就把哪个加入答案，然后让指针++。利用它，我们珂以写出大名鼎鼎的「归并排序」算法。 $n$路归并问题就是：$n$个序列，每个序列都是有序的。要合并成一个长度为$n^2$的有序的序列。 但是我们发现，我们要维护$n$个指针，一次维护指针是$O(n)$的，我们一共有$n^2$的元素，就变成$O(n^3)$了。怎么样更快呢？我们珂以用优先队列来找到值最小的那个指针。这样维护一次指针是$O(logn)$的，总共就是$O(n^2logn)$的了。而且原问题中我们只需要求前面的$n$个，所以这会更快，变成每次$O(nlogn)$的时间。 如何转化我们的原问题是有$n$行$n^n$个和的，如何转化？ 首先我们珂以每两行之间逐个合并。然后对于两行$A$和$B$的问题，我们只需要生成这样$n$个序列即珂：第一个：$A[1]+B[1],A[1]+B[2],…A[1]+B[n]$。第二个：$A[2]+B[1],A[2]+B[2],…A[2]+B[n]$。…第$n$个：$A[n]+B[1],A[n]+B[2]…A[n]+B[n]$。然后跑一个$n$路归并即珂。这样做$n-1$次，每次都只求前面$n$个小的，我们就珂以求出$n^n$个和中最小的$n$个了。 实现细节：关于如何维护指针如果您足够强，您完全不用看这个。 我们维护两个值，$s,b$。$s$表示目前的$A[a]+B[b]$，$b$表示在$B$中的下标。我们完全不用知道$A$中的下标，因为$A[a]$是不会改变的。我们有$(s,b)$，下一个指针$(s’,b’)$其实就是$(s-B[b]+B[b+1],b+1)$。 在优先队列中，我们显然是要以$s$为关键字判断优先级的。 —— 刘汝佳的思路 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 822 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int n; int a[N][N]; void Input() &#123; F(i,1,n) F(j,1,n) R1(a[i][j]); F(i,1,n) sort(a[i]+1,a[i]+n+1); &#125; struct node&#123;int s,b;&#125;;bool operator&lt;(node a,node b)&#123;return a.s&gt;b.s;&#125; //用一个struct维护指针，排序条件是以s为关键字的 priority_queue&lt;node&gt; Q; void Merge(int a[N],int b[N],int c[N]) //A和B序列中生成的n^2个和中，排序之后前面n个存在C数组中 //Merge: O(nlogn)/次 &#123; while(!Q.empty()) Q.pop(); //勿忘清空啊 F(i,1,n) Q.push((node)&#123;a[i]+b[1],1&#125;); //队列的初始状态 F(i,1,n) //只求前面n个，i循环到n即珂 &#123; node Min=Q.top();Q.pop(); c[i]=Min.s; Q.push((node)&#123;Min.s-b[Min.b]+b[Min.b+1],Min.b+1&#125;); //求出下一个指针 &#125; &#125; void Soviet() &#123; F(i,2,n) &#123; Merge(a[1],a[i],a[1]); //不断合并，合并的结果都放在a[1]里面 &#125; //总共O(n^2logn) F(i,1,n) printf("%d%c",a[1][i]," \n"[i==n]); &#125; #define Flan void Flan IsMyWife() &#123; while(~scanf("%d",&amp;n) and n) &#123; Input(); Soviet(); &#125; &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3255 Roadblocks 题解]]></title>
    <url>%2F2020%2F02%2F10%2Fpoj-3255-Roadblocks-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给你一个点边都1e5的图，求1到n的次短路。就是除了最短路之外最短的路。边珂以重复经过。 思路框架搞Dijkstra的时候顺便维护次短即珂。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 14444 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[255555]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int n,m; void Input() &#123; G.clear(); F(i,1,m) &#123; int u,v,w;R1(u),R1(v),R1(w); G.Add2(u,v,w); &#125; &#125; struct node&#123;int v,w;&#125;; bool operator&lt;(node a,node b)&#123;return a.w&gt;b.w;&#125; priority_queue&lt;node&gt; Q; int dis[N],dis2[N],vis[N]; void Dijkstra() &#123; while(!Q.empty()) Q.pop(); MEM(dis,0x3f);MEM(dis2,0x3f);FK(vis);dis[1]=0; Q.push((node)&#123;1,0&#125;); while(!Q.empty()) &#123; node Min=Q.top();Q.pop(); int u=Min.v; // if (vis[u]) continue; // vis[u]=1; // 不需要判vis，因为次短路珂能会被多次经过 Tra(i,u) &#123;int v=__v,w=G.Label(i); bool add=0; if (dis[u]+w&lt;dis[v]) dis[v]=dis[u]+w,add=1; if (dis2[u]+w&lt;dis2[v]) dis2[v]=dis2[u]+w,add=1; if (dis[u]+w&gt;dis[v] and dis[u]+w&lt;dis2[v]) dis2[v]=dis[u]+w,add=1; //只有这里被改了 if (add) Q.push((node)&#123;v,dis[v]&#125;); &#125; &#125; &#125; void Soviet() &#123; Dijkstra(); printf("%d\n",dis2[n]); &#125; #define Flan void Flan IsMyWife() &#123; while(~scanf("%d%d",&amp;n,&amp;m) and n+m) &#123; Input(); Soviet(); &#125; &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2051 UVA 1203 LA 3135 Argus 题解]]></title>
    <url>%2F2020%2F02%2F10%2Fpoj-2051-UVA-1203-LA-3135-Argus-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述有一些进程，每个进程有两个属性：id和per。id表示进程编号，per表示每per的时刻就会被调用一遍。如果有多个进程在同一时刻被调用，先调用进程编号小的。求先调用的k个进程。 思路框架优先队列。定义小于号，每次取最小的，然后把它下一次被调用的时间放回优先队列。 具体思路优先队列中，如果a]]></content>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP 历年DP贪心题]]></title>
    <url>%2F2020%2F02%2F10%2FNOIP-%E5%8E%86%E5%B9%B4DP%E8%B4%AA%E5%BF%83%E9%A2%98%2F</url>
    <content type="text"><![CDATA[马上要CSP了，赶快来做点真题。做真题时发现，我要么不会推$DP$，要么贪心贪错。 洛谷1158 NOIP2010 导弹拦截 我太蕉♂急了，看到这题的第一反应：对于每个点，去找最近的系统管。 刷刷写出代码，信心满满的交上去，完美的只有$40$分。去看了一下讨论，讨论区里有一个和我一样只有$40$分的。和我的做法一样。 然后我来讲一下这个算法为什么不对，顺便提醒一下大家，在做$CSP/NOIP$的贪心题时，一定要van♂分小心。 是这样的：有一些点，如果每个就近选，就会用更多的系统，导致答案分散，用大量的花费完成少量的任务。更优的解法是，一个系统虽然花费的更多，但是一次珂以管理更多导弹。 这句话有点难懂，但是看图就明白了。 图中，$A,B$是拦截系统，$C,D$是两个导弹。 然后按照刚刚的“就近原则”，应该是$A$管理$C$，$B$管理$D$。但是这样的花费是$20+37=57$。 实际上，只要$B$管理$D$就足够了。这样的花费是$37$。 这种算法失败的原因，就是因为把原本一个系统就能解决的事情，交给了两个系统。 那么正确的算法又是什么呢。 首先，导弹显然是无序的，根据常年经验和数据我们意识到要排序。 然后我们意识到，我们要把这些导弹分成两个部分，不一定非空，一部分给$A$管，部分给$B$管。 然后我们灵机一动，我们按照到$A$的距离排序，然后一个前缀给$A$，除此之外的部分（一个后缀）给$B$。 然后枚举断点找最小即珂。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) struct node&#123;int x,y;&#125;a[N]; int n; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(a[1].x),R1(a[1].y),R1(a[2].x),R1(a[2].y); R1(n); F(i,3,n+2) R1(a[i].x),R1(a[i].y); &#125; int dis2(node a,node b) &#123; return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y); &#125; bool cmp(node x,node y) &#123; return dis2(x,a[1])&lt;dis2(y,a[1]); &#125; int dis[N]; void Soviet() &#123; sort(a+3,a+n+3,cmp); D(i,n+2,3) &#123; dis[i]=max(dis[i+1],dis2(a[i],a[2])); &#125; int ans=0x7f7f7f7f; F(i,3,n+2) &#123; int r1=dis2(a[i],a[1]); int r2=dis[i+1]; ans=min(ans,r1+r2); &#125; printf("%d\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>DP</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LightningUZ の 做题记录(各种OJ)]]></title>
    <url>%2F2020%2F02%2F10%2FLightningUZ-%E3%81%AE-%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%90%84%E7%A7%8DOJ)(%E4%BB%A5%E5%89%8D%E7%9A%84%E8%80%81%E5%8D%9A%E5%AE%A2)%2F</url>
    <content type="text"><![CDATA[看以下的所有题解之前，务必ReadMe纯属搬运以前的文章。由于数量比较多，我懒得导入过来，就直接到原来链接上凑合看吧。CF699D Link Tag:并查集，树形结构 51nod 1984 Link Tag:整除分块，位运算 洛股♂ 4185 Link Tag:并查集，树形结构洛股♂ 2127 LinkTag:贪心，并查集，乱搞 洛股♂ 3209 Link Tag:并查集，图论 CF820D Link Tag:模拟，思维CF992D LinkTag:模拟，数学 CF1140C Link Tag:贪心，思维 CF955C Link Tag:数论，数学 CF1029D Link Tag:数论，数学bzoj 4659 LinkTag:数论，数学，莫比乌斯反演 洛股♂ 5199 Link Tag:排序，贪心，思维 洛股♂ 3800 Link Tag:单调队列优化，DP 洛股♂ 1169 Link Tag:DP（偷偷备注一句是悬线DP） bzoj 1127 Link Tag:悬线DP 洛股♂ 3512 Link Tag:单调队列 bzoj 1233 Link Tag:单调队列，DP CF185A Link Tag:数论，数学 bzoj 3231 Link Tag:矩阵乘法，数学 HDU 3530 Link Tag:单调队列 洛谷 2564 Link Tag:队列,瞎搞 洛谷 2216 Link Tag:单调队列HDU 2196 LinkTag:树形DP（很难+经典的树形DP） bzoj 3747 Link Tag:线段树 CF401C Link Tag:构造 洛谷 1196 Link Tag:并查集，思维 洛谷 5122 Link Tag:图论，建图 洛谷 3140 Link Tag:DP HDU 5663 Link Tag:莫比乌斯反演 CF 508E Link Tag:构造，贪心 洛谷 4083 题解 Link Tag:思维，阅读理解，BFS POJ 1141 题解 Link Tag:区间DP POJ 3017 题解 Link Tag:单调队列,DP 洛谷 2698 题解 Link Tag:单调队列 洛谷 1829 题解 Link Tag:莫比乌斯反演 洛谷 3069 题解 Link Tag:单调队列（尺取） 洛谷 4139 题解 Link Tag:欧拉定理 CF 75C 题解 Link Tag:数论，数学，二分答案 洛谷 2339 题解 Link Tag:区间DP 洛谷 2887 题解 Link Tag:贪心 bzoj 2467 题解 Link Tag:生成树，组合数学 CF 813D 题解 Link Tag:DP HDU 6370 题解 Link Tag:并查集，图论，DFS HDU 1496 题解 Link Tag:数论，map AtCoder AGC006D（LgAT2165） 题解 Link Tag:AtCoder风格，二分答案 HDU 4578 题解 Link Tag:线段树 洛谷 2220 题解 Link Tag：组合数学,离散化 洛谷 3216 题解 Link Tag:矩阵快速幂 HDU 5493 题解 Link Tag:线段树bzoj 4034 题解 LinkTag:DFS序，线段树 poj 3237 题解 Link Tag:线段树，树链剖分 CF 1012B 题解 Link Tag:思维，建图，并查集 bzoj 1026 题解 Link Tag:数位DP 洛谷 2155 题解 Link Tag: 数论 bzoj 3329 题解 Link Tag:数位DP，矩阵快速幂 HDU 5242 题解 Link Tag:贪心，树链剖分思想 CF 570E 题解 Link Tag: DP CF 979D 题解 Link Tag:STL，乱搞 HDU 4507 题解 Link Tag:数位DP（超难） HDU 4334 题解 Link Tag:记忆化，单调性，思维 CF 1043F 题解Link Tag：容斥 hdu 2842 题解 Link Tag：矩阵快速幂 CF 455C 题解 Link Tag：直径，并查集 HDU 3461 题解 Link Tag：思维，并查集 bzoj 4318 题解 Link Tag：期望 CF 280C 题解 Link Tag:期望 POJ 1083 题解 Link Tag:思维 hdu 4035 题解 Link Tag:期望，树形DP hdu 6170 题解 Link Tag：字符串DP bzoj 2243 题解 Link Tag：线段树，树链剖分 hdu 5692 题解 Link Tag:DFS序 hdu 3234 题解 Link Tag:并查集，思维 洛谷 4113 题解Link Tag:树状数组，瞎搞（树状数组水主席树！！！） bzoj 4883 题解 Link Tag；思维，建图，最小基环森林 hdu 5029 题解 Link Tag：树链剖分，线段树，思维 洛谷 3119 题解Link Tag：强连通分量，思维 洛谷 1407 题解 Link Tag:强连通分量，建图，思维 poj 3926 题解 Link Tag：单调队列优化DP AtCoder 2159 题解 Link Tag:STL，思维，并查集 洛谷 3223 &amp; bzoj 2729 题解Link Tag：组合数学，高精 洛谷 2144 &amp; bzoj1002 题解Link Tag：找规律 SPOJ GSS3 题解Link Tag：线段树 hdu 2795 题解 Link Tag：线段树 SPOJ LCMSum &amp; bzoj 2226 &amp; 洛谷 1891 题解 Link Tag：数论，推式子 LibreOJ 515 题解Link Tag：bitset,DP poj 2109 题解Link Tag：瞎搞 洛谷 1197 &amp; bzoj 1015 题解Link Tag：并查集，思维 bzoj 3997 &amp; 洛谷 3974 题解 Link Tag：建图，图论，DP hdu 4602 题解 Link Tag：组合数学，推式子 hdu 4000 题解 Link Tag：树状数组 洛谷 4462 &amp; bzoj 5301 题解 Link Tag：莫队 洛谷 2272 &amp; bzoj 1093 题解 Link Tag：强连通分量，思维 洛谷 5094 &amp; poj 1990 题解 Link Tag：树状数组 hdu 6411 题解Link Tag：思维，好题，并查集 洛谷 2320 &amp; bzoj 1192 题解Link Tag：思维，构造 poj 3735 题解 Link Tag：思维，构造 poj 2478 题解Link Tag：欧拉函数 poj 1936 题解 Link Tag：字符串 poj 1989 &amp; hdu 2712 &amp; 洛谷5093 题解 Link Tag：贪心，思维，好题 洛谷 1268 题解 Link Tag：图论，思维 洛谷 2879 &amp; poj 3263 题解 Link Tag：思维，前缀和 洛谷 4588 &amp; bzoj 5334 题解 Link Tag：线段树，打死你也想不到是用线段树 poj 1149 题解 Link Tag：网络流，建图 CF 140C 题解 Link Tag：思维，贪心 洛谷 2509 题解 Link Tag：倍增，单调队列，思维，好题 洛谷 2774 题解 Link Tag：最小割建图]]></content>
      <tags>
        <tag>各种OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 5762 Teacher Bo 题解]]></title>
    <url>%2F2020%2F02%2F10%2Fhdu-5762-Teacher-Bo-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述有n个点，点的坐标都在[0,m]之间。问你是否存在两对点(a,b)和(c,d)，使得a到b的曼哈顿距离和c到d的曼哈顿距离相等。输出Yes和No。n,m&lt;=1e5。 曼哈顿距离：x坐标差的绝对值+y坐标差的绝对值 思路框架$O(n^2logn)$暴力。开一个map维护哪些曼哈顿距离出现过。对于新的一对$(i,j)$，$d$为点$i,j$之间的曼哈顿距离。如果$d$已经出现过，说明有两对点曼哈顿距离都是$d$，直接输出Yes。 没找到输出No。 等等…n不是1e5么？$n^2logn$的暴力怎么能过呢？ 真的是n2logn吗？我们知道抽屉原理：如果有n个抽屉，但是一共有多于n个球。那么肯定有一个抽屉里面放了两个球以上。反之，如果我们有多于n个求，放进n个抽屉，肯定会有一个抽屉里面重复了。 注意到点的坐标是[0,m]，也是1e5以内。在正常的题目里面，这个没什么用，但是这是这个题保证复杂度的关键。因为这个条件说明了不同的曼哈顿距离只可能在[1,2m]之间。（我们不考虑两个点在一块，所以取不到0）。我们要找两个相同的曼哈顿距离，所以我们最多找2m+1对点，就能找到答案。 当然，如果我们找不到答案，也会在2m+1步之内停止（即$n^2&lt;2m+1$）。因为我们只要多于$2m+1$个，就肯定有解。 所以，你以为我是$n^2$，其实我是$O(mlogn)$哒！！！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) //一次读多个数，感谢@dev.sukazyo.cc的贡献 &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int n,m; int x[N],y[N]; void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,1,n) R1(x[i]),R1(y[i]); &#125; map&lt;int,int&gt; cnt; //开map维护 int Manhattan(int a,int b)&#123;return abs(x[a]-x[b])+abs(y[a]-y[b]);&#125; //计算曼哈顿距离 void Soviet() &#123; cnt.clear(); F(i,1,n) F(j,i+1,n) &#123; int dis=Manhattan(i,j); if (cnt[dis]) &#123;return (void)puts("YES");&#125; cnt[dis]++; &#125; puts("NO"); &#125; #define Flan void Flan IsMyWife() &#123; int t;R1(t); F(i,1,t) &#123; Input(); Soviet(); &#125; &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 4763 Theme Section 题解]]></title>
    <url>%2F2020%2F02%2F10%2Fhdu-4763-Theme-Section-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述请你在一个字符串$S$中找到最大的$k$，使得存在长度为$k$的前缀，后缀和子串，三者没有一点交集，且字符串值相等。算法必须线性（数据水，网上会被卡成n^2的算法也过了）（这是全网为数不多几个严格线性的题解） 思路框架建一颗$fail$树。然后用树上操作解决问题。 具体思路我们用$KMP$中的$fail$数组建一颗树，从$i$到$fail_i$连一条边。不难发现，$0$就是根节点。 然后，我们先解决问题的几个部分解决。 前缀=后缀前缀等于后缀并且位置不相等（即：长度不是n）。那满足条件的长度一定在$n$号节点（不含）到根节点（含）的路径上。我们知道，$S$中满足前缀=后缀的长度就是fail[n]，fail[fail[n]]…0。也就是从$n$到根的路径了。 前缀=某个子串然后我们要找到一个子串和它们相等。（$S$的）子串，就是（某个）前缀的（某个）后缀。而（某个）前缀的（某个）前缀还是（$S$的）前缀。 所以，如果$S$的一个以$i$结尾的子串和$S$的某个前缀相等，这个长度一定在$i$到根的路径上。 合并那么我们发现三者相等。所以，这个要求的长度，即在$i$到根的路径上，也在$n$到根的路径上。那么它就在$i$和$n$的$LCA$到根的路径上。 稍微一想，长度最长，就是$LCA$最深。我们要求$LCA$最深，有这样一个方法：给每个点一个点权，初始为$0$。然后从$n$到$1$的路径上都加上$1$。对于每个$i$，我们询问$i$到根路径上点权的和，就是$i$和$n$的$LCA$的深度。然后我们只需要维护一个树上前缀和，然后找到前缀和最大的位置即珂。 别忘了三者不能有相交那咋整嘛。首先，前缀，后缀还有子串不能相交，那么长度就小于等于n的三分之一。由于我们我们在用上面的方法给点权+1的时候，判一下这个点的编号是否小于n的三分之一，如果满足，那才+1。 然后我们找到$LCA$之后，不断判断$LCA$的长度是否小于$n$的三分之一，如果小于就跳$fail$。当然，我们在找$LCA$的时候，由于只有一组数据，我们也是一样的找法。用代码写，就是：1while(LCA上点权为0) 跳fail; 然后$LCA$就是我们要求的最长长度了。记得要判一下无解。 时间复杂度我们发现，我们刚刚说到了这样几个操作： 求字符串的fail 树上一条链加值 树上求前缀和 这些都是$O(n)$完成的操作。所以我们的算法是严格$O(n)$的，连$log$都不带。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1666666 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) char s[N];int n; void Input() &#123; scanf("%s",s+1);n=strlen(s+1); &#125; int fail[N]; void GetFail() &#123; fail[1]=0; F(i,2,n) &#123; int j=fail[i-1]; while(s[j+1]!=s[i] and j) j=fail[j]; if (s[j+1]==s[i]) ++j; fail[i]=j; &#125; &#125; int val[N],rsum[N];//点权，点权的前缀和 void Soviet() &#123; F(i,0,n+5) fail[i]=val[i]=rsum[i]=0; GetFail();//fail[i]是树上i节点的父亲 int pos=n; while(pos) &#123;&#123;if (pos*3&lt;=n) val[pos]=1;&#125;pos=fail[pos];&#125; //求出点权 F(i,1,n) rsum[i]=rsum[fail[i]]+val[i];//维护前缀和 int Max=0; F(i,2,n-1)//注意是2到n-1。当然你也珂以认为是n*1/3到n*2/3 &#123; if (!val[i]) if (rsum[i]&gt;rsum[Max]) Max=i; //求出最深的LCA &#125; if (rsum[Max]==0) &#123;puts("0");return;&#125;//判无解 int LCA=Max; while(!val[LCA]) LCA=fail[LCA];//这里会死循环吗？ printf("%d\n",LCA); &#125; #define Flan void Flan IsMyWife() &#123; int t;cin&gt;&gt;t; while(t--) &#123; Input(); Soviet(); &#125; &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125; 代码中的问题答案：不会，因为显然val[0]=1.]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>思维</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFT+NTT模板 笔记]]></title>
    <url>%2F2020%2F02%2F10%2FFFT-NTT%E6%A8%A1%E6%9D%BF-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[由于作者水平就只能到模板，所以笔记也就写到这里。 FFT简介FFT是干啥的？它是用来加速多项式乘法的。我们平时经常求多项式乘法，比如$(x+1)(x+3)=(x^2+4x+3)$。假设两个式子都是$n$项（不足的补0），那朴素的算法是$O(n^2)$的。那么，我们能做到$O(nlogn)$做么？你也许觉得不珂能。的确，不看题解，是很难自己想到正解的（除非你是欧拉费马级别的天才） 前置知识多项式点值表示我们平常表达多项式，都是用系数表达的。当然，还有点值表达。用平面直角坐标系上的$n$个点，唯一确定一个（不超过）$n-1$次的多项式。它的一个特殊形式，就是两点确定一条直线。点值转系数表达，你只需要解一个方程组就珂以了。（高斯消元，这样是$O(n^3)$的） 复数复数的定义这个很多人知道。定义$i=\sqrt{-1}$，即虚数单位。形如$a+bi$的数就是复数（complex）。复数$a+bi$的辐角：从$(0,0)$到$(a,b)$的线段和$x$轴的夹角。这个夹角，是顺时针方向的夹角。取值范围是$[0,360]$。 复数的几何意义在一维数轴上，我们把一个数乘以$-1$，相当于旋转了$180$。那么，我们把一个数乘以$\sqrt{-1}$，相当于：乘两次是旋转$180$。所以，乘一次就是旋转$90$，也就是竖起来了。“竖起来”，这个概念很好表示，就是$y$坐标。那么，$a+bi$就相当于平面直角坐标系上的点$(a,b)$。当然，你也珂以把它看成一个向量，从$(0,0)$到$(a,b)$。 复数的运算复数的加法：$(a_1+b_1i)+(a_2+b_2i)=(a_1+a_2)+(b_1+b_2)i$。（这样也就包含了减法的情况）复数的乘法：$(a_1+b_1i)\times (a_2+b_2i)$我们把括号拆开，然后把$i^2$都变成$-1$（由$i$的定义）。易得，它等于：$(a_1a_2-b_1b_2)+(a_1b_2+a_2b_1)i$ （n次）单位复根满足$x^n=1$的所有复数解中，辐角最小且不为$0$的那个复数。记作$w_n$。不难发现，所有满足条件的$x$，用向量表示后，把单位圆$n$等分。举个栗子，$n=6$的时候，解的分布是这样的：其中，$\omega n$就是图中标出来的，辐角大于0且最小的那个向量。 单位复根的性质 $w_{2n}^{2k}=w_{n}^{k}$（珂以把$w_n^k$看成是$360\deg\times \dfrac{k}{n}$，这条证毕） $w_n^{k+n/2}=-w_n^k$。（这里$n/2$不取整，就是小数） （把$n/2$看成是转半圈，转半圈也就是$x,y$坐标都变负，这条也证毕） 正式开始！上面不是说了点值表示么。对于两个用点值表示的多项式，只要把对应的点值乘起来即珂。但是，我们要取$n$个点（DFT），每次$O(n)$求值，不是要$O(n^2)$了么？而且，把点值转换成系数（插值，IDFT）的过程，不是要$O(n^3)$么？因此，我们的主干思想是：利用单位复根的性质，巧妙的求值/插值，使得我们在$O(nlogn)$的时间内完成这些操作。简图（远航之曲大佬的图）： DFT就是快速带入点值的过程。我们的多项式：$A(x)=a_0x^0+a_1x^1+a_2x^2…+a_{n-1}x^{n-1}$。其中$a_0,a_1…a_n$是系数（题目给定）。接下来，我们设$n=2^k$。不足的地方用$0$补齐。把它的系数按下表奇偶分组（指数还是顺序下来的）：$A_0(x)=a_0x^0+a_2x^1+a_4x^2…+a_{n-2}x^{n/2-1}$$A_1(x)=a_1x^0+a_3x^1+a_5x^2…+a_{n-1}x^{n/2-1}$易得$A(x)=A_0(x^2)+xA_1(x^2)$。那么，我们代入$x=w_n^0,w_n,w_n^2…w_{n}^{n-1}$。考虑求前面$n/2$个，然后直接得到后面$n/2$个。令$k\in [0,n/2)$，则：$A(w_n^k)=A_0(w_n^{2k})+w_n^kA_1(w_n^{2k})$然后我们再代入$w_n^{k+n/2}=-w_n^k$：$A(w_n^{k+n/2})=A_0(w_n^2k)-A_1(w_n^2k)$我们发现，$w_n^{k+n/2}=-w_n^k$。然而$A_0,A_1$里面是$x^2$，所以取负不影响$A_0$和$A_1$的结果，只有$A_1$前面那一项有一个正负号的区别！所以，我们求出前一半，就珂以$O(n)$求出后一半。这样显然是$O(nlogn)$的。 DFT的实现优化刚刚做完$O(nlogn)$的式子。但是，实现的时候，递归似乎太慢了，还不如暴力来的快。我们观察一下，被奇偶分组后的下标。（草 图）转换一下二进制：000 001 010 011 100 101 110 111变成：000 100 010 110 001 101 011 111相当于每个二进制数位反过来了。然后我们通过递推，推出最后的状态。然后不断合并，合并成答案。成功的把递归转化掉了。这样还是$O(nlogn)$，但是快了很多！ IDFTIDFT，就是我们已知一个点值表示的多项式，而且代入的点值还是$w_n^0,w_n^1…w_n^{n-1}$。 我们设出系数$a_0,a_1..a_{n-1}$，列出方程： \begin{cases} a_0(w_n^0)^0+a_1(w_n^0)^1...+a_{n-1}(w_n^0)^{n-1}=A(w_n^0)\\ a_0(w_n^1)^0+a_1(w_n^1)^1...+a_{n-1}(w_n^1)^{n-1}=A(w_n^1)\\ ...\\ a_0(w_n^{n-1})^0+a_1(w_n^{n-1})^1...+a_{n-1}(w_n^{n-1})^{n-1}=A(w_n^{n-1})\\ \end{cases}用矩阵表达： \begin{bmatrix} (w_n^0)^0 & (w_n^0)^1 & ... & (w_n^0)^{n-1}\\ (w_n^1)^0 & (w_n^1)^1 & ... & (w_n^1)^{n-1}\\ ...\\ (w_n^{n-1})^0 & (w_n^{n-1})^1 & ... & (w_n^{n-1})^{n-1} \end{bmatrix} \times \begin{bmatrix} a_0\\ a_1\\ .\\ .\\ .\\ a_{n-1} \end{bmatrix}= \begin{bmatrix} A(w_n^0)\\ A(w_n^1)\\ .\\ .\\ .\\ A(w_n^{n-1}) \end{bmatrix}设这个式子是“珂朵莉IDFT①式”然后设矩阵$D$，$D$中的每一项和左边那个矩阵 V=\begin{bmatrix} (w_n^0)^0 & (w_n^0)^1 & ... & (w_n^0)^{n-1}\\ (w_n^1)^0 & (w_n^1)^1 & ... & (w_n^1)^{n-1}\\ ...\\ (w_n^{n-1})^0 & (w_n^{n-1})^1 & ... & (w_n^{n-1})^{n-1} \end{bmatrix}中对应位置上的项，都是倒数。已证，$D\times V=n\times I_n$，其中$I_n$是$n$阶单位矩阵。那也就是，$D=\dfrac{1}{n}V^{-1}$把“珂朵莉IDFT①式”中，左右两边同时乘一个$D=\dfrac{1}{n}V^{-1}$。易得： \begin{bmatrix} a_0\\ a_1\\ .\\ .\\ .\\ a_{n-1} \end{bmatrix}= \dfrac{1}{n}D \begin{bmatrix} A(w_n^0)\\ A(w_n^1)\\ .\\ .\\ .\\ A(w_n^{n-1}) \end{bmatrix}那么我们把矩阵$V$中，所有项取倒数，然后做一遍$DFT$即珂。最后记得除一个$n$。 模板题的代码洛谷 3803123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 3000006 //空间的理论下限 //2097153=2^21+1 #define real double #define Pi (3.14159265358979323846264338) #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; struct cp&#123;real R,I;&#125;; //复数类 //R: 实部，a+bi中的a //I：虚部，a+bi中的b cp operator+(cp a,cp b)&#123;return (cp)&#123;a.R+b.R,a.I+b.I&#125;;&#125; cp operator-(cp a,cp b)&#123;return (cp)&#123;a.R-b.R,a.I-b.I&#125;;&#125; cp operator*(cp a,cp b)&#123;return (cp)&#123;a.R*b.R-a.I*b.I,a.R*b.I+a.I*b.R&#125;;&#125; int n,m; cp a[N],b[N]; void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,0,n) &#123;int x;R1(x);a[i].R=x;&#125; F(i,0,m) &#123;int x;R1(x);b[i].R=x;&#125; &#125; int r[N],lim; void FFT(cp A[],int type) //type=1: DFT //type=-1: IDFT &#123; F(i,0,lim) if (i&lt;r[i]) swap(A[i],A[r[i]]); for(int mid=1;mid&lt;lim;mid&lt;&lt;=1) //合并区间的长度 //每次合并两个长度为mid的区间 &#123; cp Wn=(cp)&#123;cos(Pi/mid),type*sin(Pi/mid)&#125;; //把虚部乘以-1，相当于变成一个实数，其值为向量长度 //由于向量在单位圆上，长度为1，就相当于取倒数了 for(int j=0;j&lt;lim;j+=(mid&lt;&lt;1)) &#123; cp w=(cp)&#123;1,0&#125;; //Wn^0 for(int k=0;k&lt;mid;++k,w=w*Wn) //w:不断代入Wn^k &#123; cp X=A[j+k],Y=w*A[j+mid+k]; //DFT的合并式子 A[j+k]=X+Y; A[j+mid+k]=X-Y; &#125; &#125; &#125; &#125; void Soviet() &#123; int l=0;lim=1; while(lim&lt;=n+m) lim&lt;&lt;=1,++l; F(i,0,lim) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); FFT(a,1);FFT(b,1); //两个DFT F(i,0,lim) a[i]=a[i]*b[i]; //点值乘法 FFT(a,-1); //IDFT F(i,0,n+m) printf("%d ",(int)(a[i].R/lim+0.5)); //还要乘一个1/lim //+0.5是取四舍五入 putchar('\n'); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125; NTTNTT本质上就是把$FFT$中的单位复根换成一个有相同性质的整数：原根。只要记住$998244353$的原根是$3$即珂。然后和$FFT$同样的方法去写就珂以了，也是DFT+IDFT。就是把里面单位复根换成原根，一样写即可。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 2666666 #define mod 998244353 #define Gi 332748118 //3^(-1) mod 998244353 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int n,m; int a[N],b[N]; void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,0,n) R1(a[i]); F(i,0,m) R1(b[i]); &#125; int qpow_p(int a,int b,int m) //正数的快速幂 &#123; int r=1; while(b) &#123; if (b&amp;1) r=r*a%m; a=a*a%m,b&gt;&gt;=1; &#125; return r; &#125; int qpow(int a,int b,int m) //支持负指数的快速幂（就是先求快速幂，然后求一个逆元） &#123; if (b==0) return 1; else if (b&lt;0) return qpow_p(qpow_p(a,-b,m),m-2,m); else return qpow_p(a,b,m); &#125; int r[N],lim; void NTT(int A[N],int type) &#123; F(i,0,lim) if (i&lt;r[i]) swap(A[i],A[r[i]]); for(int mid=1;mid&lt;lim;mid&lt;&lt;=1) &#123; int Wn=qpow(qpow(3,type,mod),(mod-1)/(mid&lt;&lt;1),mod); for(int j=0;j&lt;lim;j+=(mid&lt;&lt;1)) &#123; int w=1; for(int k=0;k&lt;mid;k++,w=(w*Wn)%mod) &#123; int X=A[j+k],Y=w*A[j+mid+k]%mod; A[j+k]=(X+Y)%mod; A[j+mid+k]=(X-Y+mod)%mod; &#125; &#125; &#125; &#125; void Soviet() &#123; lim=1ll;int l=0; while(lim&lt;=n+m) lim&lt;&lt;=1ll,++l; F(i,0,lim) r[i]=(r[i&gt;&gt;1ll]&gt;&gt;1ll)|((i&amp;1ll)&lt;&lt;(l-1)); NTT(a,1);NTT(b,1); F(i,0,lim) a[i]=(a[i]*b[i])%mod; NTT(a,-1); int iv=qpow(lim,-1,mod); F(i,0,n+m) printf("%lld ",a[i]*iv%mod); //*iv相当于除以一个lim putchar('\n'); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125; NTT的好处和坏处好处： 和FFT相比，把浮点数换成整数。常数很小，而且避免了精度问题坏处： 小心溢出！（超过NTT模数也是一种溢出，会导致答案不同）（如果让你对某个数取模那另说）]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>多项式</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP-J2019 AK记]]></title>
    <url>%2F2020%2F02%2F10%2FCSP-J2019-AK%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言我叫zps，准考证号JS-00810，来自苏州。今年我AK了CSP-J。总体感觉还是很水的，但是似乎没什么人AK。我表示不理解。总之，写个博客好了。 T1 数字游戏(number)题面给定一个保证长度为$8$的01字符串，求这个字符串中有多少1。 题解这还要解？签到题好吧…只要会打文件就能过。 时间复杂度$O(8)$。你要认为是$O(1)$也珂以。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 100 #define MEM(x,a) memset(x,a,sizeof(x)) #define CL(x) MEM(x,0) #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) char s[N];int n; void Input() &#123; scanf("%s",s+1);n=strlen(s+1); &#125; void Solve() &#123; int ans=0; F(i,1,n) if (s[i]=='1') ans++; printf("%d\n",ans); &#125; void Main() &#123; bool OPEN_FILE=0; //考场上要改为1，需要开文件 if (OPEN_FILE) &#123; #define filename "number" freopen(filename ".in","r",stdin); freopen(filename ".out","w",stdout); &#125; Input(); Solve(); &#125;&#125;int main()&#123; Flandre_Scarlet::Main(); return 0;&#125; T2 公交换乘(transfer)题面你近期有$n&lt;=1e5$个乘坐公共交通的记录，有些是地铁，有些是公交。每次都有三个值：$p,t,k$。$k=0$表示地铁，$=1$表示公交。$p$表示价格。$t$表示时刻。每坐一次地铁都会在上车时得到一个坐公交车的优惠券。如果两个时刻$t_{bus},t_{subway}$之间满足$t_{bus}-t_{subway}&lt;=45$且$t_{bus}&gt;t_{subway}$，则可以使用一张优惠券，免费乘坐公交。 合理分配优惠券使得总花费最小。保证时间$t$严格递增是顺序给出的。 题解由于时间是严格递增的，时间差要$&lt;=45$，所以每次至少会$+1$。所以，对于每个公交车，最多有$45$个优惠券满足条件。显然，在所有能用的优惠券中，肯定要选择最早的，因为晚一些的优惠券就能用更久，给后面的公交车用。 用一个$vector$存储每趟公交车能用的优惠券编号。对于已经用过的优惠券编号，我们用一个$vis$数字标记已经用过。每次暴力找$vis=0$且最小的。 时间复杂度$O(45n)$。你也珂以认为是$O(n)$。虽然这常数带的比log还大。 吐槽我的一个同学，考场上坐在我左边两个机位，他用了二分图+Dinic…怎么会有这种人… 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define MEM(x,a) memset(x,a,sizeof(x)) #define CL(x) MEM(x,0) #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) int n; int tp[N],price[N],tim[N]; int Rd(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1?x:-x)); &#125; void Input() &#123; Rd(n); F(i,1,n) &#123; Rd(tp[i]);Rd(price[i]);Rd(tim[i]); &#125; &#125; vector&lt;int&gt; use[N]; //第i趟公交车能用的优惠券编号 bool vis[N]; //判断是否使用过 void Solve() &#123; F(i,1,n) use[i].clear(); CL(vis); int cost=0; F(i,1,n) &#123; if (tp[i]==0) //如果是地铁，就记录花费并更新优惠券 &#123; cost+=price[i]; //地铁没有优惠券呢~ F(j,i+1,n) &#123; if (tim[j]-tim[i]&gt;45) break; //这一步保证复杂度 if (tp[j]==1) use[j].push_back(i); //要判断是地铁才能用优惠券 &#125; &#125; else &#123; bool cxk=0; //记录有没有能用的 F(j,0,(int)use[i].size()-1)//use[i].size()&lt;=45 //由于我们是顺序枚举的i，所以我们的use数组中的每个vector都是有序的 &#123;int u=use[i][j]; if (!vis[u] and price[u]&gt;=price[i]) //第一个满足条件的一定是t最小的 &#123; vis[u]=1;cxk=1;break; &#125; &#125; if (!cxk) cost+=price[i]; // 如果不能用的，没有办法，只能花点小钱了 &#125; &#125; printf("%d\n",cost); &#125; void Main() &#123; bool OPEN_FILE=0; //同上，考场上改为1 if (OPEN_FILE) &#123; #define filename "transfer" freopen(filename ".in","r",stdin); freopen(filename ".out","w",stdout); &#125; Input(); Solve(); &#125;&#125;int main()&#123; Flandre_Scarlet::Main(); return 0;&#125; T3 纪念品(souvenir)单词释义(英) [ˌsuːvəˈnɪə(r)](美) [ˌsuːvəˈnɪr] （我才不会告诉你我考场上不认得这个词呢） 题面有$T$天，$n$个纪念品，一开始你有$m$个金币。接下来一个$T\times n$的矩阵$P$，$p[i][j]$表示第$i$天第$j$个纪念品的价格。 每天有两种操作，买或卖任意一个纪念品，操作次数珂以无限次。当日买的纪念品，当日就珂以卖。当日卖得的钱，当日就珂以买其它纪念品。请你求出，到最后，连本带利最多能有多少钱。 $T,n&lt;=100$,$m&lt;=1000$。任意时刻，手头的金币的数量不会超过$1e4$。 题解对于第$i$天，我们只考虑和$i+1$天做交易的情况即珂。因为$(a-b)+(b-c)=a-c$，所以$i$和$i+k$天之间做生意的情况就珂以拆分为$(i,i+1)+(i+1,i+2)…+(i+k-1,i+k)$。这步很关键（但是你们为啥想不到nya） 然后我们第$i$天和第$i+1$天珂以这样求解：对于每个物品$j$，用$p[i+1][j]-p[i][j]$作价值，$p[i][j]$为重量，$M$为背包容积。跑一个完全背包之后，设答案为$ans$，则$ans$就是最大的净赚。所以$m+=ans$就是最后手头上的钱数。做$T-1$遍这样的背包即珂。 有一个小问题：不是说当天赚的前当天就珂以用吗？ 答：但是我们考虑的是这一天和下一天。第$i$天考虑的交易会在第$i+1$天的时候当天买来当天用。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 122 #define V 14444 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int t,n,m; int p[N][N]; void Input() &#123; R1(t),R1(n),R1(m); F(i,1,t) F(j,1,n) R1(p[i][j]); &#125; int w[N],v[N]; int dp[V]; void Soviet() &#123; F(i,1,t-1) &#123; F(j,1,n) w[j]=p[i][j],v[j]=p[i+1][j]-p[i][j]; FK(dp); F(j,1,n) F(k,w[j],m) dp[k]=max(dp[k],dp[k-w[j]]+v[j]);//做一个DP m+=*max_element(dp+1,dp+m+1);//dp中的最大值就是答案，m+=答案 //max_element: 返回区间最大值第一次出现的指针 &#125; printf("%d\n",m); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125; 放松一下歌曲： Hop 极乐净土 Säkkijärven Polkka 番剧&amp;漫画： 新闻联播 海峡两岸 游戏： OSU! 东方红魔乡~ 前方高能！ T4 加工零件(work)给定一个无向图表示一个工厂里面的流水线的传递网络。第$u$个点要生产一个$L$阶段的零件，就需要$u$连接的所有工厂都生产一个$L-1$阶段的零件。第$0$阶段的零件即原材料。$q$个询问，请你求出$u$号工厂生产$L$阶段的零件是否需要$1$工厂提供原材料。 $n,q&lt;=1e5,1&lt;=u&lt;=n,L&lt;=1e9$。 题解考场代码有点小问题，但是数据水，问题不大~ 提供的代码是各种$OJ$上都能拿满的代码，和前三题不一样，不是考场代码。 转化为：$u$走$L$步能否到$1$，一条边珂以经过无数次。 特判不连通，直接输出No。 然后，由于一条边珂以经过无数次，如果走$k$能到，我们把其中一条边走两遍，$k+2$步也能到。 所以我们从$1$开始维护奇数/偶数长度的最短路即珂。看着转移，很简单的。 同学问：vis怎么开？ 我：不用开…我们只有在能更新最短路的时候入队列，不能更新的时候就不用入队列了，这样显然是不会重复的，因为边权都是$1$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 455555 #define MEM(x,a) memset(x,a,sizeof(x)) #define CL(x) MEM(x,0) #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define p_b push_back int Rd(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return (x=(f==1?x:-x)); &#125; vector&lt;int&gt; G[N]; int n,m,q; void Input() &#123; Rd(n),Rd(m),Rd(q); F(i,1,m) &#123; int u,v;Rd(u),Rd(v); G[u].p_b(v);G[v].p_b(u); &#125; &#125; namespace lilunAC //理论AC，实际上也AC了呢... //考场上害怕，就只写了理论AC &#123; int dis[N][2];int Q[N];//dis[*][0/1]：偶数/奇数长度的最短路 void BFS() &#123; int head=1,tail=1;Q[tail]=1; MEM(dis,0x3f);dis[1][0]=0; while(head&lt;=tail) &#123; int u=Q[head];++head; F(i,0,(int)G[u].size()-1) &#123;int v=G[u][i]; bool add=0; if (dis[u][1]+1&lt;dis[v][0]) &#123; dis[v][0]=dis[u][1]+1; add=1; &#125; if (dis[u][0]+1&lt;dis[v][1]) &#123; dis[v][1]=dis[u][0]+1; add=1; &#125; if (add) Q[++tail]=v; &#125; &#125; &#125; void Solve() &#123; BFS(); F(i,1,q) &#123; int u,l;Rd(u),Rd(l); if (l&gt;=dis[u][l%2]) &#123; puts("Yes"); &#125; else puts("No"); &#125; &#125; &#125; void Solve() &#123; if (G[1].size()==0) F(i,1,q) puts("No"); //特判不连通 else lilunAC::Solve(); &#125; void Main() &#123; bool OPEN_FILE=0; if (OPEN_FILE) &#123; #define filename "work" freopen(filename ".in","r",stdin); freopen(filename ".out","w",stdout); &#125; Input(); Solve(); &#125;&#125;int main()&#123; Flandre_Scarlet::Main(); return 0;&#125;]]></content>
      <tags>
        <tag>水题</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 988C Equal Sums 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-988C-Equal-Sums-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述若干的序列，长度和不超过$2e5$。请你选择两个序列，从两个序列中恰好各删除一个数，使得两个序列的和相等。如果珂以，输出”Yes”，并输出是从哪两个序列中删除了编号为多少的元素。多解输出任意一个。无解输出”No”。 思路框架STL的map维护 具体思路对于每个序列，对于不同的元素，每个都把（序列的和-这个元素值）加入到map中，标记为出现过。如果在标记之前就出现过，由于我们在一个序列里是去重的，所以一定是前面某个序列里的。那就是出现解了。我们把（序列的和-这个元素值）保存下来，直接退出。设其为$k$。 然后，还是在去重过的序列里，看看哪几个元素满足（序列的和-这个元素值）=$k$，输出它所在的序列编号和它在序列中的编号即珂。细节还蛮多的，注意一下。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 255555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define p_b push_back void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int k; vector&lt;int&gt; a[N];int sum[N]; void Input() &#123; R1(k); F(i,1,k) &#123; int l;R1(l); int S=0; F(j,1,l) &#123;int x;R1(x);S+=x;a[i].push_back(x);&#125; sum[i]=S; &#125; &#125; map&lt;int,bool&gt; vis; //判断是否出现过 map&lt;int,bool&gt; vis2; //同一个序列中去重 void Soviet() &#123; int kk=-1; bool flag=0; F(i,1,k) &#123; vis2.clear(); //和vis不一样，vis2要清空一下 F(j,0,(int)a[i].size()-1) &#123; int x=a[i][j]; if (vis2[x]) continue; //去重 vis2[x]=1; if (vis[sum[i]-x]==1) &#123; puts("YES"); kk=sum[i]-x;//记录下kk flag=1;break;//flag便于多层的退出 &#125; else vis[sum[i]-x]=1; &#125; if (flag) break; &#125; if (!flag) &#123;puts("NO");return;&#125; int cnt=0; F(i,1,k) &#123; F(j,0,(int)a[i].size()-1) &#123; int x=a[i][j]; if (sum[i]-x==kk) &#123; printf("%d %d\n",i,j+1); cnt++;//我们要输出恰好两个，但是也许不止两个，所以要判一下cnt break; &#125; &#125; if (cnt==2) break; &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 873D Merge Sort 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-873D-Merge-Sort-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定$n,k$，求一个长度为$n$的数列，使得对它进行归并排序要调用$k$次$MergeSort$函数。 注：$MergeSort$：对$l,mid$和$mid,r$进行分治操作，如果有序，直接返回（不过也是要算一次调用）。否则就合并一下再返回。 思路（水题，一句解决）初始化为$1,2,3…n$，写一个归并出来，如果要多一次操作，只要把左右两半的第一个位置换一下即珂，然后左右分别操作求解。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n,k; void Input() &#123; cin&gt;&gt;n&gt;&gt;k; &#125; int a[N]; void Sort(int l,int r) //精髓 &#123; if (!k or l&gt;=r-1) return; int mid=(l+r)&gt;&gt;1; swap(a[mid-1],a[mid]); --k; Sort(l,mid);Sort(mid,r); &#125; void Soviet() &#123; if (k%2==0) return (void)puts("-1"); k/=2; F(i,1,n) a[i]=i; Sort(1,n+1); if (k) return (void)puts("-1"); else &#123; F(i,1,n) printf("%d ",a[i]); putchar('\n'); &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 776C Molly's Chemicals 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-776C-Molly-s-Chemicals-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个序列，长度$1e5$，每个数的绝对值小于$1e9$，还有一个$-10&lt;=k&lt;=10$，请你求出有多少个区间的和是$k^a$的形式，其中$a$为自然数。 思路框架开个平衡树记录一下即珂。 具体思路$k=\pm 1$的情况特判。 首先，区间和$[l,r]$珂以拆成$sum[r]-sum[l-1]$，其中$sum$是前缀和数组。然后对于每个$sum[l-1]$，我们用一个平衡树（$map$）记录它出现了多少次。对于每个$r$，我们枚举一个$k^a$，（这样的枚举是$O(log)$的），然后$sum[r]-k^a$就是对应情况下$sum[l-1]$的值。看它有多少个即珂。 根据加法原理把答案加起来。不用取膜，所以要记得开$long long$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define int long long //开long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n,k,a[N]; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n),R1(k); F(i,1,n) R1(a[i]); &#125; map&lt;int,int&gt; s; void Soviet() &#123; int sum=0; int ans=0; s[0]=1;//这个是必要的细节 F(i,1,n) &#123; sum+=a[i];//sum[r]的值，一边算一边记录 Fs(j,1,1e17,j*=k)//枚举一个k^a &#123; int x=sum-j;//对应的sum[l-1] if (s.count(x)) ans+=s[x]; if (k==1 or j==-1) break;//特判 &#125; s[sum]++;//记录 &#125; printf("%I64d\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 764C Timofey and a tree 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-764C-Timofey-and-a-tree-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一颗无根树，每个点有颜色，请确定一个点，使得以这个点为根，则所有子树中都是一个颜色。为防歧义，良心插图。 如图： 思路设c为满足链接的两个点颜色不一样的边（简称“异色边”）的个数。找到一个点，使得这个点连出去的异色边数量==C，那么这个点就是我们要找的根。否则就没有这样的根。 具体思路这个题还是很巧妙的，如果第一次做完全不会想到。别急，慢慢分析。 如右图，设我们要选的点是点k。c的定义同“思路”中的定义。那么，我们会发现，由于子树中的颜色都是一样的，所以异色边仅有在k和儿子的连边中出现。所以，如果有一个满足条件的k，那么这个k点连出去的异色边的数量肯定就等于全局的异色边数量c。 实现注意由于我们只需要遍历边，所以只要开一个struct数组存下来边即珂。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n; struct Edge//快速遍历边 &#123; int u,v; &#125;E[N];int cnt=0; int val[N]; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n); F(i,1,n-1) &#123; int u,v; R1(u),R1(v); E[++cnt]=(Edge)&#123;u,v&#125;; &#125; F(i,1,n) R1(val[i]); &#125; int ddeg[N];//different degree void Soviet() &#123; int sum=0; F(i,1,cnt) &#123; int u=E[i].u,v=E[i].v; if (val[u]!=val[v]) ++sum,++ddeg[u],++ddeg[v]; &#125; F(i,1,n) &#123; if (ddeg[i]==sum) &#123; puts("YES"); printf("%d\n",i); return; &#125; &#125; puts("NO"); &#125; void IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 719E Sasha and Array 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-719E-Sasha-and-Array-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述 维护一个序列，支持两个操作： 区间加某个数 求区间斐波那契的和。形式的说，设f_i表示斐波那契的第i项，f_1=f_2=1,f_n=f_{n-1}+f_{n-2}。设原序列为a。则区间[l,r]的斐波那契和为：f_{a_l}+f_{a_{l}+1}+f_{a_{l}+2}...+f_{a_{r}}，也就是\sum\limits_{i=l}^{r} {f_{a_i}}。（要膜1e9+7） 思路我艹了都，这tm能做？！ 不过我估计您看一下标签就能明白一切。线段树，肯定要有的。矩阵乘法？对鸭我怎么没想到用这个！太巧妙了！ 没错。我们在使用矩阵快速幂求斐波那契时，是为了达到我们这样的一个目标：把斐波那契的转移变成一个乘积形式，然后用快速幂优化。 然后这个题中也要用到类似的思想。我们把序列中的斐波那契数变成乘积形式，然后我们就珂以用线段树维护区间乘法，然后查询的话就是区间的矩阵求和问题了。这个就是非常裸了线段树了。 再具体一点： 一开始输入a_1,a_2...a_n，然后在线段树中维护矩阵： \begin{bmatrix} f_{a_1} & f_{a_1-1}\\ \end{bmatrix} \begin{bmatrix} f_{a_2} & f_{a_2-1}\\ \end{bmatrix} ... \begin{bmatrix} f_{a_n} & f_{a_n-1} \end{bmatrix}对于区间[l,r]加上c的操作，就是在对应区间乘以转移矩阵 \begin{bmatrix} 1 & 1\\ 1 & 0 \\ \end{bmatrix}的c次方。 对于区间[l,r]求和的操作，就是求出矩阵的和，然后取位于(1,1)的元素即珂。 最后讲一个实现细节：把矩阵封装成一个类，重载运算符，这样很清楚，而且几乎不用改多少线段树的代码。就是AddOne函数里面注意，不要写反了，矩阵没有交换律的。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define int long long #define N 112345 #define mod (1000000007ll) #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u);~i;i=G.Next(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) class Matrix//square matrix &#123; public: int a[3][3]; //variable list int n;//size //initialization Matrix() &#123; memset(a,0,sizeof(a)); n=0; &#125; Matrix(int _n) &#123; memset(a,0,sizeof(a)); n=_n; &#125; Matrix(int _n,int _x) &#123;_x%=mod; n=_n; for(int i=0;i&lt;3;++i) &#123; for(int j=0;j&lt;3;++j) &#123; a[i][j]=_x; &#125; &#125; &#125; //get value int* operator[](int i) &#123; return *(a+i); &#125; void Put() &#123; for(int i=1;i&lt;=2;++i) &#123; for(int j=1;j&lt;=2;++j) &#123; printf("%I64d ",a[i][j]); &#125;putchar('\n'); &#125; &#125; //set value void Set(int x) &#123;x%=mod; for(int i=0;i&lt;3;++i) &#123; for(int j=0;j&lt;3;++j) &#123; a[i][j]=x; &#125; &#125; &#125; void Identity() &#123; memset(a,0,sizeof(a)); for(int i=0;i&lt;3;++i) &#123; a[i][i]=1; &#125; &#125; #undef S //4 &#125;; Matrix operator+(Matrix x,Matrix y) &#123; Matrix ans(2,0); F(i,1,2) F(j,1,2) &#123; ans[i][j]=(x[i][j]+y[i][j])%mod; &#125; return ans; &#125; Matrix operator*(Matrix x,Matrix y) &#123; Matrix ans(2,0); int n=2; for(int i=1;i&lt;=2;++i) &#123; for(int j=1;j&lt;=2;++j) &#123; for(int k=1;k&lt;=2;++k) &#123; ans[i][j]+=x[i][k]*y[k][j]; ans[i][j]%=mod; &#125; &#125; &#125; return ans; &#125; Matrix operator^(Matrix x,int p) &#123; Matrix ans(x.n,1); ans.Identity(); while(p) &#123; if (p&amp;1) ans=ans*x; x=x*x,p&gt;&gt;=1; &#125; return ans; &#125;//矩阵 int Fib(int x) &#123; if (x==0) return 0; if (x==1) return 1; if (x==2) return 1; Matrix Init(2,0),Trans(2,0); Init.Set(0);Trans.Set(1); Init[1][1]=1; Init[1][2]=0; //Trans= //1 1 //1 0 Trans[2][2]=0; Matrix Ans(2,0); Ans=Init*(Trans^(x-1)); return Ans[1][1]; &#125;//求单个斐波那契 void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; class SegmentTree &#123; public: struct node &#123; int l,r; Matrix s,a; &#125;tree[N&lt;&lt;2]; #define ls index&lt;&lt;1 #define rs index&lt;&lt;1|1 #define L tree[index].l #define R tree[index].r #define S tree[index].s #define A tree[index].a #define lL tree[ls].l #define lR tree[ls].r #define lS tree[ls].s #define lA tree[ls].a #define rL tree[rs].l #define rR tree[rs].r #define rS tree[rs].s #define rA tree[rs].a void Update(int index=1) &#123; S=lS+rS; A.Identity();//注意：A不是0，而是单位矩阵（珂以当成是数字运算中的1） &#125; void Build(int l,int r,int index=1) &#123; L=l,R=r; if (l==r) &#123; int x;R1(x); S.Set(0);A.Set(0); S.n=A.n=2; S[1][1]=Fib(x);S[1][2]=Fib(x-1); //初始矩阵 A.Identity(); return; &#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,ls); Build(mid+1,r,rs); Update(index); &#125; void MulOne(Matrix x,int index=1) &#123; A=A*x; S=S*x;//李云龙：你他娘的给我看着点，别打歪了 &#125; void PushDown(int index=1) &#123; MulOne(A,ls); MulOne(A,rs); A.Identity(); &#125; void Mul(int l,int r,Matrix x,int index=1) &#123; if (l&gt;R or L&gt;r) return; if (l&lt;=L and R&lt;=r) &#123; MulOne(x,index); return; &#125; PushDown(index); Mul(l,r,x,ls); Mul(l,r,x,rs); Update(index); &#125; Matrix Query(int l,int r,int index=1) &#123; if (L&gt;r or l&gt;R) &#123; Matrix empt(2,0); empt.Set(0); return empt;//返回一个空矩阵 &#125; if (l&lt;=L and R&lt;=r) &#123; return S; &#125; PushDown(index); return Query(l,r,ls)+Query(l,r,rs); &#125; &#125;T; void Input_Soviet() &#123; int n,q; R1(n),R1(q); T.Build(1,n); F(i,1,q) &#123; int o,l,r; R1(o),R1(l),R1(r); if (o==1) &#123; int c;R1(c); Matrix Trans(2,1); Trans[2][2]=0; Trans=(Trans^(c)); T.Mul(l,r,Trans);//区间乘以转移矩阵的c次方 &#125; else if (o==2) &#123; Matrix Ans=T.Query(l,r); printf("%I64d\n",Ans.a[1][1]); &#125; &#125; &#125; void IsMyWife() &#123; Input_Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>线段树</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 540D Bad Luck Island 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-540D-Bad-Luck-Island-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述一个岛屿上有$a$只A类生物，$b$只B类生物,$c$只C类生物。其中A吃B，B吃C，C吃A。每个时刻，每一对动物相遇的概率都是等概率的。若干时刻后，岛屿上应该只剩下一种动物。对于A,B,C，求出剩下的最后一种动物是A，B，C的概率。$1&lt;=a,b,c&lt;=100$ 思路设状态由于a,b,c&lt;=100，容易得到$dp[i][j][k]$表示剩下$i$个A，$j$个B，$k$个C。很明显。 转移首先，$dp[i][j][k]$珂以由$dp[i+1][j][k],dp[i][j+1][k],dp[i][j][k+1$转移过来。由于三种情况相似，就只讨论一种，写代码的时候基本就是复制然后改改了。 dp[i+1][j][k]转移到dp[i][j][k]那就是死了一个A种生物。也就是上一秒一个A生物和一个C生物相遇了。总共的方案数是$(i+1)j+(i+1)k+jk$，一个A一个C有$(i+1)k$中情况，那么概率就是$\dfrac{(i+1)k}{(i+1)j+(i+1)k+jk}$。用这个式子乘以$dp[i+1][j][k]$即珂。 然后把三个情况加起来就是$dp[i][j][k]$的概率了。注意特判分母为零的情况，这个时候要令分数值为0。因为我们的转移中是要舍去这种情况的。 最后的答案：A存活的概率就是$dp[1,2….n][0][0]$，B存活的概率就是$dp[0][1,2…n][0]$，C存活的概率就是$dp[0][0][1,2…n]$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 122 #define real double #define EPS 1e-8 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int a,b,c; void Input() &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; &#125; real dp[N][N][N]; void Soviet() &#123; FK(dp); dp[a][b][c]=1.00; D(i,a,0) D(j,b,0) D(k,c,0) &#123; if(i==a and j==b and k==c) continue; real ii=i,jj=j,kk=k; dp[i][j][k]=0.00; real all,p; all=(ii+1)*jj+(ii+1)*kk+jj*kk;//总共的情况，如果为0，那就令p=0 p=(ii+1)*k;p/=all;if (fabs(all)&lt;EPS) p=0.00;//p: 概率 dp[i][j][k]+=p*dp[i+1][j][k]; all=ii*(jj+1)+ii*kk+(jj+1)*kk; p=(jj+1)*ii;p/=all;if (fabs(all)&lt;EPS) p=0.00; dp[i][j][k]+=p*dp[i][j+1][k]; all=ii*jj+ii*(kk+1)+jj*(kk+1); p=(k+1)*jj;p/=all;if (fabs(all)&lt;EPS) p=0.00; dp[i][j][k]+=p*dp[i][j][k+1];//这两个同理 &#125; real aa=0.00,bb=0.00,cc=0.00; F(i,1,a) aa+=dp[i][0][0]; F(i,1,b) bb+=dp[0][i][0]; F(i,1,c) cc+=dp[0][0][i]; printf("%.9f %.9f %.9f\n",aa,bb,cc); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 518D Ilya and Escalator 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-518D-Ilya-and-Escalator-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述$n(&lt;=2000)$个人上电梯。每一秒，队列的第一个人都有$p$（每个时刻都是$p$，不会变,$0&lt;=p&lt;=1$）的概率上电梯。请求出$t(&lt;=2000)$秒时电梯上人数的期望值。 思路框架dp[i][j]表示第$i$时刻有$j$个人在电梯上的概率。最后用概率乘以数值求出期望（根据定义）。 具体思路老样子，分两块 Part1. 设状态首先$dp$里面肯定有一维时间，这毫无疑问。然后我们发现， n,t只有2000，肯定不是让你线性过的，又不是A题 只有一维时间好像也无法转移所以考虑加上一维人数。粗略估计珂以转移。 Part2. 转移$dp[i][j]$：时间为$i$，电梯上有$j$个人的概率。 $dp[i][j]=dp[i-1][j-1]\times p+dp[i-1][j]\times (1-p)$。其中$p$是上来一个人的概率，$1-p$是没上来人的概率。这个式子看起来很正确。但是我们考虑几个特殊情况 j=0。这个的确需要考虑。而且这个时候j-1=-1，直接访问会RE。但是也不是不能转移，方程应该是dp[i][0]=dp[i-1][0]×(1-p)。也就是，我们要电梯上有0个人，那就要一直不上来，也就是一直乘以1-p。当然你也珂以认为它是(1-p)^i。 j=n。如果上一秒已经到$n$个人了，这个时候队列已经空了。无论发生什么都还是$n$个人。所以$dp[i][n]=dp[i-1][n-1]\times p+dp[i-1][n]$。 特判一下转移即珂。边界很显然，$dp[0][0]=1.00$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 2333 #define real double #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n,t;real p; void Input() &#123; scanf("%d%lf%d",&amp;n,&amp;p,&amp;t); &#125; real dp[N][N]; void Soviet() &#123; FK(dp); dp[0][0]=1.00; F(i,1,t) &#123; F(j,0,n) &#123; if (j==0) dp[i][j]=dp[i-1][j]*(1-p); else if (j==n) dp[i][j]=dp[i-1][j-1]*p+dp[i-1][j]; else dp[i][j]=dp[i-1][j-1]*p+dp[i-1][j]*(1-p); // printf("dp[%d][%d]=%.3f\n",i,j,dp[i][j]); &#125; &#125; real ans=0.00; F(i,1,n) ans+=dp[t][i]*i; printf("%.6f\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>期望</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 510E Fox and Dinner 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-510E-Fox-and-Dinner-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定n(]]></content>
      <tags>
        <tag>思维</tag>
        <tag>数论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 400E Inna and Binary Logic 口胡题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-400E-Inna-and-Binary-Logic-%E5%8F%A3%E8%83%A1%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个序列a，其长度为n,(a_i]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 301D Yaroslav and Divisors 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-301D-Yaroslav-and-Divisors-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给你一个[1,n]的排列，长度为n，多次查询一段区间中有多少对数满足其中一个是另一个的倍数。n是1e5，复杂度大约是log^2的，当然如果您能想出一个带根号的算法，那我开心死了。私信3348064478@qq.com，或者评论。 思路框架离线询问，然后用合理的遍历顺序加上一个完美的树状数组维护，nlogn过这个题。 具体思路我们的主体目标是要在每个数的右边找到一个能与其组成一对倍数关系的数，这样就不会导致同一对倍数被算两次了。所以我们不管是因数关系还是倍数关系，只管往右边就对了。 由于是排列，所以我们珂以用一个vector存储每个数的倍数/因数都出现在哪些位置。这样的空间复杂度是O(n/1+n/2+n/3+n/4...+n/n)=O(nlogn)的，能够承受。 然后我们把询问的区间按左端点从右往左排序。考虑每个数，显然它的贡献就是出现在[l,r]中并且能和其组成倍数关系的数。然后，对于它每个倍数/因数的位置，我们用树状数组维护一下，在这里加上1，然后计算[1,r]的和即珂。 实现注意 不用long long （是不是很反常 没啥别的了，就是个纯思维题（是不是很良心 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 255555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) struct node &#123; int l,r,id; &#125;q[N]; bool operator&lt;(node a,node b) &#123;return a.l&gt;b.l;&#125; int n,m; int a[N]; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n),R1(m); F(i,1,n) R1(a[i]); F(i,1,m) &#123; int l,r;R1(l),R1(r); if (l&gt;r) swap(l,r); q[i]=(node)&#123;l,r,i&#125;; &#125; &#125; int pos[N]; int ans[N]; vector&lt;int&gt; mul[N]; void initmul() &#123; F(i,1,n) pos[a[i]]=i;//存储每个数出现在哪个位置 F(i,1,n) //由于我们要往右边找，所以要保证mul[i]的每个位置都&gt;=i &#123; for(int num=a[i];num&lt;=n;num+=a[i])//对于每个倍数，我们都存储一下 &#123; if (pos[num]&gt;=i)//如果在右边 &#123; mul[i].push_back(pos[num]);//那就记录在i这里 &#125; else &#123; mul[pos[num]].push_back(i);//否则就记录在pos[num]这里，这样就是存因数了，所以我们就不需要再来一个循环存储因数了 &#125; &#125; &#125; &#125; class BIT &#123; public: int tree[N]; int len; void BuildTree(int _len) &#123; len=_len; FK(tree); &#125; void Add(int pos,int val=1) &#123; for(int i=pos;i&lt;=len;i+=(i&amp;(-i))) &#123; tree[i]+=val; &#125; &#125; int Query(int pos) &#123; int ans=0; for(int i=pos;i&gt;0;i-=(i&amp;(-i))) &#123; ans+=tree[i]; &#125; return ans; &#125; &#125;T; void Soviet() &#123; initmul(); sort(q+1,q+m+1); T.BuildTree(n); int Max=n+1;//上一个位置+1 （STL风 F(i,1,m) &#123; F(j,q[i].l,Max-1)//从上一个位置开始 &#123; F(k,0,(int)mul[j].size()-1)//找到每个能组成倍数的 &#123; T.Add(mul[j][k],1);//在这里加上1 &#125; &#125; ans[q[i].id]=T.Query(q[i].r);//然后[1,q[i].r]中的和就是倍数对的数量了 Max=q[i].l;//这个别忘了 &#125; F(i,1,m) printf("%d\n",ans[i]); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>数论</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 261D Maxim and Increasing Subsequence 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-261D-Maxim-and-Increasing-Subsequence-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定四个正整数k,n,maxb,t。（$k&lt;=10$，$n,maxb&lt;=1e5,n\times maxb&lt;=2e7$，$t&lt;=1e9$）。k组数据，每次给定一个长度为n的序列a1,a2…an，每个数都在[0,maxb]之间。把a序列重复写t遍，求最长严格上升子序列长度。 思路框架设有sum个不同的数。如果t&gt;=sum，显然答案就是sum。否则，因为$n\times maxb&lt;=2e7$，暴力即珂。$O(tnogn)$，虽然有些卡，但是要相信CF机的速♂度。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) class BIT &#123; public: int tree[N]; int len; void BuildTree(int _len) &#123; len=_len; FK(tree); &#125; void Add(int pos,int val=1) &#123; for(int i=pos;i&lt;=len;i+=(i&amp;(-i))) &#123; tree[i]=max(tree[i],val); &#125; &#125; int Query(int pos) &#123; int ans=0; for(int i=pos;i&gt;0;i-=(i&amp;(-i))) &#123; ans=max(ans,tree[i]); &#125; return ans; &#125; &#125;T; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int k,n,Maxb,t; int a[N]; void Input() &#123; F(i,1,n) R1(a[i]); &#125; int b[N]; int dp[N]; void Soviet() &#123; int sum=0; F(i,1,n) &#123; if (b[a[i]]!=k+1) sum++; b[a[i]]=k+1; &#125;//求出不同的元素数量 if (t&gt;=sum)//t&gt;=sum，直接输出sum &#123; printf("%d\n",sum);return; &#125; int ans=0; T.BuildTree(110000);//按值域建树 FK(dp); F(i,1,t)F(j,1,n) &#123; int c=T.Query(a[j]-1)+1; if (c&gt;dp[j]) &#123; dp[j]=c; ans=max(dp[j],ans); T.Add(a[j],c); &#125; if (ans&gt;=sum) break;//思考：这里能否改成ans==sum？ &#125; printf("%d\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; R1(k),R1(n),R1(Maxb),R1(t); while(k--) &#123; Input(); Soviet(); &#125; &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125; 思考题答案：珂以，因为在那个地方不珂能出现ans&gt;sum的情况。]]></content>
      <tags>
        <tag>思维</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 16E Fish 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-16E-Fish-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述有n(]]></content>
      <tags>
        <tag>DP</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 163A Substring and Subsequence 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-163A-Substring-and-Subsequence-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[震惊！一sb少年被一个A题卡了半天！题意简述给定两个字符串$a,b$，求有多少对有序对$(x,y)$使得$x$是$a$的子串，$y$是$b$的子序列。两字符串长度$&lt;=5000$，空间$5000\times 5000\times 5$是够的。 思路框架裸的$DP$。 具体思路$dp[i][j]$表示考虑$a$的前$i$位，$b$的前$j$位的答案。那么，$dp[i][j]$=$dp[i-1][k]$的和$+1$，其中$k\in [1,j-1]$，并且$a[i]==b[j]$。 这个转移式很好理解。就是在$ai$和$bj$相同的时候，两种情况 上一个位置的答案，就是前面的求和 $a[i]$和$b[j]$取出来，也是一种方案。 但是，这个转移是$O(n^3)$的，那咋整嘛。 我们会发现，这个转移式珂以用前缀和优化。 设$sum[i][j]$表示$dp[i][1…j]$的和。然后$dp[i][j]=sum[i-1][j-1]+1$。 每次求完$dp$之后，维护一下$sum$。 时空复杂度最高$O(n^2)$。其中$n=5000$。稳过。 （相信CF的机子） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 5003 #define mod 1000000007 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) char a[N],b[N]; int la,lb; void Input() &#123; scanf("%s%s",a+1,b+1); la=strlen(a+1),lb=strlen(b+1); &#125; int dp[N][N]; int sum[N][N]; void Soviet() &#123; if (a[1]==b[1]) dp[1][1]=1; F(i,2,lb) if (a[1]==b[i]) dp[1][i]=1; F(i,2,la) if (a[i]==b[1]) dp[i][1]=1; F(i,1,lb) sum[1][i]=sum[1][i-1]+dp[1][i]; F(i,2,la) &#123; F(j,2,lb) &#123; if (a[i]==b[j]) &#123; dp[i][j]=sum[i-1][j-1]+1; &#125; else dp[i][j]=0; dp[i][j]%=mod; &#125; F(j,1,lb) sum[i][j]=(sum[i][j-1]+dp[i][j])%mod; &#125; int ans=0; F(i,1,la) ans=(ans+sum[i][lb])%mod; printf("%d\n",ans%mod); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1266C Diverse Matrix 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-1266C-Diverse-Matrix-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述构造一个r行c列的矩阵，r,c&lt;=500，满足：不存在1&lt;=i&lt;=r，1&lt;=j&lt;=c，使得第i行所有数的gcd=第j列所有数的gcd（即：行，列gcd两两不同）多解输出任意一个。无解输出0。 思路框架 只有1x1的矩阵是无解的 r=1的情况，显然只要令矩阵为[2,3,4…c+1]即珂。c=1同理。 别的情况，令第$i$行的$gcd$为$i$，第$i$列的$gcd$为$r+i$即珂。这样行，列的$gcd$正好是$1,2,3…r+c$，完美而潇洒。 具体思路思考一个问题：如何令第$i$行的$gcd$为$i$，第$i$列的$gcd$位$r+i$？ 那很简单，拿行举例：第$i$行的$gcd$为$i$，那就让每个数都是i乘上一个东西即珂。乘上的东西要互质。 如何保证互质呢？我们发现，此时$r,c&gt;=2$，而连续的两个（或以上）个正整数之间，$gcd$肯定是$1$。所以我们只要让第$i$行为$c$个连续正整数即珂。列同理。 稍加思索，我们令第$i$行第$j$列为：$i*(j+r)$。这样，对于任意的$i$，第$i$行所有数都是$i$乘上$c$个连续的正整数；对于任意的$i$，第$I$列所有数都是$i$乘上$r$个连续的正整数。满足条件。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1333 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int a[N][N]; int r,c; void Input() &#123; R1(r),R1(c); &#125; void Soviet() &#123; if (r==1 and c==1) &#123;return (void)puts("0");&#125; if (r==1) &#123;F(i,1,c) printf("%d ",i+1);return;&#125; if (c==1) &#123;F(i,1,r) printf("%d ",i+1);return;&#125; F(i,1,r) F(j,1,c) a[i][j]=i*(j+r); F(i,1,r) F(j,1,c) printf("%d%c",a[i][j]," \n"[j==c]); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>数论</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1257C Dominated Subarray 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-1257C-Dominated-Subarray-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述定义“支配数组”：长度&gt;=2，且出现次数最多的那个数字唯一。 给定一个数组，请你求出这个数组中，长度最小的是“支配数组”的连续子序列的长度。 数组长度&lt;=2e5。 思路最短的“支配连续子序列”，显然是：最左边和最右边两个数字相同，中间的数组两两不同。 设pre[i]表示a中上一个和a[i]的值相同的位置。换句话说，pre[i]=max{j，满足a[j]==a[i]} 那么只要求所有i-pre[i]+1的最小值即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 255555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int n,a[N]; void Input() &#123; R1(n);F(i,1,n) R1(a[i]); &#125; int pre[N],pos[N]; void Soviet() &#123; MEM(pos,-1);MEM(pre,-1); bool flag=0; int ans=0x3f3f3f3f; F(i,1,n) &#123; pre[a[i]]=pos[a[i]]; pos[a[i]]=i; if (pre[a[i]]!=-1) ans=min(ans,i-pre[a[i]]+1),flag=1; &#125; if (!flag) puts("-1"); else printf("%d\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; int t;R1(t); F(i,1,t) &#123; Input(); Soviet(); &#125; &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1251E2 Voting (Hard Version) 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-1251E2-Voting-Hard-Version-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述多组数据。有$n&lt;=2e5$个人，每个人有$m_i,p_i$。如果有$m_i$个人投给了你，那么这个人也会投你。否则你珂以用$p_i$块钱贿赂它。求所有人都投你的最小花费。 思路框架先贿赂$m$大的，$p$小的。 具体思路首先，$m$值更大的显然需要更多的人投，才能免费。所以，大一些的$m$我们就先考虑直接贿赂（当然，如果人数够了就直接免费）。所以要把$m$从大到小排序。然后优先贿赂便宜的，这也是显然的。while循环判断人数是否够了。优先贿赂便宜的，就用个优先队列好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 255555 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) vector&lt;int&gt; a[N]; int n; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n); F(i,0,n) a[i].clear(); F(i,1,n) &#123; int m,p;R1(m),R1(p); a[m].push_back(p); &#125; &#125; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; Q; void Soviet() &#123; while(!Q.empty()) Q.pop(); int cost=0; D(i,n,0) &#123; for(auto v:a[i]) Q.push(v); while((int)Q.size()&gt;n-i) &#123; cost+=Q.top();Q.pop(); &#125; &#125; printf("%lld\n",cost); &#125; #define Flan void Flan IsMyWife() &#123; int t;R1(t); F(i,1,t) &#123; Input(); Soviet(); &#125; &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1240C Paint the Tree 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-1240C-Paint-the-Tree-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个有$n$个节点的树，$n&lt;=5e5$。每个点只能染精确的$k$种颜色，有无限种颜色珂供选择，但是每种颜色不能出现超过两次。如果一条边连接的两个点的两个颜色中有至少一个共同的，这条边就会产生它边权的权值。合理分配使权值最大，输出最大的权值。 思路框架设$dp[i][0/1]$表示以$i$为根，是/否选择$i$到$i$的父亲那一条边，的最大权值和。转移即珂。 具体思路分两个部分。 Part 1. 状态那么我们为什么这么设状态呢。。。 套路 原因是这样的，我们一开始肯定能想到设前面的$dp[i]$表示以$i$为根的答案。但是，如果只有这个，我们很难判断一个儿子是否能连上来，因为要连上来就需要有一个颜色与父亲对应，而和儿子只能用$k-1$个颜色，这状态就不对，或者说，我们少一个状态。 所以我们考虑设$dp[i][0/1]$，加上后面那一维。 Part 2. 转移首先，把所有儿子的$dp[son][1]$加起来显然是一种选择。记这个默认值为$S$。 然后我们发现，还珂能有儿子连到父亲的边的情况。这种情况，就是$dp[son][0]+w$，$w$是这条边的边权。如果这种情况的确更好，我们要把$son$这个儿子的默认值$dp[son][1]$换成$dp[son][0]+w$，对$S$的影响很显然就是$S=S-dp[son][1]+dp[son][0]+w$。但是我们能接到儿子的边最多就只有$k$条，因为我们现在考虑的$u$点只能染$k$种颜色。 那咋整嘛。也好办，我们把后半部分$dp[son][0]+w-dp[son][1]$记下来，从大到小排个序。如果是$dp[i][1]$，选前面$k$个即珂；但是$dp[i][0]$只能选前面$k-1$个，因为还有留一个给父亲。当然，如果这个值是负的，说明选了之后不会更优。一个是负的，后面肯定都是负的了，于是直接 $break$掉，不管了。 然后就结束了代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1666666 #define lovelive long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[N&lt;&lt;1]; void clear(int _len) &#123; memset(Ed,-1,sizeof(Edge)*(_len+10)); memset(head,-1,sizeof(int)*(_len+10)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; int n,k; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n),R1(k); G.clear(n); F(i,1,n-1) &#123; int u,v,w;R1(u),R1(v),R1(w); G.Add2(u,v,w); &#125; &#125; lovelive dp[N][2]; //0: choose father //1: don't choose father void DFS(int u,int f) &#123; lovelive sum=0; vector&lt;lovelive&gt; son;son.clear(); Tra(i,u) &#123;int v=__v; if (v!=f) &#123; DFS(v,u); int d=dp[v][0]+G.Label(i)-dp[v][1]; sum+=dp[v][1]; son.push_back(d); &#125; &#125; dp[u][0]=dp[u][1]=sum; sort(son.begin(),son.end(),greater&lt;lovelive&gt;()); F(i,0,min(k-1,(int)son.size()-1)) &#123; int v=son[i]; if (v&gt;0) &#123; dp[u][1]+=v; if (i&lt;k-1) dp[u][0]+=v; &#125; &#125; &#125; void Soviet() &#123; F(i,1,n) dp[i][0]=dp[i][1]=0; DFS(1,1); printf("%I64d\n",dp[1][1]); &#125; #define Flan void Flan IsMyWife() &#123; int t;R1(t); while(t--) &#123; Input(); Soviet(); &#125; &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1237D Balanced Playlist 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-1237D-Balanced-Playlist-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述n首歌循环播放。每首歌有一个欢乐值。播放到一首歌，如果这首歌的欢乐值的两倍小于放过的最大值，则停止。对于每首歌，求出从这首歌开始播放，能放几首歌。n&lt;=1e5。 思路框架如果全局最小值的两倍&gt;=全局最大值，直接全部输出-1。 数组开三倍。维护一个单调递减的单调队列。现在考虑到$i$，先把$a[i]$入队列。如果$a[i]$两倍小于队首$H$，记录$ans[H]=i-H$，弹出队首。对于没有处理过的位置$i$，直接ans[i]=ans[i+1]+1。输出1~n位置的答案。 具体思路由于是循环的问题，我们考虑把数组开两倍。但是看到样例二，手动模拟一下，发现这不够，要三倍。 开始分析。显然，$i$位置能播放到的位置肯定&lt;=$i+1$能放到的位置。比如这组数据：121558 37 28 74 28 41 50 34 72 79 45 42 94 54 39 我们计算每个位置能放到的位置，得到这样一个数组：13 5 5 5 15 15 15 15 15 15 15 15 15 18 18 （小数据，可以手做做看或者模拟） 设这个数组为$pos$。题目让我们求的就是$pos[i]-i$，并输出。设题目求的是$ans$数组。那么我们考虑求这个$pos$。如果不是在“转折点”的时候，应该满足$ans[i]=ans[i+1]+1$。所以我们现在就是要求这些转折点位置的答案。别的位置就直接$ans[i]=ans[i+1]+1$。 求转折点位置及答案思考：为什么会有“转折”？ 比如说第$i$个位置和第$i+1$个位置不一样。那么肯定是因为$i$位置更新了最大值，让最大值变大了，更加容易满足条件，所以答案减少。 能更新最大值的位置，就是转折点。我们用一个单调队列维护即珂（队列里面维护下标）。 入队列的条件如果有一个元素A比另一个元素B排在后面，然后A还比B大，那么B无论如何也不会更新最大值了。因为，只要能考虑到B，就肯定能考虑到A，而且A还比你大。所以我们的队列，如果新的队尾大于原来的队尾，那么就弹出原来的队尾。换句话说，就是维护一个单调递减的队列。 出队列的条件如果当前考虑的$i$，满足$a[i]$两倍小于队首$H$，那么如果从$H$开始播放，肯定播放到$i$就停止了，后面就不会再有影响。所以如果发生了这样的情况，就记录队首的答案，并且把它弹出去。 转折点篇 完代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 355555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int n,a[N]; void Input() &#123; R1(n);F(i,1,n) R1(a[i]),a[i+n]=a[i+2*n]=a[i]; &#125; int Q[N],head,tail; int ans[N]; void Soviet() &#123; int Max=*max_element(a+1,a+n+1),Min=*min_element(a+1,a+n+1); if (Min*2&gt;=Max) &#123; F(i,1,n) printf("-1%c"," \n"[i==n]); return; &#125;//特判-1 head=0,tail=1; F(i,1,3*n) &#123; while(head&lt;=tail and a[Q[tail]]&lt;a[i]) --tail; Q[++tail]=i; //入队列 while(head&lt;=tail and a[Q[head]]&gt;2*a[i]) &#123; ans[Q[head]]=i-Q[head]; //到i为止，但是题目要求输出的是pos[i]-i，所以干脆直接令答案为i-Q[head] ++head; &#125; &#125; D(i,3*n,1) &#123; if (ans[i]==0) ans[i]=ans[i+1]+1; //直接继承 &#125; F(i,1,n) printf("%d\n",ans[i]); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1027D Mouse Hunt 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces-1027D-Mouse-Hunt-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述n个房间，有一只老鼠可能出现在任意一个房间，并且老鼠在第i个房间出现时，下一秒就会运动到第ai个房间。需要放陷阱确保老鼠不管在哪里出现都会被抓。在第i个房间放陷阱成本ci，输出最少需要多少成本完成题目要求（vjudge翻译）（又是蒯的） 思路框架我们把$i$向$a_i$连边，就得到了老鼠的走向图。然后我们在走向图上找到所有强连通分量。显然，同一个强连通分量（由于每个点有且仅有唯一的出边，所以一个强连通分量肯定就是一个环）中，我们只要在其中一个位置布置陷阱即珂。那么我们就在花费最小的位置布置好了。 那么，哪些强连通分量中要布置陷阱呢？只有缩点后出度为$0$的强连通分量需要布置，因为别的强连通分量会不断的往下走，肯定会走到一个出度为$0$的强连通分量。 总结一下思路： 找出所有强连通分量，求出里面最小的花费，令它为这个强连通分量的花费。 答案=所有出度为0的强连通分量花费的和。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 255555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[N&lt;&lt;1]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int n,a[N],c[N]; void Input() &#123; R1(n); F(i,1,n) R1(c[i]); F(i,1,n) R1(a[i]); &#125; int DFSid[N],low[N],Time=0; stack&lt;int&gt; S;bool In[N]; int SCCid[N],SCCcnt; int Min[N]; //Min[i]: 编号为i的强连通分量的花费 void Tarjan(int u) &#123; DFSid[u]=low[u]=++Time; S.push(u);In[u]=1; Tra(i,u) &#123;int v=__v; if (!DFSid[v]) &#123;Tarjan(v);low[u]=min(low[u],low[v]);&#125; else if (In[v])&#123;low[u]=min(low[u],low[v]);&#125; &#125; if (DFSid[u]==low[u]) &#123; ++SCCcnt; int top; do &#123; top=S.top();S.pop();In[u]=0; SCCid[top]=SCCcnt; Min[SCCcnt]=min(Min[SCCcnt],c[top]); &#125;while(top!=u); &#125; &#125; int odeg[N]; //out degree，出度 void Soviet() &#123; G.clear(); F(i,1,n) G.AddEdge(i,a[i]); while(!S.empty()) S.pop(); Time=SCCcnt=0; FK(DFSid);FK(low); MEM(Min,0x3f); F(i,1,n) if (!DFSid[i]) Tarjan(i); F(u,1,n) Tra(i,u) &#123;int v=__v; int su=SCCid[u],sv=SCCid[v]; if (su!=sv) ++odeg[su]; &#125; int ans=0; F(i,1,SCCcnt) if (!odeg[i]) ans+=Min[i]; //出度为0的强连通分量的花费的和 printf("%d\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>图论</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 833B 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodeforces%20833B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个序列a，长度]]></content>
      <tags>
        <tag>思维</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codefoeces 351B Jeff and Furik 题解]]></title>
    <url>%2F2020%2F02%2F10%2FCodefoeces-351B-Jeff-and-Furik-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个长度为n(]]></content>
      <tags>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4887 洛谷 5789&3758 [TJOI2017]可乐 题解]]></title>
    <url>%2F2020%2F02%2F10%2Fbzoj-4887-%E6%B4%9B%E8%B0%B7-5789-3758-TJOI2017-%E5%8F%AF%E4%B9%90-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[（PS：洛谷上5789是加强版，3758是可以dp水过的原版）（本文讲最优做法，能通过加强版的） 题意简述有$n$个点$m$条边的无向图，你有一个机器人，从点$1$开始走。每次可以：停留在原地，自爆（就不能继续走了），选一个相邻的点继续走。边珂以重复经过。问你走$k$步有多少种情况。答案对$2017$取膜。 （最高数据）$n,m&lt;=100,k&lt;=1e9$。 思路停留在原地，我们给每个点加一个自环即珂。自爆的话，我们加入一个新的$E$（设其编号$n+1$即珂）。对于原图的每一个点，都向$E$连一条有向边。$E$就表示一个爆炸的状态：每个点都可以爆炸，爆炸完就回不去了（边是有向的，去了就回不来了）。 然后我们保存一个邻接矩阵$G$。我们发现，$G[u][v]=1$，表示$u$珂以一步走到$v$。 那么$G^k$（矩阵快速幂）表示什么意义呢？容易得到，它表示：走$k$步，珂以经过重复的边，图的连通方案。$G^k[u][v]$表示$u,v$之间长度为$k$的路径的条数（边能重复经过）。 那么我们根据上面的建图方式，建出邻接矩阵，然后矩阵快速幂求$k$次方，$G[1][1]+G[1][2]+…+G[1][n+1]$（$n+1$就是点$E$），就是机器人走$k$步的所有方案数了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 122 #define mod 2017 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; class Matrix//square matrix &#123; #define S 122//changeable private: int a[S][S]; public: //variable list int n;//size //initialization Matrix() &#123; memset(a,0,sizeof(a)); n=0; &#125; Matrix(int _n) &#123; memset(a,0,sizeof(a)); n=_n; &#125; Matrix(int _n,int _x) &#123;_x%=mod; n=_n; for(int i=0;i&lt;S;++i) &#123; for(int j=0;j&lt;S;++j) &#123; a[i][j]=_x; &#125; &#125; &#125; //get value int* operator[](int i) &#123; return *(a+i); &#125; //set value void Set(int x) &#123;x%=mod; for(int i=0;i&lt;S;++i) &#123; for(int j=0;j&lt;S;++j) &#123; a[i][j]=x; &#125; &#125; &#125; void Identity() &#123; memset(a,0,sizeof(a)); for(int i=0;i&lt;S;++i) &#123; a[i][i]=1; &#125; &#125; #undef S //5 &#125;; Matrix operator*(Matrix x,Matrix y) &#123; Matrix ans(x.n,0); int n=ans.n; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) &#123; if (x[i][j]) &#123; for(int k=1;k&lt;=n;++k) &#123; ans[i][k]+=x[i][j]*y[j][k]; ans[i][k]%=mod; &#125; &#125; &#125; &#125; return ans; &#125; Matrix operator^(Matrix x,int p) &#123; Matrix ans(x.n,1); ans.Identity(); while(p) &#123; if (p&amp;1) ans=ans*x; x=x*x,p&gt;&gt;=1; &#125; return ans; &#125; //到这里都是矩阵 int n,m,t; Matrix G(101,0); //矩阵开n+1个大小 void Input() &#123; Rd(2,&amp;n,&amp;m); F(i,1,m) &#123; int u,v;Rd(2,&amp;u,&amp;v); G[u][v]=G[v][u]=1; &#125; F(i,1,n+1) G[i][i]=G[i][n+1]=1; //G[i][i]是停留在原地的边，G[i][n+1]是自爆的边 &#125; void Soviet() &#123; R1(t); //名字不太一样...t就是上面说的k，抱歉 G=G^t; int ans=0; F(i,1,n+1) ans+=G[1][i],ans%=mod; printf("%d\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>矩阵乘法</tag>
        <tag>转换思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4804 欧拉心算 题解]]></title>
    <url>%2F2020%2F02%2F10%2Fbzoj-4804-%E6%AC%A7%E6%8B%89%E5%BF%83%E7%AE%97-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述T组数据。每次给定n，求$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}\phi(gcd(i,j))$n&lt;=10^7，T&lt;=5000。 （用T根号n的算法就能过了） 思路框架把gcd换掉，然后用[SDOI2008]仪仗队（洛谷 bzoj）的做法，每次根号(n)求出来 具体思路把$gcd$换掉，式子变成$\sum\limits_{g=1}^n\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n} [gcd(i,j)==g] \phi(g)$$\phi(g)$提前，变成$\sum\limits_{g=1}^n \phi(g) \sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n} [gcd(i,j)==g]$后面那个式子化一下，变成枚举$i,j$的倍数：$\sum\limits_{g=1}^n \phi(g) \sum\limits_{i=1}^{n/g}\sum\limits_{j=1}^{n/g} [gcd(i,j)==1]$ 然后，后面的式子就变成了仪仗队那题的式子了。也就是，我们要求：$\sum\limits_{i=1}^{x}\sum\limits_{j=1}^{x} [gcd(i,j)==1]$。由于前面$g$要整除分块，带一个根号，所以这个地方就要用一个$O(1)$的算法求。 仪仗队那题的O(1)做法由于$gcd(i,j)$是对称的，所以我们考虑把它变成这样：$2\times \sum\limits_{i=1}^{x}\sum\limits_{j=1}^{i} [gcd(i,j)==1]-\sum\limits_{i=1}^{x} [gcd(i,i)==1]$。我们设$\phi’(i)=\phi(1…i)$的和。（即：求$\phi$的前缀和）那么该式等于$2\phi’(i)-1$。 得解回到原问题。上回说到，式子变成了$\sum\limits_{g=1}^n \phi(g) \sum\limits_{i=1}^{n/g}\sum\limits_{j=1}^{n/g} [gcd(i,j)==1]$。套用仪仗队那题的式子，变成：$\sum\limits_{g=1}^{n} \phi(g)\times(2\phi’(n/g)-1)$ 后面的$n/g$珂以整除分块做。总体复杂度就是$O(1e7+T\times\sqrt{n})=O(AC)$。 WARNING只有phi的前缀和以及答案需要开long long ，其它int就够了。防止MLE。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 10000007 #define lovelive long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int primes[N];bool notp[N]; int phi[N];lovelive sphi[N]; //处理phi的前缀和，记得开long long void Init() //筛 &#123; int &amp;cnt=primes[0]; int n=1e7; notp[1]=1;phi[1]=1; F(i,2,n) &#123; if (!notp[i]) primes[++cnt]=i,phi[i]=i-1; for(int j=1;j&lt;=cnt and i*primes[j]&lt;=n;++j) &#123;int u=primes[j]; notp[i*u]=1; if (i%u==0) &#123; phi[i*u]=phi[i]*u;break; &#125; else &#123; phi[i*u]=phi[i]*phi[u]; &#125; &#125; &#125; F(i,1,n) sphi[i]=sphi[i-1]+phi[i]; //以上O(n) &#125; int n; void Input() &#123; R1(n); &#125; void Soviet() &#123; lovelive ans=0; for(int l=1,r;l&lt;=n;l=r+1) &#123;r=n/(n/l); ans+=(sphi[r]-sphi[l-1])*(2ll*sphi[n/l]-1ll); //整除分块 &#125; printf("%lld\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Init(); int t;R1(t); F(i,1,t) &#123; Input(); Soviet(); &#125; &#125; #undef int //long long&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>数论函数</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4568 洛谷 3292 libreoj 2013 [SCOI2016]幸运数字 题解]]></title>
    <url>%2F2020%2F02%2F10%2Fbzoj-4568-%E6%B4%9B%E8%B0%B7-3292-loj-2013-SCOI2016-%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一颗$n&lt;=20000$个点的树，点带点权，不超过$2^{60}$。还有$Q&lt;=200000$个询问，每次询问两个点之间路径上的最大异或和。 思路$B[i][k]$表示从$i$往上$2^k$个节点组成的线性基。$LCA$的时候线性基合并就珂以了。带三个log，两个是$log2^{60}$，一个是$logn$。也就是$O(200000\times 60\times 60\times 16)$。虽然看起来有$1e9$，但是你相信我那两个$60$乘不满。所以你能过。在$bzoj$的机器上写面向对象都能过。 代码细节这题重在模拟。代码细节蛮多的。 lca的第一步，跳到同一高度，判断条件是deep[fa[u][k]]&lt;=deep[v] lca的最后一步，要把val[u],val[v],val[fa[u][0]]的值都插入进来。联想一下求最小值你就明白这步了 好像没了？代码还是蛮长的，别写挂别的地方即珂 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 24444 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) class LB &#123; public: int d[64]; int&amp; operator[](int id)&#123;return *(d+id);&#125; void Init()&#123;FK(d);&#125; void Insert(int x) &#123; D(i,60,0) &#123; if (!(x&amp;(1ll&lt;&lt;i))) continue; if (!d[i]) &#123; d[i]=x;break; &#125; x^=d[i]; &#125; &#125; int MaxXor() &#123; int ans=0; D(i,60,0) if ((ans^d[i])&gt;ans) ans^=d[i]; return ans; &#125; &#125;; LB Merge(LB a,LB b) &#123; D(i,60,0) &#123; if (b[i]) a.Insert(b[i]); &#125; return a; &#125; class Graph &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[N&lt;&lt;1]; void clear(int _V=N,int _E=N&lt;&lt;1) &#123; memset(Ed,-1,sizeof(Edge)*(_E)); memset(head,-1,sizeof(int)*(_V)); EdgeCount=-1; &#125; void AddEdge(int u,int v,int w=1) &#123; Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125; int Start(int u) &#123;return head[u];&#125; int To(int u)&#123;return Ed[u].To;&#125; int Label(int u)&#123;return Ed[u].Label;&#125; int Next(int u)&#123;return Ed[u].Next;&#125; &#125;G; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int n,m;int val[N]; void Input() &#123; R1(n),R1(m); F(i,1,n) R1(val[i]); G.clear(); F(i,1,n-1) &#123; int u,v;R1(u),R1(v); G.Add2(u,v); &#125; &#125; LB B[N][18]; int fa[N][24],deep[N]; void DFS(int u,int f) &#123; deep[u]=deep[f]+1; fa[u][0]=f; B[u][0].Init();B[u][0].Insert(val[u]); F(i,1,16) &#123; fa[u][i]=fa[fa[u][i-1]][i-1]; B[u][i]=Merge(B[u][i-1],B[fa[u][i-1]][i-1]); &#125; Tra(i,u) &#123;int v=__v; if (v==f) continue; DFS(v,u); &#125; &#125; int LCA(int u,int v) &#123; LB ans;ans.Init(); if (deep[u]&lt;deep[v]) swap(u,v); D(i,16,0) &#123; if (deep[fa[u][i]]&gt;=deep[v]) &#123; ans=Merge(ans,B[u][i]); u=fa[u][i]; &#125; &#125; if (u==v) &#123; ans.Insert(val[u]); return ans.MaxXor(); &#125; D(i,16,0) &#123; if (fa[u][i]!=fa[v][i]) &#123; ans=Merge(ans,B[u][i]); ans=Merge(ans,B[v][i]); u=fa[u][i],v=fa[v][i]; &#125; &#125; ans.Insert(val[u]);ans.Insert(val[v]); ans.Insert(val[fa[u][0]]); return ans.MaxXor(); &#125; void Soviet() &#123; DFS(1,1); F(i,1,m) &#123; int u,v;R1(u),R1(v); printf("%lld\n",LCA(u,v)); &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>树形结构</tag>
        <tag>倍增</tag>
        <tag>线性基</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4542 洛谷 3245 [HNOI]2016大数 题解]]></title>
    <url>%2F2020%2F02%2F10%2Fbzoj-4542-%E6%B4%9B%E8%B0%B7-3245-HNOI-2016%E5%A4%A7%E6%95%B0-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给你一个数字字符串$S$，长度为$n&lt;=1e5$。有一个$int$范围内的质数$P$和$Q&lt;=1e5$次询问，每次询问一个区间$[l,r]$中，$S$的多少个子串（不一定不同）是$P$的倍数。 比如$S=”007”$，它有6个子串，分别是$\{0,0,00,07,007\}$，这$6$个都是$7$的倍数。 思路框架处理后缀和，分类讨论$p$和$10$是否互质。一个用莫队维护，一个用树状数组维护。 具体思路先分类讨论。 1. P和10互质那么末尾多几个$0$就不会影响对$P$的整除性。 维护后缀和$suf$，它表示从$i$开始的后缀接起来膜$P$的值。特殊地，$suf[n+1]=0$。对于一个区间$[l,r]$，当$suf[l]$和$suf[r+1]$相等的时候，$[l,r]$这一段就是$P$的倍数了。相当于我们要在$suf$数组中维护相等的无序对数，莫队即珂。 2. P不和10互质即：P=2或5 这个时候我们就只需要判断末尾就好了。对于$2$的情况，那么子串结尾就是$0,2,4,6,8$。对于$5$的情况，子串结尾就是$0,5$。 假设询问$[l,r]$。我们找到一个$k$，如果以$k$为结尾的子串一定满足条件，那么这个$k$对答案的贡献就是$k-(l-1)$。（因为开始位置珂以是$[l,k]$中的任意一个，一共有$k-(l-1)$种情况） 我们先对$2$和$5$的情况分开讨论，然后开$20$个树状数组，其中$10$个维护长度为0~9的下标的和，另外$10$个维护$0~9$中的数量和。 对于$[l,r]$的询问，相当于要求和所有$k-(l-1)$。令满足条件$k$的数量是$C$，和为$S$。那么这一段答案就是$S-(l-1)\times C$。对于每一种尾数累加答案即珂。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n,p; char s[N]; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(p);scanf("%s",s+1); n=strlen(s+1); &#125; int a[N]; namespace SpecialCxk //p=2或5的情况 &#123; class BIT &#123; public: int tree[N]; int len; void BuildTree(int _len) &#123; len=_len; FK(tree); &#125; void Add(int pos,int val=1) &#123; for(int i=pos;i&lt;=len;i+=(i&amp;(-i))) &#123; tree[i]+=val; &#125; &#125; int Query(int pos) &#123; int ans=0; for(int i=pos;i&gt;0;i-=(i&amp;(-i))) &#123; ans+=tree[i]; &#125; return ans; &#125; int RQuery(int l,int r) &#123; return Query(r)-Query(l-1); &#125; &#125;T[10][2]; //T[i][j]: 值为i的所有位置的j次方和 //换句话说，j=0时计算数量，j=1时计算下标的和 void Soviet() &#123; F(i,0,9) F(j,0,1) T[i][j].BuildTree(n+5); if (p==2) &#123; F(i,1,n) &#123; T[a[i]][0].Add(i,1); T[a[i]][1].Add(i,i); //对于第i个位置，一个加上1，一个加上i //所以一个是数量和，一个是下标和 &#125; int q;R1(q); F(i,1,q) &#123; int l,r; R1(l),R1(r); int cnt0=T[0][0].RQuery(l,r); int sum0=T[0][1].RQuery(l,r)-(l-1)*cnt0; int cnt2=T[2][0].RQuery(l,r); int sum2=T[2][1].RQuery(l,r)-(l-1)*cnt2; int cnt4=T[4][0].RQuery(l,r); int sum4=T[4][1].RQuery(l,r)-(l-1)*cnt4; int cnt8=T[8][0].RQuery(l,r); int sum8=T[8][1].RQuery(l,r)-(l-1)*cnt8; //0 2 4 8分类讨论一下 printf("%lld\n",sum0+sum2+sum4+sum8); //累加 &#125; &#125; else if (p==5) //和p==2的情况没什么本质差别，是同样的思路 &#123; F(i,1,n) &#123; T[a[i]][0].Add(i,1); T[a[i]][1].Add(i,i); &#125; int q;R1(q); F(i,1,q) &#123; int l,r; R1(l),R1(r); int cnt0=T[0][0].RQuery(l,r); int sum0=T[0][1].RQuery(l,r)-(l-1)*cnt0; int cnt5=T[5][0].RQuery(l,r); int sum5=T[5][1].RQuery(l,r)-(l-1)*cnt5; printf("%lld\n",sum0+sum5); &#125; &#125; &#125; &#125; namespace Normal //p不是2或5的情况 &#123; int p10[N],suf[N]; map&lt;int,int&gt; disc;int dcnt=0; int q,sn,ans[N]; struct node&#123;int l,r,id;&#125;Q[N]; bool cmp(node a,node b)&#123;return a.l/sn&lt;b.l/sn or (a.l/sn==b.l/sn and a.r&lt;b.r);&#125; int cur; int cnt[N]; void Add(int x)&#123;cur+=cnt[x];cnt[x]++;&#125; void Del(int x)&#123;cnt[x]--;cur-=cnt[x];&#125; void Soviet() &#123; p10[0]=1;F(i,1,n) p10[i]=p10[i-1]*10ll%p; //处理10的幂，方便维护suf数组 suf[n+1]=0; D(i,n,1) suf[i]=(suf[i+1]+p10[n-i]*a[i])%p; //求出后缀和数组suf F(i,1,n+1) &#123; if (!disc[suf[i]]) disc[suf[i]]=++dcnt; suf[i]=disc[suf[i]]; &#125; //把suf离散化，我用的是map离散化，懒得写排序+lowerbound了 //反正map也能过 sn=sqrt(n+0.5); R1(q); F(i,1,q) &#123; int l,r;R1(l),R1(r); Q[i]=(node)&#123;l,r+1,i&#125;; //注意这里改成l,r+1 &#125; sort(Q+1,Q+q+1,cmp); int ll=1,rr=0;cur=0; F(i,1,q) &#123; while(ll&lt;Q[i].l) Del(suf[ll]),ll++; while(rr&gt;Q[i].r) Del(suf[rr]),rr--; while(ll&gt;Q[i].l) ll--,Add(suf[ll]); while(rr&lt;Q[i].r) rr++,Add(suf[rr]); ans[Q[i].id]=cur; &#125; //莫队 F(i,1,q) printf("%lld\n",ans[i]); &#125; &#125; void Soviet() &#123; F(i,1,n) a[i]=s[i]-'0'; if (p==2 or p==5) SpecialCxk::Soviet(); else Normal::Soviet(); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>数论</tag>
        <tag>树状数组</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3626 [LNOI2014] LCA 题解]]></title>
    <url>%2F2020%2F02%2F10%2Fbzoj-3626-LNOI2014-LCA-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给你一颗n&lt;=1e5个节点树，1e5次询问，每次给你(l,r,z)，求[l,r]区间内每个数和z在树上LCA的深度的和。对201314取膜。 注：根节点深度是1。 思路框架(x,y)的LCA深度就是，把x到根点权+1，然后询问根到y点权和多少。 那么我们相当于，把[l,r]每个点到根点权都+1，然后询问根到z的点权和。差分做。 具体思路差分做法：把一个询问(l,r,z)拆成(1,r,z)和(1,l-1,z)。(l,r,z)的答案显然就是(1,r,z)-(1,l-1,z)。这样我们要求的就是若干的前缀点的答案了。 我们把l-1和r都打上标记i从1到n遍历一下，不断在根到i的路径上点权+1。的如果某个点有标记，那么就把所有的z拿出来询问一遍，更新询问的答案。这样是O(nlogn+q)。 还有，对于每个标记，还要记录是l-1还是r，因为l-1的答案还要带一个负号。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 54444 #define mod 201314 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) class Graph //这个是图。跳到60行 //如果你有个IDE，那么直接折叠起来好了 &#123; public: int head[N]; int EdgeCount; struct Edge &#123; int To,Label,Next; &#125;Ed[N&lt;&lt;3]; void clear() &#123; memset(head,-1,sizeof(head)); memset(Ed,-1,sizeof(Ed)); EdgeCount=0; &#125; void AddEdge(int u,int v,int w=1) &#123; ++EdgeCount; Ed[EdgeCount]=(Edge)&#123;v,w,head[u]&#125;; head[u]=EdgeCount; &#125; void Add2(int u,int v,int w=1) &#123; AddEdge(u,v,w);AddEdge(v,u,w); &#125; int Start(int u) &#123; return head[u]; &#125; int To(int u) &#123; return Ed[u].To; &#125; int Label(int u) &#123; return Ed[u].Label; &#125; int Next(int u) &#123; return Ed[u].Next; &#125; &#125;G; class SegmentTree //这个是线段树。支持区间加Add(l,r,x)，还有区间求和Query(l,r)。 //如果您会，跳到138行. &#123; public: struct node &#123; int l,r; int s,a; &#125;tree[N&lt;&lt;2]; #define ls index&lt;&lt;1 #define rs index&lt;&lt;1|1 #define L tree[index].l #define R tree[index].r #define S tree[index].s #define A tree[index].a #define lL tree[ls].l #define lR tree[ls].r #define lS tree[ls].s #define lA tree[ls].a #define rL tree[rs].l #define rR tree[rs].r #define rS tree[rs].s #define rA tree[rs].a void Update(int index=1) &#123; S=(lS+rS)%mod; &#125; void Build(int l,int r,int index=1) &#123; L=l,R=r; if (l==r) &#123; S=0;return; &#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,ls); Build(mid+1,r,rs); Update(index); &#125; void AddOne(int x,int index=1) &#123; A+=x; S+=(R-L+1)*x; A%=mod,S%=mod; &#125; void PushDown(int index=1) &#123; if (A) &#123; AddOne(A,ls); AddOne(A,rs); A=0; &#125; &#125; void Add(int l,int r,int x,int index=1) &#123; if (l&gt;R or L&gt;r) return; if (l&lt;=L and R&lt;=r) return AddOne(x,index); PushDown(index); Add(l,r,x,ls); Add(l,r,x,rs); Update(index); &#125; int Query(int l,int r,int index=1) &#123; if (l&gt;R or L&gt;r) return 0; if (l&lt;=L and R&lt;=r) return S; PushDown(index); return (Query(l,r,ls)+Query(l,r,rs))%mod; &#125; &#125;T; int n,q; struct node //一个询问 &#123; int l,r,z; &#125;Q[N]; vector&lt;int&gt; idl[N],idr[N]; //l-1和r分开记录 bool cxk[N]; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n),R1(q); G.clear(); F(i,2,n) &#123; int fa;R1(fa);++fa; //我们从1开始编号 G.Add2(i,fa); &#125; F(i,1,q) &#123; int l,r,z; R1(l),R1(r),R1(z); ++l,++r,++z; Q[i]=(node)&#123;l,r,z&#125;; cxk[l-1]=cxk[r]=1; //记录该点是否有标记 idl[l-1].push_back(i); idr[r]. push_back(i); //记录标记 //标记存询问的编号.询问中的l,r,z只要一个编号就都能获取了. &#125; &#125; int deep[N],size[N],fa[N],son[N]; //如果您会树剖,跳到218行 //这里两个DFS都是没有改过的模板 void DFS(int u,int f) &#123; deep[u]=(u==f)?1:deep[f]+1; size[u]=1; fa[u]=f; son[u]=-1;int Max=-1; Tra(i,u) &#123; int v=__v; if (v!=f) &#123; DFS(v,u); size[u]+=size[v]; if (size[v]&gt;Max) &#123; Max=size[v]; son[u]=v; &#125; &#125; &#125; &#125; int DFSid[N],Time=0; int top[N]; void DFS2(int u,int topu) &#123; top[u]=topu; DFSid[u]=++Time; if (son[u]==-1) return; DFS2(son[u],topu); Tra(i,u) &#123; int v=__v; if (v!=son[u] and v!=fa[u]) &#123; DFS2(v,v); &#125; &#125; &#125; //DFS1和DFS2是树剖用的函数 void PathAdd(int u,int v) //u到v的链上点权+1 &#123; while(top[u]!=top[v]) &#123; if (deep[top[u]]&lt;deep[top[v]]) swap(u,v); T.Add(DFSid[top[u]],DFSid[u],1); u=fa[top[u]]; &#125; if (deep[u]&gt;deep[v]) swap(u,v); T.Add(DFSid[u],DFSid[v],1); &#125; int PathQuery(int u,int v) //询问u到v上点权的和 &#123; int ans=0; while(top[u]!=top[v]) &#123; if (deep[top[u]]&lt;deep[top[v]]) swap(u,v); ans+=T.Query(DFSid[top[u]],DFSid[u]); u=fa[top[u]]; &#125; if (deep[u]&gt;deep[v]) swap(u,v); ans+=T.Query(DFSid[u],DFSid[v]); return ans; &#125; //核心代码 int ans[N]; //ans[i]: 第i个询问的答案 void Soviet() &#123; DFS(1,1); DFS2(1,1); T.Build(1,n); //记得建树 F(i,1,n) &#123; PathAdd(1,i); //从i到根(1)+1 if (cxk[i]) //如果有标记 &#123; F(j,0,(int)idl[i].size()-1) &#123; int id=idl[i][j]; ans[id]-=PathQuery(1,Q[id].z); //l-1的询问答案是减掉的 ans[id]%=mod; &#125; F(j,0,(int)idr[i].size()-1) //r的答案是加上的 &#123; int id=idr[i][j]; ans[id]+=PathQuery(1,Q[id].z); ans[id]%=mod; &#125; &#125; &#125; F(i,1,q) &#123; printf("%d\n",(ans[i]%mod+mod)%mod); &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>转换思维</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1296 & 洛谷4158 [SCOI2009]粉刷匠 题解]]></title>
    <url>%2F2020%2F02%2F10%2Fbzoj-1296-%E6%B4%9B%E8%B0%B74158-SCOI2009-%E7%B2%89%E5%88%B7%E5%8C%A0-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述一个$n\times m$的矩阵，每个位置珂能是粉色（0表示）或者是蓝色（1表示），然后你珂以对同一行里连续一段长度的区间染上一种颜色（覆盖型），你能染$t$次，每次不限长度。求你染到的正确的颜色的个数最多是多少。 思路框架$f[i][j]$表示前$i$行染$j$次最大染色个数。$g[i][j][k]$表示第$i$行染$j$次只考虑前$k$个格子最大方案。 具体思路$DP$题分两步，设状态，求转移。 多数题目是状态不好设的。像这个题就是，我想了好久没想出来状态怎么设，看一下题解知道状态怎么设之后就是秒切。那么，我们这个题也是分两块来讲。 Part 1. 状态首先$f$是很好想的。答案就是$f[n][i] (i\in [1,t])$中的最大值。 然后我们来求$f[i][j]$的转移。求着求着发现，我们先要枚举一个$k$，$k$小于$j$。转移的一部分就是$f[n-1][j-k]$，就是上一行染$j-k$次。还有$k$次留给这一行。所以我们要加上一个数，这个数就是：第$i$行中染$k$次正确染色的最大值。 然后我们来求这个子问题。 Part 1.1 子问题的状态设$g[i][j]$表示第$i$行染$j$次的答案。考虑转移。。。转你妈，缺状态。观察数据也能轻易发现，应该是$O(nmt)$的算法，然后$O(nt)$过是什么鬼，肯定还缺一维。 缺什么状态呢。我们发现，还和染到了那里有关。不妨再加上一个$k$，表示我们考虑到第$k$个位置。 Part 1.2 子问题的转移然后就来推转移了。像这种有“考虑到第xxx个位置”为一个状态的$DP$，通常我们用枚举断点作转移。枚举断点$q$（我真的没名字了，$i,j,k$都用过了，就叫$q$了，随便一点）。由定义，$q$小于$k$。还有一个注意点，$q$是能取$0$的。其原因是，我习惯枚举的是$q$把区间分成$[0,q]$和$[q+1,k]$。显然，$q$取$0$时也有意义。 然后我们要看$[q+1,k]$中是蓝色多还是粉色多，哪个多我们就染那种颜色。这样显然是对的。然后我们只要维护一个前缀和出来，维护每一行内蓝色的前缀和，记为$sum$。看是 $sum[i][k]-sum[i][q]$大，还是$(k-q)-(sum[i][k]-sum[i][q])$大。设这两个的最大值为$S$。 那么$g[i][j][k]=max(g[i][j-1][q]+S)$。 Part 1.3 时间复杂度？看起来状态数是$O(nmt)$，转移数是$O(m)$，复杂度$O(nm^2t)$。但是，$g$的第二维，即染了$j$次那一维中，显然$j$不会超过$m$。因为这一行最多就$m$个数，染$m$次啥事都解决了。所以复杂度应该是$O(nm^3)$，即$O(50^4)$。稳过。 子问题完毕Part 2. 转移好了，回到主线。有了$g$之后，就珂以得到$f$的转移： $f[i][j]=max(f[i-1][j-k]+g[i][k][m]) $（哎哟这个式子不要太显然，我真的不想解释了） （$Part2$比$Part1$短很多，说明这个题重点在设状态，是个毒瘤题） 代码 （精髓）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 61 #define T 2602 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n,m,t; int sum[N][N];char mp[N][N]; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n),R1(m),R1(t); F(i,1,n) &#123; scanf("%s",mp[i]+1); sum[i][0]=0; F(j,1,m) &#123; if (mp[i][j]=='1') sum[i][j]=sum[i][j-1]+1; else sum[i][j]=sum[i][j-1]; &#125; &#125; &#125; int f[N][T],g[N][T][N]; void Soviet() &#123; F(i,1,n) F(j,1,t) F(k,1,m) F(q,0,k-1) &#123; int ss=sum[i][k]-sum[i][q]; int S=max(ss,(k-q)-ss); g[i][j][k]=max(g[i][j][k],g[i][j-1][q]+S); &#125; F(i,1,n) F(j,1,t) F(k,0,min(j,m)) f[i][j]=max(f[i][j],f[i-1][j-k]+g[i][k][m]); printf("%d\n",*max_element(f[n]+1,f[n]+t+1)); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder agc35c(5140) Skolem XOR Tree 题解]]></title>
    <url>%2F2020%2F02%2F10%2FAtcoder-agc35c-5140-Skolem-XOR-Tree-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个$n&lt;=1e5$，构造一颗$2n$个节点的数。其中，点$i$和$i+n$上都带点权$i$，并且满足：对于$1&lt;=i&lt;=n$，$i$到$i+n$的路径上（包括两端点），所有点权的异或和为$i$。 举例：i=3，构造图如下：其中，4,5,6的点权分别是1,2,3。不难验证，满足题设条件。 如果无解，输出No。 思路当且仅当$n=2^x$时，无解。（x为自然数） 先构造一个上面样例的图。 然后，如这个图所示：。如果$n$是奇数，就把$(4,5)$，$6,7$，$8,9$…$(n-1,n)$都按这样的构造，连接到点$1+n$上就珂以了。如果$n$是偶数，先把前$n-1$个点按照这样的方式构造一颗树。然后考虑$n$和$2n$。找到比$n$小的最大的$2$的幂$p$，显然，$p-&gt;1-&gt;(n^p^1)$，这条路径的异或和为$n$。并且，这条路径存在（已证）。那么，我们把$n$链接到$p$上，把$2n$链接到$n^p^1$上，即珂。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Rd(int cnt,...) &#123; va_list args; va_start(args,cnt); F(i,1,cnt) &#123; int* x=va_arg(args,int*);R1(*x); &#125; va_end(args); &#125; int n; void Input() &#123; R1(n); &#125; void Add(int u,int v)&#123;printf("%d %d\n",u,v);&#125; void Soviet() &#123; F(i,0,20) if ((1&lt;&lt;i)==n) &#123; puts("No");return; &#125; puts("Yes"); Add(1,2); Add(2,3); Add(3,n+1); Add(n+1,n+2); Add(n+2,n+3); Fs(i,5,n,i+=2) &#123; Add(1+n,i); Add(i,i-1); Add(1+n,i-1+n); Add(i-1+n,i+n); &#125; if (n%2==0) &#123; int p2; F(i,0,20) if ((1&lt;&lt;i)&lt;n) p2=(1&lt;&lt;i); Add(n,p2+n); Add(2*n,n^p2^1); &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder 2649 11 题解]]></title>
    <url>%2F2020%2F02%2F10%2FAtcoder-2649-11-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述长度为n+1的序列a.其中[1..n]每个数都至少出现一次. （n&lt;=1e5）,对每个k从1到n+1，询问长度为k的不同的子序列有多少个?答案膜10^9+7 （所以你要输出n+1行） （又是蒯的） 思路框架对于每个k：显然有且仅有一个数字出现两次。找到这两个位置，设为p1,p2，然后答案就是C_{n+1}^{k}-C_{n-p2+p1}^{k-1} 具体思路首先，如果我们没有那个重复的式子，显然答案是C_{n+1}^k。但是我们还有两个相同的数字，就珂能会引起重复的计算。 分类讨论长度为k的区间的包含情况： 包含了两个重复数字：这种情况显然没有相同的区间。不管就是了 没有包含两个重复数字：同上 只包含一个：枚举i从0到k-1，求和C_{p1-1}^{i}\times C_{n+1-p2}^{k-i+1}（前面选一些，后面选一些，求和，就是会重复的了）然后我们用组合恒等式优化一下，得到：所有的和=C_{p1-1+n-p2+1}^{k-1}，然后一个+1一个-1抵消了，变成C_{n-p2+p1}^{k-1}。 实现注意 预处理阶乘和阶乘逆元求组合数，这样快 开longlong 使用STL加快写代码速度 使用异或求出重复的数字，就不用谢很长的代码了（重复数字=原序列的异或和 ^ 1~n的异或和） 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define int long long #define mod 1000000007 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n,a[N]; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n); F(i,1,n+1) R1(a[i]); &#125; int fac[N],ifac[N]; int qpow(int a,int b,int m) &#123; int r=1; while(b) &#123; if (b&amp;1) r=r*a%mod; a=a*a%mod,b&gt;&gt;=1; &#125; return r; &#125; int C(int n,int m) &#123; if (n&lt;m) return 0; return fac[n]*ifac[m]%mod*ifac[n-m]%mod; &#125; void Soviet() &#123; fac[0]=1; F(i,1,n+1) fac[i]=fac[i-1]*i%mod; ifac[n+1]=qpow(fac[n+1],mod-2,mod); D(i,n,0) ifac[i]=ifac[i+1]*(i+1)%mod;//预处理阶乘和阶乘逆元 int twice=0; //twice=xorsum(a[1~n+1])^xorsum(1~n) F(i,1,n+1) twice^=a[i]; F(i,1,n) twice^=i; int pos,pos2; pos=find(a+1,a+n+1,twice)-a;//STL的find函数，在一段区间中找到一个指针 pos2=find(a+pos+1,a+n+1,twice)-a; int num=(n-pos2+1)+(pos-1); F(i,1,n+1) &#123; int overlap=C(num,i-1); int ans=C(n+1,i)-overlap; ans=(ans%mod+mod)%mod; printf("%lld\n",ans); &#125; &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder 1218 bzoj 4240 libreoj 2873 「JOISC 2014 Day1」有趣的家庭菜园 题解]]></title>
    <url>%2F2020%2F02%2F10%2FAtcoder-1218-bzoj-4240-libreoj-2873-%E3%80%8CJOISC-2014-Day1%E3%80%8D%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AE%B6%E5%BA%AD%E8%8F%9C%E5%9B%AD-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个序列a，长度为n(=所有左边的元素，要么它>=所有右边的元素。（形象的说，就是一个山峰）输出最少的交换次数。记得开longlong。 思路倒序排序，一个一个插入，判断是插入在左边还是插入在右边，记录逆序对个数，求出答案 具体思路这个问题看起来不好直接求。确实，这种题如果第一次做的话，是很难想到做法的。 首先确定这样一个东西：交换次数=把原序列看成\{1,2,3...n\}之后交换得到的逆序对数。 然后我们要让这个值最小。接下来就是如何求这个最小了。 有这样一个模型，像这种要么左边，要么右边的题目，我们珂以这样考虑： 将a序列倒序 初始序列为空 考虑我们新加入的元素a[i]在最左边还是最右边，插入进去 正确性是显然的。由于我们在插入a[i]的时候，所有数都是>=a[i]的。所以我们不管插入在左边还是右边，还是能构成一个“山峰”。只不过是左边长还是右边长的问题了。 我们开一个结构体，把每个数按值（设为v_i）排序，然后还要保留原来的位置（方便统计逆序数，设为p_i）。 那么我们把a_i插入在序列的最左边，花费就是新加入的逆序对数，也就是j\in [1,i-1]中满足p_jp_i的j的个数。第一个很明显珂以用树状数组记录，设答案为s。那么第二个就不用再去记录了，就是i-1-x。i-1是数字的总数，由于p_i显然不会有相等的情况，所以总数-小于的就是大于的。 然后比较一下是s大还是i-1-s大即珂，记录到答案。 注意，如果有连续的一段a_i相等的话，那么要记得判一下。如果不判的话，我们就要记录一些类似“交换两个相同的数”的无用功了，就不一定最小。我们原来那个算法几乎完全是基于数值v_i进行插入判断的，p_i只是起到答案的作用。所以即使是相同的v_i，由于p_i不同，我们也会认为这是不一样的数，然后还会记录答案。这很明显是不必要的。 实现注意千万不要忘了开long long！！！千万不要忘了开long long！！！千万不要忘了开long long！！！千万不要忘了开long long！！！千万不要忘了开long long！！！ 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define int long long #define N 355555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) class BIT &#123; public: int tree[N]; int len; void BuildTree(int _len) &#123; len=_len; FK(tree); &#125; void Add(int pos,int val=1) &#123; for(int i=pos;i&lt;=len;i+=(i&amp;(-i))) &#123; tree[i]+=val; &#125; &#125; int Query(int pos) &#123; int ans=0; for(int i=pos;i&gt;0;i-=(i&amp;(-i))) &#123; ans+=tree[i]; &#125; return ans; &#125; &#125;T; struct node &#123; int h,pos; &#125;a[N]; bool operator&lt;(node a,node b)&#123;return a.h&gt;b.h;&#125; int n; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n); F(i,1,n) &#123; R1(a[i].h); a[i].pos=i; &#125; &#125; void Soviet() &#123; sort(a+1,a+n+1); T.BuildTree(n); int j; int ans=0; F(i,1,n) &#123; j=i; while(a[j].h==a[j+1].h and j&lt;n) ++j; F(k,i,j) ans+=min(T.Query(a[k].pos),i-1-T.Query(a[k].pos)); F(k,i,j) T.Add(a[k].pos); i=j; &#125; printf("%lld\n",ans); &#125; void IsMyWife() &#123; Input(); Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;2]]></content>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 2206 低买高卖 题解]]></title>
    <url>%2F2020%2F02%2F10%2F51nod-2206-%E4%BD%8E%E4%B9%B0%E9%AB%98%E5%8D%96-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述股票市场一共$n&lt;=2e5$天，每天股票价格是$a_i$。你开始有正无穷的钱，每天珂以买/卖一个单位的股票，也珂以吊也不干。求最大利润（净赚）。 思路弄一个priority_queue，对于第$i$天，选择之前最便宜的一天买来，然后今天卖了。 但显然这样不一定最优，我们需要一个反悔的系统，珂以让我们撤销一次操作。 考虑到$(a-b)+(b-c)=a-c$。那么，只要存在两个$b$，就珂以相当于撤回了之前做的生意。 所以，我们每次枚举到一个点，就把它入队列两次即珂。入完队列之后，取最小的做交易。注意开long long 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1666666 #define int long long #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int n; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; Q; void Input_Soviet() &#123; R1(n); int ans=0; F(i,1,n) &#123; int x;R1(x); Q.push(x); Q.push(x); ans+=x-Q.top();Q.pop(); &#125; printf("%lld\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input_Soviet(); &#125; #undef int //long long &#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 1963 树上NIM游戏 题解]]></title>
    <url>%2F2020%2F02%2F10%2F51nod-1963-%E6%A0%91%E4%B8%8ANIM%E6%B8%B8%E6%88%8F-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述多组数据，每次给定一个有$n(&lt;=3e5,\sum n&lt;=1e6)$个节点的树，每个点有点权。两个人玩$Nim$游戏，两人轮流操作。每次操作，珂以把一个点上$&gt;=1$个点权移动到父亲上，如果有一个不能操作了，这个人就输了。判断先手是否会赢。 思路框架深度为奇数的点权异或起来，如果非0，先手必胜。 具体思路首先我们要把这个问题转换成$Nim$游戏。 然后我们要知道一个模型，叫阶梯$Nim$游戏。其规则和这个题类似，只不过是序列上的问题，每个点$i$珂以把$&gt;=1$个点权移动到$i-1$位置上。 然后这个问题的解，就是把奇数位置异或起来，非零则先手必胜。 知道这个之后，转换成树上，水的鸭皮。 但是如何证明这个序列上的问题呢？ 证明 先手必胜 此时先手就会逼迫后手进行Nim游戏。先手最理想的$Nim$游戏是，先手只动奇数的位置，那么这个结论就是成立的。但是后手显然不会傻傻的让先手玩$Nim$游戏，动了偶数位置，那么先手只要把后手移动的这堆再往前移动一个位置，那就没有区别了。这就是先手的“逼迫”过程。这样，后手没有办法，只能乖♂乖玩$Nim$游戏，等死了。 后手必胜 同上，后手会逼迫先手进行$Nim$游戏。先手动偶数位置，后手只要再动一次即珂。所以，和上面类似，先手也只能等死了。 证毕然后这个题就被切了。 实现注意 题目中有说fa[i]小于i，所以我们连搜都不用搜，倒着循环一遍即珂 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1666666 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int n; int fa[N]; int val[N]; void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; void Input() &#123; R1(n); F(i,1,n-1) R1(fa[i]); F(i,0,n-1) R1(val[i]); &#125; int deep[N];//deep%2 void Soviet() &#123; F(i,1,n-1) deep[i]=deep[fa[i]]^1; int s=0; F(i,0,n-1) if (deep[i]) s^=val[i];//奇数位置异或和 puts(s?"win":"lose");//非零则先手赢 &#125; #define Flan void Flan IsMyWife() &#123; int t;R1(t); while(t--) &#123; Input(); Soviet(); &#125; &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 1554 欧姆诺姆和项链 题解]]></title>
    <url>%2F2020%2F02%2F10%2F51nod-1554-%E6%AC%A7%E5%A7%86%E8%AF%BA%E5%A7%86%E5%92%8C%E9%A1%B9%E9%93%BE-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个长度为n(]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>next数组</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 1524 可除图的最大团 题解]]></title>
    <url>%2F2020%2F02%2F10%2F51nod-1524-%E5%8F%AF%E9%99%A4%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%9B%A2-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述有一个长度为$n$的序列$a$，$n&lt;=1e6$。根据这个序列生成一个无向图：若$a[u]$和$a[v]$中一个是另一个的倍数，那么$u$到$v$连一条无向边。请你求出这个图的最大团（最大子完全图）。 思路框架设$dp[i]$表示以$i$为最小值的图的最大团。先dp[i]=1，然后dp[i的倍数]=max(dp[i的倍数]，dp[i])即珂。这样更新是O(n/1+n/2…+n/n)=O(nlogn)的。（关于这个，自己百度“调和级数”，看它减去nlogn的收敛性）。 具体思路为什么我们能想到这样的dp呢？首先，如果$a$到$b$有连边，$b$到$c$有连边，那么$a$到$c$也有连边。同理推得，我们只要找到一条递增的链使得长度最长即珂。因为只要有一条链，那就肯定有一张完全图。 然后最长链问题，就直接DP出来了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 1666666 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; int n,a[N]; void Input() &#123; R1(n);F(i,1,n) R1(a[i]); &#125; int dp[N]; void Soviet() &#123; sort(a+1,a+n+1); FK(dp); F(i,1,n) &#123; dp[a[i]]++; Fs(j,2*a[i],1000000,j+=a[i]) &#123; dp[j]=max(dp[j],dp[a[i]]); &#125; &#125; printf("%d\n",*max_element(dp+1,dp+1000001)); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>图论</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 1464 半回文 题解]]></title>
    <url>%2F2020%2F02%2F10%2F51nod-1464-%E5%8D%8A%E5%9B%9E%E6%96%87-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述一个字符串S，长度5000（时间空间都够平方做），只有’a’和’b’两个字符组成。一个字符串A是“半回文”的，当且仅当，对于所有的奇数$i&lt;=(|A|+1)/2$，满足A的正数第$i$个和$A$的倒数第$i$个相等。 请你求出，$S$的所有半回文的子串中，字典序排序第$k$位的是哪个。 思路框架$dp$求出哪些子串是半回文的，加入到TRIE树中，用类似二叉查找树的方法找到第$k$个即珂。 具体思路$dp[l][r]$表示$[l,r]$这一段子串是否是“半回文”的。如果$s[l]==s[r]$，才有珂能半回文，否则直接设为$0$。 如果l+2&gt;=r-2，那么只需要满足$s[l]==s[r]$，就是半回文了。否则，还需要使$dp[l+2][r-2]$为真，$dp[l][r]$才为真。 然后TRIE树上记录一个子树和。设指向字符’a’的是左儿子，’b’是右儿子。由于’a’的字典序小于’b’，所以，如果左儿子的size&lt;=k，那么第$k-num[leftson]$个就在左子树里面。否则，就在右子树里面找第$k-num[rightson]$即珂。其中$num[u]$表示节点$u$是否表示一个半回文串。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 5333 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) char s[N]; int k;int n; void Input() &#123; scanf("%s%d",s+1,&amp;k); n=strlen(s+1); &#125; class Trie //TRIE树 &#123; public: int num[N*1000];int T[N*1000][2];int cnt; //开个N*1000就够了 bitset&lt;N&gt; dp[N];int Max[N]; //bitset节省空间，大约是除以一个32的常数，因为其利用率高 void Init() &#123; cnt=0; D(i,n,1) &#123; dp[i][i]=1;Max[i]=i; F(j,i+1,n) &#123; if (s[i]==s[j]) &#123; if (i+2&gt;=j-2) dp[i][j]=1; else dp[i][j]=dp[i+2][j-2]; &#125; if (dp[i][j]) Max[i]=max(Max[i],j); //Max[i]: 最远的j满足dp[i][j]=1 &#125; &#125; &#125; void Insert(int l,int r) &#123; int pos=0; F(i,l,r) &#123; int id=s[i]-'a'; if (T[pos][id]==0) T[pos][id]=++cnt; if (dp[l][i]) num[T[pos][id]]++; //暴力插入，反正平方能做 pos=T[pos][id]; &#125; &#125; string ans; void DFS(int u) &#123; string tmp=ans; if (k&gt;0 and T[u][0]) &#123; k-=num[T[u][0]]; ans+='a'; DFS(T[u][0]); &#125; if (k&gt;0 and T[u][1]) &#123; ans=tmp; k-=num[T[u][1]]; ans+='b'; DFS(T[u][1]); &#125; &#125; &#125;T; void Soviet() &#123; T.Init(); F(i,1,n) T.Insert(i,T.Max[i]); T.DFS(0); printf("%s\n",T.ans.c_str()); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>思维</tag>
        <tag>DP</tag>
        <tag>TRIE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 1395 两个回文 题解]]></title>
    <url>%2F2020%2F02%2F10%2F51nod-1395-%E4%B8%A4%E4%B8%AA%E5%9B%9E%E6%96%87-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述多组数据。每次给定一个字符串$S$，$|S|&lt;=1e5$，请从$S$中选择两个不相交的回文子串使得这两个子串的长度和最大。 思路框架对于每个位置，求出前缀和后缀中最长回文子串。然后枚举断点，更新答案。 具体思路首先考虑如何求出前缀和后缀中的最长回文子串。 然后我们珂以先求最长回文后缀（简称$LPS$，即$Longest Palindrome Suffix$）和最长回文前缀（简称$LPP$，即$Longest Palindrome Prefix$）。$LPS[i]$表示以$i$为结尾的前缀的最长回文后缀，$LPP[i]$表示以$i$开头的后缀的最长回文前缀。然后，只要求$LPS$的前缀最大值，$LPP$的后缀最大值，就是前缀/后缀中的最长回文子串了。 $LPP$和$LPS$都很好求，就是回文自动机的板子。正着跑一遍求出$LPS$，反着跑一遍求出$LPP$。 原地修改前缀/后缀最大值。然后用$LPS[i]+LPP[i+1]$更新答案即珂。这个式子的含义是：一个回文子串在$i$左边，一个回文子串在$i$右边，也就是上文说的“枚举断点”。 提示代码很长，从Soviet函数开始看代码哦，这样方便理清结构。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 155555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) char s[N];int n; void Input() &#123; scanf("%s",s+1);n=strlen(s+1); &#125; class Palindrome_Tree &#123; public: char s[N]; struct node &#123; int len,fail; int ch[26]; &#125;t[N]; node&amp; operator[](int id)&#123;return *(t+id);&#125; int last; int cnt=1; void Init(char ss[N]) &#123; FK(t); strcpy(s+1,ss+1); t[0].len=0;t[0].fail=1; t[1].len=-1;t[1].fail=0; cnt=1; last=0; &#125; int Getfail(int fa,int pos) &#123; int cur=t[fa].fail; for(;s[pos]!=s[pos-t[cur].len-1];cur=t[cur].fail); int id=s[pos]-'a';return t[cur].ch[id]; &#125; void Insert(int pos) &#123; int cur=last; while(s[pos-t[cur].len-1]!=s[pos]) &#123; cur=t[cur].fail; &#125; int id=s[pos]-'a'; if (t[cur].ch[id]==0) &#123; ++cnt; t[cnt].len=t[cur].len+2; t[cnt].fail=Getfail(cur,pos); t[cur].ch[id]=cnt; &#125; last=t[cur].ch[id]; &#125; &#125;T; //普通的回文自动机 int LPS[N],LPP[N]; void Soviet() &#123; FK(LPS),FK(LPP); T.Init(s);F(i,1,n) T.Insert(i),LPS[i]=T[T.last].len;//正着跑一遍求出LPS，以i结尾的前缀的最长回文后缀 reverse(s+1,s+n+1); T.Init(s);F(i,1,n) T.Insert(i),LPP[n-i+1]=T[T.last].len; //反着跑一遍LPP，以i开始的后缀的最长回文前缀 F(i,1,n) LPS[i]=max(LPS[i],LPS[i-1]); //以i结尾的前缀的最长回文子串 D(i,n,1) LPP[i]=max(LPP[i],LPP[i+1]); //以i开头的后缀的最长回文子串 int ans=0; F(i,1,n-1) ans=max(ans,LPS[i]+LPP[i+1]);//枚举断点 printf("%d\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; int t;cin&gt;&gt;t; while(t--) &#123; Input(); Soviet(); &#125; &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 1277 字符串中的最大值 题解]]></title>
    <url>%2F2020%2F02%2F10%2F51nod-1277-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定一个长度]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>next数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 1191 消灭兔子 题解]]></title>
    <url>%2F2020%2F02%2F10%2F51nod-1191-%E6%B6%88%E7%81%AD%E5%85%94%E5%AD%90-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述有一些箭，每个箭有伤害和价钱两种属性。还有一些兔子，每个兔子有一些血量。两个的数量都是2e5规模。如果一个箭的伤害值大于某个兔子的血量值，那么这个箭就能杀死这只兔子。请你用最少的钱杀死所有的兔子。不行输出NO。 思路框架很明显，对于一只兔子，我们要找能杀死它的箭中最便宜的那个。优先队列维护。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 255555 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i)) #define p_b push_back #define sz(a) ((int)a.size()) #define iter(a,p) (a.begin()+p) void R1(int &amp;x) &#123; x=0;char c=getchar();int f=1; while(c&lt;'0' or c&gt;'9') f=(c=='-')?-1:1,c=getchar(); while(c&gt;='0' and c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=(f==1)?x:-x; &#125; struct node&#123;int d,p;&#125;a[N]; bool operator&lt;(node a,node b)&#123;return a.p&gt;b.p;&#125; bool cmp_d_down(node a,node b)&#123;return a.d&gt;b.d;&#125; int n,m; int b[N]; void Input() &#123; R1(n),R1(m); F(i,1,n) R1(b[i]); F(i,1,m) R1(a[i].d),R1(a[i].p); &#125; priority_queue&lt;node&gt; Q; void Soviet() &#123; sort(b+1,b+n+1,greater&lt;int&gt;()); //b降序排序 sort(a+1,a+m+1,cmp_d_down); //a按照伤害值降序排序 int p=1; //最远的能杀死当前兔子的坐标。按照上面的排序方法，p应该是单调递增的。 int ans=0; F(i,1,n) &#123; while(p&lt;=m and a[p].d&gt;=b[i]) Q.push(a[p]),++p; //把所有满足条件的扔进优先队列，然后取p最小的 if (Q.empty()) return (void)puts("No Solution"); //如果找不到了，就无解了 ans+=Q.top().p;Q.pop(); &#125; printf("%d\n",ans); &#125; #define Flan void Flan IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 3966 libreoj10060 [TJOI2013]单词 题解]]></title>
    <url>%2F2019%2F09%2F13%2F%E6%B4%9B%E8%B0%B7-3966-libreoj10060-TJOI2013-%E5%8D%95%E8%AF%8D-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题意简述给定n个单词，对每个单词求出n个单词中总共包含多少这个单词（自己也算，也就是说答案至少为1）。比如三个单词分别是a,aa,aaa，那么aa出现3次（自己一次，aaa中两次）。 思路每个字符接在一起，中间插入一个特殊字符，然后跑一遍AC自动机即珂。 具体的思维过程AC自动机的模板问题：给定一个文本串，和一些模式串，求每个模式串在文本串中出现了多少次。 实际上我们珂以把这个问题转化成模板问题。由于我们的匹配不能跨单词，只能限于每个单词之间。最好的解决方法就是构造这样的情况：跨单词肯定得失配。 这好办，只要把所有单词接在一起，然后在中间加一个特殊字符，使得它不等于[a,z]中的任意一个，那跨单词的时候肯定就失配了（因为模式串中只有[a,z]）比如说设成ASCII中的字符'z'+1，经验证，这个字符是左大括号\{。然后写AC自动机的时候，就当字母有27个字母去建树即珂。这题就被完美的套成了模板解决了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;using namespace std;namespace Flandre_Scarlet&#123; #define N 212345 #define F(i,l,r) for(int i=l;i&lt;=r;++i) #define D(i,r,l) for(int i=r;i&gt;=l;--i) #define Fs(i,l,r,c) for(int i=l;i&lt;=r;c) #define Ds(i,r,l,c) for(int i=r;i&gt;=l;c) #define Tra(i,u) for(int i=G.Start(u);~i;i=G.Next(i)) #define MEM(x,a) memset(x,a,sizeof(x)) #define FK(x) MEM(x,0) int id[N]; class AC_Automaton &#123; public: int tr[N][27]; int tot; void Init() &#123; FK(tr); tot=1; &#125; int Insert(char s[]) &#123; int pos=1; F(i,0,INT_MAX) &#123; if (!s[i]) break; int c=s[i]-'a'; if (!tr[pos][c]) &#123; tr[pos][c]=++tot; &#125; pos=tr[pos][c]; &#125; return pos; &#125; int fail[N]; queue&lt;int&gt; Q; vector&lt;int&gt; G[N];void Add(int u,int v)&#123;G[u].push_back(v);&#125; void BuildFail() &#123; while(!Q.empty()) Q.pop(); F(i,0,26) tr[0][i]=1; Q.push(1); while(!Q.empty()) &#123; int u=Q.front();Q.pop(); F(i,0,26) &#123; if (tr[u][i]) &#123; fail[tr[u][i]]=tr[fail[u]][i]; Q.push(tr[u][i]); &#125; else tr[u][i]=tr[fail[u]][i]; &#125; &#125; F(i,2,tot) Add(fail[i],i); &#125; int size[N]; void DFS(int u) &#123; F(i,0,(int)G[u].size()-1) &#123; int v=G[u][i]; DFS(v); size[u]+=size[v]; &#125; &#125; void Query(char s[]) &#123; int pos=1; F(i,0,INT_MAX) &#123; if (!s[i]) break; int c=s[i]-'a'; pos=tr[pos][c]; ++size[pos]; &#125; DFS(1); &#125; &#125;AC; int n; char s[N]; char T[N*10]; void Input() &#123; scanf("%d",&amp;n); AC.Init(); FK(T); F(i,1,n) &#123; scanf("%s",s); id[i]=AC.Insert(s); strcat(T,s); strcat(T,"&#123;");//'&#123;'='z'+1 &#125; &#125; void Soviet() &#123; // printf("T=%s\n",T); AC.BuildFail(); AC.Query(T); F(i,1,n) &#123; printf("%d\n",AC.size[id[i]]); &#125; &#125; void IsMyWife() &#123; Input(); Soviet(); &#125;&#125;int main()&#123; Flandre_Scarlet::IsMyWife(); getchar();getchar(); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记 神奇的根号]]></title>
    <url>%2F2019%2F09%2F09%2F%E7%AC%94%E8%AE%B0-%E7%A5%9E%E5%A5%87%E7%9A%84%E6%A0%B9%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[还是第一次写这样的笔记呢。。。开博客以来出来在写简介，就是在写题解。像这样的笔记还是第一次写。不过大家应该都会那种算法的笔记，除非写的特别好（像BYVoid神仙那样），不然基本上也没啥用。不过，这篇不一样，因为它讲的是一个很有意思的根号算法。不过我估计我应该会一直整理这个的。 根号思路1.第一个思路是我在考场上想出来的。链接：这个题 当然，我发现大家可能看不了这个题。这里给大家我在这个OJ上的账号： 用户名：LightningUZ密码： 123456 但是请不要修改密码，如果修改了请快速改回来。注意，你修改密码是不会影响到我的，顶多就是和老师说一下，换一个账号即可，很简单的。但是会不方便别的同学进行练习，而且以后有比赛了也得再换一个号上来交，很麻烦，浪费时间。 如果您不想交，只想看思路，那好，我贴张图上来： 这个题是hlx学长（清华爷，网名Fuxey）给我们出的。当时他讲题的时候说的正解绝对不是带根号的。但是我考场上就是想到了一个带根号的做法（准确来讲不是带根号吧。。。因为没有控制好平衡）； 当时我先打了一个暴力分。如果r-l+1]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>神奇的根号</tag>
      </tags>
  </entry>
</search>
