<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flandre Scarlet 的小屋</title>
  
  <subtitle>LightningUZ 的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lightninguz2.github.io/"/>
  <updated>2020-05-04T13:54:04.861Z</updated>
  <id>https://lightninguz2.github.io/</id>
  
  <author>
    <name>LightningUZ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>exkmp 笔记</title>
    <link href="https://lightninguz2.github.io/2020/05/04/exkmp-%E7%AC%94%E8%AE%B0/"/>
    <id>https://lightninguz2.github.io/2020/05/04/exkmp-笔记/</id>
    <published>2020-05-04T13:07:22.000Z</published>
    <updated>2020-05-04T13:54:04.861Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>exkmp 用于求解这样的问题：</p><p>求文本串 $T$ 的每一个后缀与模式串 $M$ 的匹配长度（即最长公共前缀长度）。特别的，取 $M=T$，得到的这个长度被称为 $Z$ 函数。“函数”只是一个叫法，它本质上是个数组…为了好听，后面叫他“$Z$ 数组” （互联网上的确有人这么叫）</p><h3 id="符号-字符串"><a href="#符号-字符串" class="headerlink" title="符号(字符串)"></a>符号(字符串)</h3><p>$|S|$ 表示 $S$ 的长度</p><p>$S[l:r]$ 表示 $S$ 从 $l$ 到 $r$ 的子串。如果 $l$ 空着，默认为 $1$；同理 $r$ 默认为 $|S|$。</p><p>也就是 $S[:x]$ 表示 $S$ 到 $x$ 结束的前缀，$S[x:]$ 表示 $S$ 从 $x$ 开始的后缀。</p><p>$LCP(S_1,S_2)$ 表示 $S_1,S_2$ 的 <strong>最长公共前缀</strong> （<code>Longest Common Prefix</code>）</p><h3 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>设 $p_i=LCP(T_i,M)$</p><p>定义从 $l$ 开始的匹配区间为 $[l,l+p_l-1]$ （设 $l+p_l-1=r$）</p><p>我们枚举处理。假设现在已经求好了 $[1,i-1]$ 的 $p$ 数组，要求 $p_i$。记录一个 <strong>最靠后</strong> 的匹配区间 $[l,r]$ （$l&lt;i$，以 $r$ 靠后为第一关键字，$l$ 靠后为第二关键字），考虑直接从 $[l,r]$ 中继承点答案来，那很显然一个前提就是 $i\le r$ （你 $i$ 在 $r$ 外面继承啥）</p><p>显然，$p_i\ge LCP(T[i:r],M)$ （因为 $T[i:r]$ 是 $T[i:]$ 前缀）</p><p>由定义， $[l,r]$ 是最长<strong>匹配</strong>长度，可知 $T[l:r]=M[1:r-l+1]$。</p><p>然后现在假如 $l&lt;i\le r$，那么显然 $T[i:r]=M[i-l+1:r-l+1]$</p><p>那么 $LCP(T[i:r],M)=LCP(M[i-l+1:r-l+1],M)$</p><p>简单想一下，$LCP(A[l:r],A)=min(LCP(A[l:],A),r-l+1)$</p><p>我们要求 $[l,r]$ 子串与整个串的 $LCP$，可以先求以 $l$ 开头的整个后缀的与整个串的 $LCP$，然后和区间长度取 $min$。这显然正确。</p><p>然后有：</p><p>$LCP(M[i-l+1:r-l+1],M)=min(LCP(M[i-l+1:],M),(r-l+1)-(i-l+1+1))$</p><p>右边的 $-l+1$ 两个抵消了，就变成 $r-i+1$</p><p>然后前面是 $LCP(M[i-l+1:],M)$ 。这不就是 $M$ 的 $Z$ 数组的第 $i-l+1$ 个位置吗！（还记得 $Z$ 数组的定义吗？）</p><p>觉得看字母理解不了的看图（自己画的）（纯鼠标）：</p><p><img src="https://i.loli.net/2020/05/04/dxpDcv31MtEUL5S.png" alt></p><p>红色的部分就是我们推出来的匹配部分。然后现在我们把 $M$ 移到 $i$ 开头的位置来匹配，就相当于把 $M[i-l+1:r-l+1]$ 这一段（红色）移到 $M$ 的开头处匹配。这一段匹配的长度就是 $min(Z_{i-l+1},r-i+1)$。</p><p>假设我们现在能求这个 $Z$ 数组，那么我们已经知道 $p_i$ 的最小值了 ，就是 $min(Z_{i-l+1},r-i+1)$ 。从这个位置开始暴力即可。这样就不用每次从 $1$ 开始匹配了。</p><p>求完 $p_i$ 之后，记得用 $[i,i+p_i-1]$ 更新 $[l,r]$。</p><p>时间是线性的，我不会证，可以参考网上的证明。</p><h4 id="如何求-Z-数组"><a href="#如何求-Z-数组" class="headerlink" title="如何求 Z 数组"></a>如何求 Z 数组</h4><p>我们发现 $Z$ 数组就是自己和自己匹配的过程。然后我们把上面过程中 $M$ 换成 $T$ 即可。</p><p>所以我们还是记录一个最靠后的匹配区间 $[l,r]$，然后 $p_i$ 就相当于 $Z_i$ 了。</p><p>易得：</p><p>$Z_i=min(LCP(M[i-l+1:],M),r-i+1)=min(LCP(T[i-l+1:],T),r-i+1)=min(Z_{i-l+1},r-i+1)$</p><p>求完 $Z_i$ 之后，记得用 $[i,i+Z_i-1]$ 来更新 $[l,r]$。</p><p>一样，也是从这里开始暴力即可。时间复杂度依然是线性的，可以参考网上的证明。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p><a href="https://www.luogu.com.cn/problem/P5410" target="_blank" rel="noopener">洛谷板子</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) a.begin(),a.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Flandre_Scarlet int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IsMyWife main</span></span><br><span class="line"><span class="keyword">char</span> _c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">I</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>; <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(_c&lt;<span class="string">'0'</span> <span class="keyword">or</span> _c&gt;<span class="string">'9'</span>) f=(_c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,_c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(_c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> _c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(_c^<span class="number">48</span>),_c=getchar();</span><br><span class="line">    <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args; va_start(args,cnt);</span><br><span class="line">    F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=I();&#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,a+<span class="number">1</span>,b+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> z[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Z</span><span class="params">(<span class="keyword">char</span> s[])</span> <span class="comment">// 求 Z 函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">z[<span class="number">1</span>]=n; F(i,<span class="number">2</span>,n) z[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Z[1]=n 特判，同时也是递推边界</span></span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">F(i,<span class="number">2</span>,n) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;=r) z[i]=min(z[i-l+<span class="number">1</span>],r-i+<span class="number">1</span>); <span class="comment">// 推理出下界</span></span><br><span class="line"><span class="keyword">while</span>(i+z[i]&lt;=n <span class="keyword">and</span> s[i+z[i]]==s[z[i]+<span class="number">1</span>]) ++z[i]; <span class="comment">// 暴力</span></span><br><span class="line"><span class="keyword">if</span> (i+z[i]<span class="number">-1</span>&gt;=r) l=i,r=i+z[i]<span class="number">-1</span>; <span class="comment">// 更新最靠后的匹配位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExKmp</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">char</span> t[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">Z(t);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">F(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;=r) p[i]=min(z[i-l+<span class="number">1</span>],r-i+<span class="number">1</span>); <span class="comment">// 推理出下界</span></span><br><span class="line"><span class="keyword">while</span>(i+p[i]&lt;=n <span class="keyword">and</span> s[i+p[i]]==t[p[i]+<span class="number">1</span>]) ++p[i]; <span class="comment">// 暴力</span></span><br><span class="line"><span class="keyword">if</span> (i+p[i]<span class="number">-1</span>&gt;r) l=i,r=i+p[i]<span class="number">-1</span>; <span class="comment">// 更新最靠后的匹配位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ExKmp(a,b);</span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(a+<span class="number">1</span>),m=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">F(i,<span class="number">1</span>,m) ans^=<span class="number">1l</span>l*i*(z[i]+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line">F(i,<span class="number">1</span>,n) ans^=<span class="number">1l</span>l*i*(p[i]+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Flandre_Scarlet <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Input();</span><br><span class="line">Soviet();</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://lightninguz2.github.io/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="思维" scheme="https://lightninguz2.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="exkmp" scheme="https://lightninguz2.github.io/tags/exkmp/"/>
    
  </entry>
  
  <entry>
    <title>五边形数 笔记</title>
    <link href="https://lightninguz2.github.io/2020/05/02/%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0-%E7%AC%94%E8%AE%B0/"/>
    <id>https://lightninguz2.github.io/2020/05/02/五边形数-笔记/</id>
    <published>2020-05-02T14:10:24.000Z</published>
    <updated>2020-05-02T15:06:38.328Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>近日，一国外小哥学习了这个定理，竟然能预处理出整数划分的方案数！快跟小编来看看吧</del></p><p>这个小哥学习的定理，就是小编（我）接下来要讲的五边形数定理</p><p><del>好的，让我们一起来看看这个定理吧</del></p><h3 id="五边形数是啥"><a href="#五边形数是啥" class="headerlink" title="五边形数是啥"></a>五边形数是啥</h3><p><a href="https://baike.baidu.com/item/%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0/9459853" target="_blank" rel="noopener">百度百科</a></p><p>用图来讲，就是若干个点，排成若干个五边形，需要多少个点。</p><p>百度百科上有一个很清楚的图：</p><p><img src="https://bkimg.cdn.bcebos.com/pic/faf2b2119313b07ecf28339b07d7912396dd8c8f?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5" alt></p><p>它的通项公式为 $a_n=\dfrac{n(3n-1)}{2}$，前面几项是 $0, 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, 176, 210…$。你可以在 OEIS 上找到它，是序列 <a href="http://oeis.org/A000326" target="_blank" rel="noopener">A000326</a></p><p>我们要研究的是 <strong>广义五边形数</strong>，是这样一个数列：$p=a_0,a_{1},a_{-1},a_{2},a_{-2}…$</p><p>其中，如果 $p$ 的下标是负数，照样代入到上面的通项公式里算即可。容易证明，当 $n&lt;0$ 时，$p_n$ 也是正的。前面几项是 $0, 1, 2, 5, 7, 12, 15, 22, 26, 35, 40, 51, 57, 70, 77, 92, 100, 117…$，同样可以在 OEIS 上找到它是 <a href="http://oeis.org/A001318" target="_blank" rel="noopener">A001318</a></p><h3 id="它能干啥"><a href="#它能干啥" class="headerlink" title="它能干啥"></a>它能干啥</h3><h4 id="欧拉函数（五边形数）"><a href="#欧拉函数（五边形数）" class="headerlink" title="欧拉函数（五边形数）"></a>欧拉函数（五边形数）</h4><p>（为了和欧拉数论函数区别开来，这里给它起名叫欧拉函数-五边形数(*/ω＼*)</p><p>是这样一个函数：$\varphi(x)=(1-x)(1-x^2)(1-x^3)(1-x^4)…(1-x^inf)=\prod\limits_{i=1}^{inf} (1-x^i)$</p><p>这东西有一个很神奇的性质。如果你闲的没事，可以暴力拆开它，发现它等于</p><p>$x^0-x^1-x^2+x^5+x^7-x^{12}-x^{15}+x^{22}+x^{26}…=\sum\limits_{i=1}^{inf} (-1)^{(i+1)/2} x^{p_i}$</p><p>系数：一个正，两个负，两个正，两个负，两个正，两个负…</p><p>指数：广义五边形数</p><h4 id="与整数划分问题的联系"><a href="#与整数划分问题的联系" class="headerlink" title="与整数划分问题的联系"></a>与整数划分问题的联系</h4><p>然后我们可以来解决整数划分问题。设 $P(n)$ 表示将 $n$ 分成若干个整数的无序方案（即，$a+b$ 和 $b+a$ 只算一次），同一个数可以用很多次。</p><p>比如，$P(4)=5$，因为 $4$</p><p>$=1+1+1+1$</p><p>$=1+1+2$</p><p>$=1+3$</p><p>$=2+2$</p><p>$=4$</p><p>特殊地，$P(0)=1$</p><p>我们求出 $P(n)$ 的生成函数 $f(x)=\sum\limits_{n=0}^{inf} P(n)x^n$</p><p>给它换个定义：我们要选出若干个（可以是 $0$ 个） $1$，若干个 $2$，若干个 $3$…使得选出来的所有数和为 $n$。</p><p>这样就好考虑了。看这个式子：</p><p>$(1+x+x^2+x^3…)(1+x^2+(x^2)^2+(x^2)^3…)(1+x^3+(x^3)^2+(x^3)^3…)…$</p><p>第一个因式表示我们能随便选择用多少个 $x^1$</p><p>第二个因式表示我们能随便选择用多少个 $x^2$</p><p>…</p><p>乘起来之后，考虑 $x^n$ 的系数，你会发现它就是 $P(n)$！是不是特别巧妙φ(&gt;ω&lt;*) </p><p>于是</p><p> $f(x)=(1+x+x^2+x^3…)(1+x^2+(x^2)^2+(x^2)^3…)(1+x^3+(x^3)^2+(x^3)^3…)…=\prod\limits_{n=1}^{inf} \sum\limits_{i=0}^{inf} (x^n)^i$</p><p>然后我们用等比数列求和公式化一下，得到：</p><p>$f(x)=\prod\limits_{n=1}^{inf} \dfrac{1}{1-x^n}$</p><p>我们发现它就是欧拉函数-五边形数的倒数(/≧▽≦/)！</p><p>即</p><p>$\varphi(x)f(x)=1$</p><p>也就是</p><p>$(1-x-x^2+x^5+x^7-x^{12}-x^{15}…)(\sum\limits_{n=0}^{inf} P(n)x^n)=1$</p><p>观察其中 $x^n$ 项的系数（分别考虑左边和右边的括号出的是几次项），容易发现这个系数应该是 $P(n)-P(n-1)-P(n-2)+P(n-5)+P(n-7)…$</p><p>$n=0$ 时，这个式子显然为 $1$。那么 $n&gt;0$ 时， $x^n$ 乘以它的系数的和就得是 $0$ 了。</p><p>然后我们发现等式右边是 $1$。并且原式为恒等式，所以 $x$ 取任何值都成立。为了让 $x$ 取任何值时等式都成立，对于 $n&gt;0$ 时，$P(n)-P(n-1)-P(n-2)$ 这个可怜的等式只好取 $0$ 了。</p><p>然后就得到了：</p><p>$P(n)-P(n-1)-P(n-2)+P(n-5)+P(n-7)-P(n-12)-P(n-15)…=0$</p><p>于是 $P(n)=P(n-1)+P(n-2)-P(n-5)-P(n-7)+P(n-12)+P(n-15)…$</p><p>然后 $\le n$ 的五边形数是 $\sqrt{n}$ 级别的（注意到五边形数的通项公式是二次的）</p><p>于是我们可以递推出 $P(n)$，是 $O(n\sqrt{n})$ 的，是不是很厉害呢(✪ω✪)</p><p><del>好了，以上就是这个定理的全部内容了，喜欢记得收藏起来哟</del></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://lightninguz2.github.io/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="五边形数定理" scheme="https://lightninguz2.github.io/tags/%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0%E5%AE%9A%E7%90%86/"/>
    
      <category term="生成函数" scheme="https://lightninguz2.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1231E Middle Out 题解</title>
    <link href="https://lightninguz2.github.io/2020/05/02/Codeforces-1231E-Middle-Out-%E9%A2%98%E8%A7%A3/"/>
    <id>https://lightninguz2.github.io/2020/05/02/Codeforces-1231E-Middle-Out-题解/</id>
    <published>2020-05-02T12:16:24.000Z</published>
    <updated>2020-05-02T13:19:55.571Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>（$q$ 组数据）你有两个串，$s$ 和 $t$，长度都是 $n$。现在你可以对 $s$ 做若干次操作：选择某一个字符，把它移到最前面或者最后面（二选一）。</p><p>你现在要把 $s$ 变成 $t$，请问最少需要多少步操作。不行输出 $-1$。</p><p>$1\le q,n\le100$。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先放结论：求出最长的串 $a$ 使得 $a$ 是 $s$ 的子序列（不一定连续），并且是 $t$ 的子串（必须连续），答案是 $n-|a|$，$|a|$ 表示 $a$ 的长度</p><h4 id="怎么想到的"><a href="#怎么想到的" class="headerlink" title="怎么想到的"></a>怎么想到的</h4><p>首先我们发现能任意从中间取字符放到首尾，根据某些直觉，我们发现：把不同的往两边放，把相同的留在中间对齐。</p><p>那么留在中间的“相同的”部分，想一想，应该是某一段公共子序列。</p><p>这一段公共子序列一定是最长公共子序列吗？不一定，发现我们 <strong>只能</strong> 对 $s$ 操作，不能动 $t$，所以这段公共子序列在 $t$  中必须是连续的，不能有断开的。</p><p>就比如说样例第一个里面的第三组数据，$s=\texttt{“tste”}$，$t=\texttt{“test”}$，最长公共子序列应该是 $\texttt{“tst”}$，长度为 $3$。可是剩下的那一个字符 $\texttt{e}$ 并不能直接归位，因为要让它归位必须去动 $t$，但是我们只能动 $s$。最优策略应该是把 $\texttt{“st”}$ 放在中间，然后把 $\texttt{t}$ 和 $\texttt{e}$ 动两次归位。</p><p>然后现在还有一个问题：移动次数一定是 $n-|a|$ 吗？也就是说，剩下的 $n-|a|$ 个不同的恰好一定能在 $n-|a|$ 步之内归位？</p><p>分两步证，先证一定不小于这个数，然后证可以做到 $n-|a|$ 步，又因为我们要步数最小，就只能恰好是这个答案了。</p><p>一定不小于：如果能小于，那么我们的最长公共子序列 $a$ 就能变的更长了。所以一定不会小于这个数。</p><p>一定能取到：在 $t$ 中，由于 $a$ 是一个子串，于是 $t$ 中和 $s$ 不匹配的地方，就是 $t$ 中抠掉 $a$ 剩下的部分，一定是一段前缀加一点后缀。先从右到左遍历剩下的前缀，在 $s$ 中找一个相等的，放到最前面来。再从左到右遍历剩下的后缀，在 $s$ 中找一个相等的，放到最后面来。然后这个步数显然可以做到 $n-|a|$ 步。（附：关于这个从左到右还是从右到左，可以简单的概括为：<strong>从里到外</strong>）（为啥是从里到外，可以自己手玩一下）</p><h4 id="怎么求"><a href="#怎么求" class="headerlink" title="怎么求"></a>怎么求</h4><p>枚举这一段公共子序列在 $t$ 中的起点，然后写两个指针，匹配一下即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 122</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) a.begin(),a.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Flandre_Scarlet int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IsMyWife main</span></span><br><span class="line"><span class="keyword">char</span> _c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">I</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>; <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(_c&lt;<span class="string">'0'</span> <span class="keyword">or</span> _c&gt;<span class="string">'9'</span>) f=(_c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,_c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(_c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> _c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(_c^<span class="number">48</span>),_c=getchar();</span><br><span class="line">    <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args; va_start(args,cnt);</span><br><span class="line">    F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=I();&#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> a,b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=I();</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">F(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> pos=i;</span><br><span class="line">F(j,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span> (pos&lt;n <span class="keyword">and</span> b[pos]==a[j]) ++pos;</span><br><span class="line">        <span class="comment">// pos 表示在 t 中的位置，j 表示在 s 中的位置</span></span><br><span class="line">        <span class="comment">// pos-i 就是求出来的长度</span></span><br><span class="line">ans=min(ans,n-(pos-i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(all(a)); sort(all(b)); <span class="keyword">if</span> (a!=b)&#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>);<span class="keyword">return</span>;&#125; <span class="comment">// 判一下无解</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Flandre_Scarlet <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=I();</span><br><span class="line">F(i,<span class="number">1</span>,t)</span><br><span class="line">&#123;</span><br><span class="line">Input();</span><br><span class="line">Soviet();</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="思维" scheme="https://lightninguz2.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>cdq分治 笔记</title>
    <link href="https://lightninguz2.github.io/2020/05/02/cdq%E5%88%86%E6%B2%BB-%E7%AC%94%E8%AE%B0/"/>
    <id>https://lightninguz2.github.io/2020/05/02/cdq分治-笔记/</id>
    <published>2020-05-02T09:59:26.000Z</published>
    <updated>2020-05-02T10:21:51.450Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>这个算法用于解决三维偏序问题。</p><p>三维偏序：给定 $n$ 个三元组： $(a_i,b_i,c_i)$，求同时满足满足 $a_i\le a_j,b_i\le b_j,c_i\le c_j$ 的 $(i,j)$ 的数量。</p><p>那这该咋求呢⊙(・◇・)？</p><p>先把维度降下来，二维偏序，会不会做？就是求多少个 $(i,j)$ 满足 $a_i\le a_j,b_i\le b_j$。</p><p>显然，先按照 $a$ 排一下序。然后就变成了 $i&lt;j,b_i\le b_j$ 的问题了。可以用树状数组做。最典型的案例就是逆序对问题，这个都写熟练了哈(*╹▽╹*)</p><p>三维偏序的问题，也是先按 $a$ 排一下序。然后接下来的问题考虑分治（这样的分治过程被我们称为“cdq分治”）</p><p>假设我们要求 $[l,r]$ 中的答案。已经求好了 $[l,mid],[mid+1,r]$ 中的答案，现在只需要考虑跨区的答案了。</p><p>那么我们可以把 $[l,mid]$ 和 $[mid+1,r]$ 内部都按照 $b$ 排序。因为我们只要考虑跨区的答案，那么我们把两边分别都随便排序，对跨区的时候 $a$ 的大小关系没有影响。然后我们在 $[mid+1,r]$ 中枚举一个元素 $j$，找到在 $[l,mid]$ 中有多少个 $i$ 满足 $b_i\le b_j$，然后这个 $i$ 显然是递增的。然后我们一边单调的维护这个 $i$ ，一边用树状数组维护 $c_i\le c_j$ 的数量即可。</p><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><p>洛谷3810 陌上花开</p><p><a href="https://www.luogu.com.cn/paste/fc16nbqi" target="_blank" rel="noopener"><img src="https://i.loli.net/2020/05/02/pdk8tDQOzaGqjsw.png" alt></a></p><p>（↑代码找我老婆要）（那张图是一个链接(*^▽^*)）（偷偷测试功能）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="cdq分治" scheme="https://lightninguz2.github.io/tags/cdq%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>线段树优化建图 笔记</title>
    <link href="https://lightninguz2.github.io/2020/04/19/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE-%E7%AC%94%E8%AE%B0/"/>
    <id>https://lightninguz2.github.io/2020/04/19/线段树优化建图-笔记/</id>
    <published>2020-04-19T13:06:09.000Z</published>
    <updated>2020-04-19T14:25:01.873Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>其实不用讲，看标题就知道这大概是一个什么样的算法了。</p><p>它用来解决这样类型的问题：你要支持，从一个点往一个区间中的所有点连一条边，或者一个区间中的所有点连一条边（有向）。</p><p>然后你就要进行一些 最短路/强连通分量/最大流 等图论基本操作了。</p><p>那么这个咋整呢（⊙.⊙）</p><p>假设我们现在是从第 ⑨ 个点向 $[3,6]$ 区间中的所有点连边。可以如下图处理：</p><p><img src="https://i.loli.net/2020/04/19/d2l6sTjxRM7FQg1.jpg" alt="blog1.jpg"></p><p>先建一颗线段树，这颗线段树上的每一个非叶子节点都向它的两个儿子连了一条有向边。</p><p>接着，我们把 $[3,6]$ 在线段树上拆分一下，变成 $[3,4]+[5,6]$。然后我们从 $9$ 连到线段树节点 $[3,4]$，还有 $[5,6]$，这样就可以 $O(\log n)$ 的时空复杂度实现一次区间连边了，是不是很神奇呢~~(✪ω✪)</p><p>（我当时是被这个算法骚到了，吓的我目瞪口呆）</p><p>那么这个父子之间的有向边，边权多少呢？首要原则是，不能影响答案，比如你要求最大流，那么影响答案的就是路径最小值，此时要把边权都设置为 $INF$。如果是求最短路，那影响答案的就是路径和，此时把边权设置为 $0$ 就好了 (*^▽^*)</p><p>然后我们怎么从区间连向点呢？我们再建一颗树，这颗树的父子边是从儿子到父亲的有向边。然后再把区间拆分一下即可，和上面基本一样，就是反个方向☆daze~</p><p>还是那句话（<del>韩信带净化</del>），只有你们想不到，没有出题人出不到，咱们去挑战一把毒瘤例题咯 ~❤</p><h3 id="起飞"><a href="#起飞" class="headerlink" title="起飞"></a>起飞</h3><h4 id="T1-超级经典のCF786B-Legacy"><a href="#T1-超级经典のCF786B-Legacy" class="headerlink" title="T1. 超级经典のCF786B Legacy"></a>T1. 超级经典のCF786B Legacy</h4><p>（诶诶诶别吓我嗷，B 题就 *2600？</p><p>（对，没错，这就是 div.1 的神仙，自闭了 o(╥﹏╥)o</p><p>这题基本就是板子了（板子也毒瘤的要死），支持 $m$ 个三种形式的连边操作：</p><ol><li>有向边 $u\xrightarrow[w]{\qquad} v$ </li><li>区间连点 $[l,r]\xrightarrow[w]{\qquad} u$</li><li>点连区间 $u\xrightarrow[w]{\qquad} [l,r]$</li></ol><p>然后给你源点 $S$，求 $S$ 到每个点的最短路。</p><p>$n,m\le 10^5,w\le 10^9$，其余所有操作保证有意义且合法</p><p>然后，$m$ 指的是连边 <strong>操作</strong> 的数量，并不代表边数！</p><p>（边数可能会到 $O(n^2)$ 级别，存不下</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>就像上面那样，开两颗线段树，然后连边即可。我们管从父亲到儿子连边的线段树叫“入树”，即 $T_{in}$。它用来存储  $u\xrightarrow[w]{\qquad} [l,r]$ 形式的边。同理，另一颗叫“出树”，即 $T_{out}$。设 $T[l,r]$ 表示线段树 $T$ 上代表区间 $[l,r]$ 的节点。</p><p>对于 $u\xrightarrow[w]{\qquad} [l,r]$ 的边，就连边 $T_{out}[u,u]\xrightarrow[w]{\qquad}T_{in}[l,r]$。</p><p>同理，对于 $[l,r]\xrightarrow[w]{\qquad} u$ 的边，就连边 $T_{out}[l,r]\xrightarrow[w]{\qquad}T_{in}[u,u]$</p><p>还有，两颗线段树对应的叶子节点本质上是同一个 点，所以要连 $n$ 条边权为 $0$ 的无向边，把这些叶子节点合并起来。即，对于每个 $i$，连边 $T_{out}[i,i]\xrightarrow[0]{\qquad}T_{in}[i,i]$</p><p>然后从 $T_{out}[s,s]$ 跑一遍最短路即可。最后输出记得输出 $dis[T_{in}[i,i]]$。</p><p><a href="https://vjudge.net/solution/24052382" target="_blank" rel="noopener">代码</a></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>刚接触的时候，一定要想清楚 <strong>入树</strong> 和 <strong>出树</strong>！</p><p>（不建议背，要好好理解，看不懂的私信我</p><h4 id="T2-libreoj2255"><a href="#T2-libreoj2255" class="headerlink" title="T2. libreoj2255"></a>T2. libreoj2255</h4><p><a href="https://loj.ac/problem/2255" target="_blank" rel="noopener">戳我</a></p><p>中文超短题意，我就不概括了。</p><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>显然，每个能引爆的所有炸弹，最后是要连续的</p><p>对于每个点，向它能一步引爆的炸弹连一条有向边（点到区间连边，这一步用线段树优化）</p><p>然后维护它能到的点中，最小和最大的编号即可。这个可以 Tarjan 缩点后一遍 DFS 求出来。</p><p>然后就是硬上了…</p><p>这题比上面水的是，不用注意出树和入树，这题就一个入树…</p><p><a href="https://loj.ac/submission/785470" target="_blank" rel="noopener">代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://lightninguz2.github.io/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="线段树优化建图" scheme="https://lightninguz2.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>bzoj 4962 简单的字符串 题解</title>
    <link href="https://lightninguz2.github.io/2020/04/19/bzoj-4962-%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-%E9%A2%98%E8%A7%A3/"/>
    <id>https://lightninguz2.github.io/2020/04/19/bzoj-4962-简单的字符串-题解/</id>
    <published>2020-04-19T12:03:29.000Z</published>
    <updated>2020-04-19T12:49:57.461Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>给你一个长度为 $n$ 的数组 $a$，问你有多少个区间，满足：</p><ol><li>长度为偶数</li><li>前一半和后一半循环同构</li></ol><p>$n\le 5000,a_i\le 5000$</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>两个串 $a,b$ 循环同构 ，那么一定可以把 $a$ 分成两个串 $u,v$ 接起来，然后把 $b$ 表示成 $v,u$ 的形式。</p><p>就比如 $a=\texttt{“abcde”},b=\texttt{“cdeab”}$，那么 $a=\texttt{“ab”+”cde”},b=\texttt{“cde”+”ab”}$。</p><p>然后现在这两个串相邻了，也就是有一段连续的 $uv|vu$ 的形式。考虑枚举中间这个划分线，然后计算两边有多少满足条件的。这也许能用哈希水过，但是我们要想一个正经办法(*^▽^*)</p><p>一般我们遇到这样的“分块回文” 的问题，都是怎么做的呢⊙(・◇・)？</p><p>联想一下 <a href="https://vjudge.net/problem/CodeForces-932G" target="_blank" rel="noopener">codeforces 932G</a> 这个题，我们可以把前面一半的 $uv$ 反过来，然后一个隔一个的插入到后半边的 $vu$ 里面去。这样插入完就会变成两个长度为偶数的回文串拼在一起啦 (/≧▽≦/)</p><div><div class="fold_hider"><div class="close hider_title">点击</div></div><div class="fold"><h4 id="关于它为啥会变成这样"><a href="#关于它为啥会变成这样" class="headerlink" title="关于它为啥会变成这样"></a>关于它为啥会变成这样</h4><p>先考虑一个串的情况。现在有一个 $u$，假设它由三个字符 $a,b,c$ 构成。我们把它反过来，然后一个隔一个的插入，变成：</p><p>$\color{red} c\color{black}a \color{red} b \color{black} b \color{red} a \color{black} c$</p><p>新插入的用红色表示，原来就有的用黑色表示。然后我们发现它变成了一个回文串！</p><p>容易归纳证明，无论它长度多少，这样子做总会变成一个回文串。</p><p>然后考虑两个串 $u,v$ 拼一块的情况。我们把 $u+v$ 反过来，一个隔一个的插入到 $v+u$ 中，会变成什么呢？</p><p>设 $s’$ 是 $s$ 反过来的串。然后显然 $(u+v)’=v’+u’$。我们把它插入到 $v+u$ 中之后，前面 $|v|$ 个串会先变成一个长度为 $2|v|$ 的回文串，后面还有 $|u|$ 个串，会变成长度为 $2|u|$ 的回文串。于是总体就变成了一个长度为 $2|v|+2|u|$ 的两个偶数长度回文串。</p><p>举个例子，$u=\texttt{“ab”},v=\texttt{“cd”}$，这样插入完之后变成 这样：<a href="https://www.luogu.com.cn/paste/nhbxmn6j" target="_blank" rel="noopener">公式炸了，点我</a></p><p>它等于 $\texttt{“dccd”}+\texttt{“baab”}$。</p><p>（你们可能不知道这公式有多难打，就为了举个形象的例子… 唉o(╥﹏╥)o）</p></div></div><p>然后我们只需要用 Manacher 统计一下有多少个这样的回文串即可（～￣▽￣～）</p><p>设 $pre[i]$ 表示从 $i$ 往前最多能跳多少长度，使得跳过的部分是回文串。然后 $f[i]$ 是回文中心。</p><p>用 $last$ 记录上一个回文前缀的位置。当前位置在 $i$ ，如果 $[last,i]$ 是个回文串，或者 $[i-pre[i]+1,i]$ 是个回文串，那么当前的 $i$ 就是合法的~☆，答案 ++。</p><p>那么如何判断 $[l,r]$ 是不是回文串呢⊙(・◇・)？设 $mid=(l+r)/2$，看看是否满足 $f[mid]\ge (r-l+1)/2$ 即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div><div class="fold_hider"><div class="close hider_title">点击</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> N 14444</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">I</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">        <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">        <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        va_list args; va_start(args,cnt);</span><br><span class="line">        F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=I();&#125;</span><br><span class="line">        va_end(args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n=I();</span><br><span class="line">        F(i,<span class="number">1</span>,n) a[i]=I();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> s[N];</span><br><span class="line">    <span class="keyword">int</span> f[N],pre[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=p,r=p+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">1</span> <span class="keyword">and</span> r&lt;=n) s[++cnt]=a[l],s[++cnt]=a[r],--l,++r;</span><br><span class="line"> </span><br><span class="line">        F(i,<span class="number">0</span>,cnt+<span class="number">1</span>) f[i]=pre[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> id=<span class="number">1</span>,Max=<span class="number">1</span>;</span><br><span class="line">        F(i,<span class="number">1</span>,cnt) </span><br><span class="line">        &#123;</span><br><span class="line">            f[i]=min(max(Max-i,<span class="number">0</span>),f[id+(id-i)]);</span><br><span class="line">            <span class="keyword">while</span>(i+f[i]+<span class="number">1</span>&lt;=n <span class="keyword">and</span> i-f[i]&gt;<span class="number">0</span> <span class="keyword">and</span> s[i+f[i]+<span class="number">1</span>]==s[i-f[i]]) ++f[i]; </span><br><span class="line">            <span class="keyword">if</span> (i+f[i]&gt;=Max) Max=i+f[i],id=i;</span><br><span class="line">            pre[i+f[i]]=max(pre[i+f[i]],f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        D(i,cnt,<span class="number">1</span>) pre[i]=max(pre[i],pre[i+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">        Ds(i,cnt,<span class="number">1</span>,i-=<span class="number">2</span>) pre[i]*=<span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">        Fs(i,<span class="number">2</span>,cnt,i+=<span class="number">2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i/<span class="number">2</span>]==i/<span class="number">2</span>) last=i;</span><br><span class="line">            <span class="keyword">if</span> (f[(i+last)/<span class="number">2</span>]&gt;=(i-last)/<span class="number">2</span> <span class="keyword">or</span> f[(i-pre[i])/<span class="number">2</span>]&gt;=(i-pre[i])/<span class="number">2</span>) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        F(i,<span class="number">1</span>,n<span class="number">-1</span>) ans+=calc(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line">    <span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Input();</span><br><span class="line">        Soviet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Flandre_Scarlet::IsMyWife();</span><br><span class="line">    getchar();getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="思维" scheme="https://lightninguz2.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="Manacher" scheme="https://lightninguz2.github.io/tags/Manacher/"/>
    
  </entry>
  
  <entry>
    <title>libreoj 6192 「美团 CodeM 复赛」城市网络 题解</title>
    <link href="https://lightninguz2.github.io/2020/04/19/libreoj-6192-%E3%80%8C%E7%BE%8E%E5%9B%A2-CodeM-%E5%A4%8D%E8%B5%9B%E3%80%8D%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C-%E9%A2%98%E8%A7%A3/"/>
    <id>https://lightninguz2.github.io/2020/04/19/libreoj-6192-「美团-CodeM-复赛」城市网络-题解/</id>
    <published>2020-04-18T18:27:00.000Z</published>
    <updated>2020-04-18T18:40:10.415Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>有 $n$ 个城市，组成一张树形网络。第 $i$ 个城市售卖价值为 $a_i$ 的珠宝。zps 的父母计划了 $q$ 次行程。每次先带上价值为 $c$ 的珠宝，从城市 $u$ 走到城市 $v$ （保证 $v$ 在 $u$ 到 $1$ 的路径上）。如果当前的城市售卖的珠宝比手头的贵（严格大于，等于不行），那么 zps 的父母会买入这个珠宝。</p><p>对于每次行程，求出 zps 的父母进行了多少次“买入”操作。</p><p>$n,q,c,a_i\le 10^5$，$1\le u,v\le n$</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们发现，对于每一次行程，除了第一次要特判一下之外，我下一次走到哪里应该是固定的。</p><p>假设我们当前在 $u$，那么我们下一次走的位置，应该就是 $u$ 往上跳，第一个 $a_i&gt;a_u$ 的 $i$（当然，如果这个 $i$ 跳到了 $v$ 外面，那么我们不算它）</p><p>于是我们考虑，先用倍增求出第一个 $a_i&gt;a_u$ 的 $i$，然后重新建图，把 $u$ 直接连到 $i$ 上。这样，对于每次行程，我们把首尾特判掉之后，就相当于新树上求一段路径的长度了。这个直接维护一个深度就能求了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> N 155555</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">I</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">        <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">        <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        va_list args; va_start(args,cnt);</span><br><span class="line">        F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=I();&#125;</span><br><span class="line">        va_end(args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">int</span> head[N];</span><br><span class="line">            <span class="keyword">int</span> EdgeCount;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="keyword">int</span> To,Label,Next;</span><br><span class="line">            &#125;Ed[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> _V=N,<span class="keyword">int</span> _E=N&lt;&lt;<span class="number">1</span>)</span> </span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="built_in">memset</span>(Ed,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Edge)*(_E));</span><br><span class="line">                <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(_V));</span><br><span class="line">                EdgeCount=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;;</span><br><span class="line">                head[u]=EdgeCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">Add2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w=<span class="number">1</span>)</span> </span>&#123;AddEdge(u,v,w);AddEdge(v,u,w);&#125;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">Start</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">return</span> head[u];&#125;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">To</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="keyword">return</span> Ed[u].To;&#125;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">Label</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="keyword">return</span> Ed[u].Label;&#125;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">Next</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="keyword">return</span> Ed[u].Next;&#125;</span><br><span class="line">    &#125;G;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Rd(<span class="number">2</span>,&amp;n,&amp;m);</span><br><span class="line">        F(i,<span class="number">1</span>,n) a[i]=I();</span><br><span class="line">        G.clear();</span><br><span class="line">        F(i,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u,v; Rd(<span class="number">2</span>,&amp;u,&amp;v); G.Add2(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> deep[N],fa[N][<span class="number">22</span>],Max[N][<span class="number">22</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        deep[u]=(u==f)?<span class="number">0</span>:deep[f]+<span class="number">1</span>;</span><br><span class="line">        fa[u][<span class="number">0</span>]=f; F(i,<span class="number">1</span>,<span class="number">20</span>) fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        Max[u][<span class="number">0</span>]=max(a[u],a[f]); F(i,<span class="number">1</span>,<span class="number">20</span>) Max[u][i]=max(Max[u][i<span class="number">-1</span>],Max[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">        Tra(i,u) <span class="keyword">if</span> (v!=f) DFS(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">PathMax</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> <span class="comment">// 求路径最大值</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u==f) <span class="keyword">return</span> a[u];</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        D(i,<span class="number">20</span>,<span class="number">0</span>) <span class="keyword">if</span> (deep[fa[u][i]]&gt;=deep[f]) </span><br><span class="line">        &#123;</span><br><span class="line">            ans=max(ans,Max[u][i]),u=fa[u][i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MaxPos</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> <span class="comment">// 求路径最大值是哪个位置</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Mx=PathMax(u,f);</span><br><span class="line">        <span class="keyword">if</span> (a[u]==Mx) <span class="keyword">return</span> u;</span><br><span class="line">        D(i,<span class="number">20</span>,<span class="number">0</span>) <span class="keyword">if</span> (Max[u][i]&lt;Mx) u=fa[u][i]; </span><br><span class="line">        <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstBig</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c)</span> <span class="comment">// 找到 u 往上第一个满足 a[i]&gt;c 的</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[u]&gt;c) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">if</span> (Max[u][<span class="number">20</span>]&lt;=c) <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">        D(i,<span class="number">20</span>,<span class="number">0</span>) <span class="keyword">if</span> (Max[u][i]&lt;=c) u=fa[u][i];</span><br><span class="line">        <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">namespace</span> Re_build <span class="comment">// 把重新建的图封装起来，避免名字冲突</span></span><br><span class="line">    &#123;   </span><br><span class="line">        Graph G;</span><br><span class="line">        <span class="keyword">int</span> deep[N],fa[N][<span class="number">22</span>];</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            G.clear();</span><br><span class="line">            F(i,<span class="number">1</span>,n) G.AddEdge(fa[i][<span class="number">0</span>],i); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            deep[u]=(u==n+<span class="number">1</span>)?<span class="number">0</span>:deep[fa[u][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">            F(i,<span class="number">1</span>,<span class="number">20</span>) fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">            Tra(i,u) DFS(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span>  <span class="title">Query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fu)</span> </span>&#123;<span class="keyword">return</span> deep[u]-deep[fu];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DFS(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        F(i,<span class="number">1</span>,n) Re_build::fa[i][<span class="number">0</span>]=(Max[i][<span class="number">20</span>]==a[i])?n+<span class="number">1</span>:FirstBig(i,a[i]);</span><br><span class="line">        <span class="comment">// 重新设置 fa 数组</span></span><br><span class="line">        Re_build::Init();</span><br><span class="line">        Re_build::DFS(n+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 重新 DFS 一遍</span></span><br><span class="line"></span><br><span class="line">        F(i,<span class="number">1</span>,m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u,v,c; Rd(<span class="number">3</span>,&amp;u,&amp;v,&amp;c); </span><br><span class="line">            <span class="keyword">int</span> uu=u,vv=v; <span class="comment">// 存储原始的 u,v (后面会有修改)</span></span><br><span class="line">            <span class="keyword">if</span> (u==v) &#123;<span class="built_in">puts</span>(c&lt;a[u]?<span class="string">"1"</span>:<span class="string">"0"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span> (c&gt;=PathMax(u,v)) &#123;<span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">            u=FirstBig(uu,c);  <span class="comment">// 先跳到上面第一个 &gt;c 的 （注意，这里先跳了一次，所以答案+1）</span></span><br><span class="line">            v=MaxPos(uu,vv); <span class="comment">// 处理一下开头结尾</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Re_build::Query(u,v)+<span class="number">1</span>); </span><br><span class="line">            <span class="comment">// 如上面所说，答案 +1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line">    <span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Input();</span><br><span class="line">        Soviet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Flandre_Scarlet::IsMyWife();</span><br><span class="line">    getchar();getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="思维" scheme="https://lightninguz2.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="树形结构" scheme="https://lightninguz2.github.io/tags/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/"/>
    
      <category term="倍增" scheme="https://lightninguz2.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>莫比乌斯容斥 笔记</title>
    <link href="https://lightninguz2.github.io/2020/04/18/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%AE%B9%E6%96%A5-%E7%AC%94%E8%AE%B0/"/>
    <id>https://lightninguz2.github.io/2020/04/18/莫比乌斯容斥-笔记/</id>
    <published>2020-04-18T12:28:58.000Z</published>
    <updated>2020-05-04T02:20:50.371Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>（本篇文章假设您学过莫比乌斯反演 (〃’▽’〃) </p><p>我们知道莫比乌斯函数有一个性质： $\sum\limits_{d|n} \mu(d)=[n=1]$</p><p>根据这条性质，我们写出一个类似筛的东西：一个数组，初始都是 $0$。 第 $i$ 轮，将 $i$ 的倍数都加上 $\mu(i)$。</p><p><img src="https://i.loli.net/2020/04/18/gksPoOy6wfMBClE.jpg" alt="blog1.jpg"></p><p>$n$ 轮之后，显然只有第一个位置还剩一个 $1$，其它都变成了 $0$。好好理解下这个表，然后往下看。</p><p>那么，假设现在我们要求 $n=1$ 时的答案，但是我们方便求的只有 $n$ 的倍数的答案和，如何转化捏 （⊙.⊙）</p><p>我们设 $f(x)$ 表示 $n$ 恰好为 $x$ 的答案，$F(x)$ 表示 $n$ 为 $x$ 的倍数的答案和，即 $\sum\limits_{d|n} f(n)$。</p><p>考虑 $\sum\limits_{i=1}^{n} \mu(i)F(i)$，</p><p>它 $=\sum\limits_{i=1}^{n}\sum\limits_{i|j} \mu(i)f(j)$</p><p>考虑每个 $f(i)$ 被算了多少次，变为：</p><p>$\sum\limits_{j=1}^{n} f(j) \sum\limits_{i|j} \mu(i)=\sum\limits_{j=1}^{n} f(j) [j=1]=f(1)$</p><p>$f(1)$ 不就是我们要求的，$n$ 恰好为 $1$ 的方案吗(✪ω✪)</p><p>其实你也可以联系上面那个表来理解，我们给每一列带上一个 $f(i)$ 的权值，$F(i)$ 就是 $i$ 的倍数列的额。然后我们把所有的 $F(i)*\mu(i)$ 加起来， 根据上面那个表，只会在第一列剩下一个“1”。又因为我们带了一个 $f(i)$ 的权，相当于剩下的就是 $f(1)$ 了。</p><p>所以，莫比乌斯容斥的解题步骤：</p><ol><li>转化成 $n=1$ 的方案（一般这步比较考思维）</li><li>求 $n$ 的倍数的方案和</li></ol><p>说这些有点抽象，还是做点题☆daze~</p><h3 id="起飞"><a href="#起飞" class="headerlink" title="起飞~"></a>起飞~</h3><h4 id="T1-CF-439E"><a href="#T1-CF-439E" class="headerlink" title="T1.  CF 439E"></a>T1.  CF 439E</h4><p>给定 $q$ 个询问，每次给定 $n,k$ ，问有多少种方法，把 $n$ 分成 $k$ 个数相加，并且 <strong>所有数</strong> 的 $\gcd$ 为 $1$（即：允许有部分的 $\gcd$ 不为 $1$ ，比如 $n=20,k=3$ 时，$\{2,3,15\}$ 是合法的一组拆分）</p><p>$q,n\le 10^5,k\le n$</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>如何转化成上面的 “$n=1$ 的方案数” 呢</p><p>设 $f(i)$ 表示：$k$ 个数的 $\gcd=i$ 的方案数，$F(i)$ 表示：$k$ 个数的 $\gcd$ 为 $i$ 的倍数的方案数（即：$k$ 个数都是 $i$ 的倍数的方案数）</p><p>$F(i)$ 好求。显然，此时 $i$ 是 $n$ 的因数（$k$ 个数都是 $i$ 的倍数，所以它们加起来， $n$ 也是 $i$ 的倍数）。如果不是，那么 $F(i)=0$</p><p>然后所有数都是 $i$ 的倍数的划分方案，我们可以把 $i$ 个数并成一块，然后有 $n/i$ 个块，任意划分成 $k$ 个部分，求方案数。然后我们在 $n/i$ 个块中间插入 $n/i-1$ 个隔板，选择 $k-1$ 个，就能把 $n$ 个数分成 $k$ 个部分，每个部分都是 $i$  的倍数了。这样方案数是 $F(i)=C_{n/i-1}^{k-1}$。预处理阶乘和阶乘逆元，这个 $O(1)$ 算。</p><p>然后根据莫比乌斯容斥的式子，$f(1)=\sum\limits_{i=1}^{n} F(i) \mu(i)$。然后在这题中要变下型 （看上面），因为 $i|n$ 时，$F(i)$ 才能按照上面的方法算，否则 $F(i)=0$。于是， $f(1)=\sum\limits_{i|n} F(i)\mu(i)$</p><p>然后这个枚举因数是 $O(\sqrt{n})$ 的。总的复杂度 $O(q\sqrt{n})$，能过。</p><p><a href="https://vjudge.net/solution/25263424" target="_blank" rel="noopener">代码</a> （篇幅问题，我就不放主页了(*^▽^*)）（代码看不懂的右下角联系我，或者在代码那边的评论区留言~~❤）</p><h4 id="T2-CF-900D"><a href="#T2-CF-900D" class="headerlink" title="T2. CF 900D"></a>T2. CF 900D</h4><p>同样是求划分的问题。相当于在 $T1$ 的基础上：</p><ol><li>去掉 $k$ 的限制</li><li>一组询问，范围改成 $n\le 10^9$，答案模 $10^9+7$</li><li>给定了参数 $y$，划分完所有数的 $\gcd=y$ （而不是等于 $1$）</li></ol><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>所有数 $\gcd=y$，相当于所有数除以 $y$ 之后 $\gcd=1$。</p><p>然后没有了 $k$ 的限制，相当于所有的隔板随便选/不选。这咋整捏 ⊙(・◇・)？</p><p>假设有 $n$ 个隔板，答案为 $2^{n}$。然后，$n$ 个数不限个数划分，每个数都是 $y$ 的倍数，方案数就是 $2^{n/y-1}$。</p><p>然后要注意的是，$n\le 10^9$，只有一部分 $\mu$ 可以筛出来，超过范围的就只好暴力算了。</p><p>这个时间复杂度有点玄学…但还是能过的 φ(&gt;ω&lt;*)</p><p><a href>代码</a></p><h4 id="T3-CF1036F"><a href="#T3-CF1036F" class="headerlink" title="T3. CF1036F"></a>T3. CF1036F</h4><p>$T$ 组询问，每次询问 $[2,n]$ 中有多少好数。一个数 $x$ 是“好数”，那么不存在任何一个 $k$ 使得 $\sqrt[k]{x}$ 是整数。</p><p>$T\le 10^5,x\le 10^{18}$。</p><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>一个数是“好数”，那么它分解质因数后，所有指数的 $\gcd=1$</p><p>然后我们考虑所有指数的 $\gcd$ 是 $k$ 的倍数怎么算。很显然，这个方案数就是 $\lfloor \sqrt[k]{x} \rfloor$ 。</p><p>然后 $k$ 大概枚举到 $60,70$ 就够了。 </p><p>然后卡<strong>亿点点</strong>常数就过了 o(╥﹏╥)o</p><p><a href="https://vjudge.net/solution/25372440" target="_blank" rel="noopener">代码</a></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>如果您认真的看完并理解了我上面的瞎扯…</p><p>恭喜您！学会了莫比乌斯反演！φ(&gt;ω&lt;*) </p><p>完结撒花花~~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="莫比乌斯反演" scheme="https://lightninguz2.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="毒瘤" scheme="https://lightninguz2.github.io/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="思维" scheme="https://lightninguz2.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="组合数学" scheme="https://lightninguz2.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 4247 bzoj 2962 [清华集训2012]序列操作</title>
    <link href="https://lightninguz2.github.io/2020/04/11/%E6%B4%9B%E8%B0%B7-4247-bzoj-2962-%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2012-%E5%BA%8F%E5%88%97%E6%93%8D%E4%BD%9C/"/>
    <id>https://lightninguz2.github.io/2020/04/11/洛谷-4247-bzoj-2962-清华集训2012-序列操作/</id>
    <published>2020-04-11T12:51:50.000Z</published>
    <updated>2020-04-11T13:41:20.720Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>给一个长度为 $n$ 的序列 $a$，支持 $q$ 个操作：<br><code>I l r x</code> 区间元素整体 $+x$。</p><p><code>R l r</code>  区间元素整体 $\times (-1)$</p><p><code>Q l r x</code> 询问：从 $[l,r]$ 中选择 $x$ 个数的积的所有方案的和，$\bmod 19940417$。</p><p>$n,q\le 5\times 10^4$。</p><p>所有操作保证 $[l,r]$ 有意义。操作 <code>I</code> 中，$x\le 10^9$；操作 <code>Q</code> 中，$x\le min(r-l+1,20)$</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们观察到 $x\le 20$。不妨在线段树中维护每一种情况的答案。设 $S[x]$ 表示当前节点中选择 $x$ 个数的积的所有方案的和。为了方便考虑，设 $S[0]=1$。然后，显然还需要维护取相反数的标记和加法标记。</p><p>然后开始线段树传 统 艺 能了。</p><h4 id="如何合并左右儿子的答案"><a href="#如何合并左右儿子的答案" class="headerlink" title="如何合并左右儿子的答案"></a>如何合并左右儿子的答案</h4><p>我们在左半边选 $a$ 个，右半边选 $b$ 个，那就一共选了 $a+b$ 个，贡献是 $lS[a]\times rS[b]$。其中 $lS,rS$ 表示左儿子，右儿子的 $S$ 数组。</p><h4 id="如何单节点加值"><a href="#如何单节点加值" class="headerlink" title="如何单节点加值"></a>如何单节点加值</h4><p>我们其实就是要考虑这样一个东西：</p><p>$a_1\times a_2\cdots \times a_m$ 如何变成 $(a_1+x)(a_2+x)\cdots (a_m+x)$</p><p>每个括号里可能是 $a_i$，也可能是 $x$。</p><p> 枚举 $i$ 个括号出了 $a_i$，剩下 $m-i$ 个括号出了 $x$，贡献为：</p><p><code>(a 中选 i 个数的积的所有方案的和)</code> $\times x^{m-i}$。</p><p>那么，$S[m]$ （<del>不要想歪</del>）该怎么算呢？还是不好算。</p><p>其实是因为还差一步转换：我们考虑每个 $i$ 给 $m$ 的贡献。</p><p>根据上面的式子，当前的 $i$ 会给 $S[m]$ 加上 $S[i]\times x^{m-i}$ 。那么，加了多少遍呢？我们上面假设现在钦定了 $i$ 个括号出了 $a_i$，然后剩下 $m-i$ 个括号出了 $x$。剩下 $m-i$ 个括号显然不是唯一确定的，那么它们有多少种选择呢？显然是 $C_{len-i}^{m-i}$。其中 $len$ 表示线段树当前区间的长度。</p><p>于是，</p><script type="math/tex; mode=display">S[m]=\sum\limits_{i=1}^{m} S[i]\times x^{m-i}\times C_{len-i}^{m-i}</script><h4 id="如何单节点取反"><a href="#如何单节点取反" class="headerlink" title="如何单节点取反"></a>如何单节点取反</h4><p>显然，取反只会改变正负性，不改变绝对值，而且只有奇数位置会被改变正负性。</p><p>即：对于奇数的 $i$，$S[i]$ 变为 $-S[i]$。</p><p>到此，这题涉及到的全部操作都解决了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div><div class="fold_hider"><div class="close hider_title">点击</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 54444</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 19940417</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">I</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args; va_start(args,cnt);</span><br><span class="line">    F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=I();&#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 预处理组合数</span></span><br><span class="line"><span class="keyword">int</span> CC[N][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CC[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">5e4</span>;</span><br><span class="line">F(i,<span class="number">1</span>,n) </span><br><span class="line">&#123;</span><br><span class="line">CC[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">F(j,<span class="number">1</span>,min(<span class="number">20l</span>l,i)) CC[i][j]=(CC[i<span class="number">-1</span>][j<span class="number">-1</span>]+CC[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ====================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> l,r; <span class="keyword">bool</span> f; <span class="keyword">int</span> a,ans[<span class="number">22</span>];&#125;;</span><br><span class="line">node <span class="keyword">operator</span>+(node ls,node rs) <span class="comment">// 合并区间就用重载运算符了</span></span><br><span class="line">&#123;</span><br><span class="line">node cur;</span><br><span class="line">cur.l=ls.l; cur.r=rs.r; cur.f=<span class="number">0</span>; cur.a=<span class="number">0</span>;</span><br><span class="line">FK(cur.ans);</span><br><span class="line">F(i,<span class="number">0</span>,min(<span class="number">20l</span>l,ls.r-ls.l+<span class="number">1</span>)) F(j,<span class="number">0</span>,min(<span class="number">20l</span>l-i,rs.r-rs.l+<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cur.ans[i+j]=(cur.ans[i+j]%mod+ls.ans[i]*rs.ans[j]%mod+<span class="number">2</span>*mod)%mod;</span><br><span class="line">            <span class="comment">// cur.ans[i+j]+=ls.ans[i]*rs.ans[j]</span></span><br><span class="line">            <span class="comment">// 话说取膜好丑啊...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">node tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls index&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs index&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L tree[index].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R tree[index].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C tree[index].f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A tree[index].a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S tree[index].ans</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lL tree[ls].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lR tree[ls].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lC tree[ls].f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lA tree[ls].a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lS tree[ls].ans</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rL tree[rs].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rR tree[rs].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rC tree[rs].f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rA tree[rs].a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rS tree[rs].ans</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> up(index) tree[index]=tree[ls]+tree[rs]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L=l,R=r; C=A=<span class="number">0</span>; FK(S);</span><br><span class="line"><span class="keyword">if</span> (l==r) </span><br><span class="line">&#123;</span><br><span class="line">S[<span class="number">0</span>]=<span class="number">1</span>; S[<span class="number">1</span>]=(I()%mod+mod)%mod; <span class="comment">// 为了方便合并左右，设 S[0]=1</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">Build(l,mid,ls); Build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddOne</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A=(A+x)%mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">22</span>]; p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">F(i,<span class="number">1</span>,min(<span class="number">20l</span>l,R-L+<span class="number">1</span>)) p[i]=p[i<span class="number">-1</span>]*x%mod; <span class="comment">// 预处理出幂</span></span><br><span class="line">S[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">D(i,min(<span class="number">20l</span>l,R-L+<span class="number">1</span>),<span class="number">1</span>) F(j,<span class="number">0</span>,i<span class="number">-1</span>) </span><br><span class="line">&#123;</span><br><span class="line">S[i]=(S[i]+S[j]*p[i-j]%mod*CC[R-L+<span class="number">1</span>-j][i-j]%mod)%mod;</span><br><span class="line">                <span class="comment">// S[i]+=S[j]*x^(i-j)*CC[len-j][i-j];</span></span><br><span class="line">&#125;</span><br><span class="line">F(i,<span class="number">0</span>,min(<span class="number">20l</span>l,R-L+<span class="number">1</span>)) S[i]=(S[i]%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FlipOne</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">F(i,<span class="number">1</span>,min(<span class="number">20l</span>l,R-L+<span class="number">1</span>)) S[i]=(i&amp;<span class="number">1</span>)?(mod-S[i]):S[i];</span><br><span class="line">            <span class="comment">// 奇数位置取反</span></span><br><span class="line">A=mod-A;</span><br><span class="line">            <span class="comment">// 注意：取反会影响到加法标记的！！！</span></span><br><span class="line">C^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (C)</span><br><span class="line">&#123;</span><br><span class="line">FlipOne(ls); FlipOne(rs); C=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (A)</span><br><span class="line">&#123;</span><br><span class="line">AddOne(A,ls); AddOne(A,rs); A=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l&gt;R <span class="keyword">or</span> L&gt;r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (l&lt;=L <span class="keyword">and</span> R&lt;=r) <span class="keyword">return</span> AddOne(x,index);</span><br><span class="line">PushDown(index);</span><br><span class="line">Add(l,r,x,ls); Add(l,r,x,rs);</span><br><span class="line">up(index); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Flip</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l&gt;R <span class="keyword">or</span> L&gt;r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (l&lt;=L <span class="keyword">and</span> R&lt;=r) <span class="keyword">return</span> FlipOne(index);</span><br><span class="line">PushDown(index);</span><br><span class="line">Flip(l,r,ls); Flip(l,r,rs);</span><br><span class="line">up(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l&lt;=L <span class="keyword">and</span> R&lt;=r) <span class="keyword">return</span> tree[index];</span><br><span class="line"></span><br><span class="line">PushDown(index);</span><br><span class="line"><span class="keyword">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (mid&lt;l)  <span class="keyword">return</span> Query(l,r,rs);</span><br><span class="line"><span class="keyword">if</span> (r&lt;=mid) <span class="keyword">return</span> Query(l,r,ls);</span><br><span class="line"><span class="keyword">return</span> Query(l,r,ls)+Query(l,r,rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Rd(<span class="number">2</span>,&amp;n,&amp;m);</span><br><span class="line">T.Build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Init();</span><br><span class="line">F(i,<span class="number">1</span>,m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>]; <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="keyword">if</span> (s[<span class="number">0</span>]==<span class="string">'I'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l,r,x; Rd(<span class="number">3</span>,&amp;l,&amp;r,&amp;x);</span><br><span class="line">T.Add(l,r,x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s[<span class="number">0</span>]==<span class="string">'R'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l,r; Rd(<span class="number">2</span>,&amp;l,&amp;r);</span><br><span class="line">T.Flip(l,r,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s[<span class="number">0</span>]==<span class="string">'Q'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l,r,k; Rd(<span class="number">3</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">node ans=T.Query(l,r,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans.ans[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line"><span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Input();</span><br><span class="line">Soviet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int <span class="comment">//long long</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Flandre_Scarlet::IsMyWife();</span><br><span class="line">getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://lightninguz2.github.io/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="线段树" scheme="https://lightninguz2.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>洛谷-4492-HAOI2018-苹果树-题解</title>
    <link href="https://lightninguz2.github.io/2020/04/11/%E6%B4%9B%E8%B0%B7-4492-HAOI2018-%E8%8B%B9%E6%9E%9C%E6%A0%91-%E9%A2%98%E8%A7%A3/"/>
    <id>https://lightninguz2.github.io/2020/04/11/洛谷-4492-HAOI2018-苹果树-题解/</id>
    <published>2020-04-11T11:01:02.000Z</published>
    <updated>2020-04-11T12:23:31.318Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先膜一发 <a href="https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/solution-p4492" target="_blank" rel="noopener">shadowice1984的题解</a>，太神了！</p><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>你有一个 $n$，表示你的二叉树<strong>将要</strong>有 $n$ 个节点。然后每次你的树会等概率选择某个点的还没长过的儿子，在这里长一个儿子。容易证明，这样有 $n!$ 种方案。</p><p>（第一次有一种方案，第二次两种，第三次三种…一共就是 $n!$ 种）</p><p>然后你要输出树上路径和的期望值乘以 $n!$ 后 $\bmod{p}$ 的值。</p><p>$n,p$ 给定，满足：$n\le 2000,p\le 10^9+7$</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考虑每条边的贡献：如果树是确定的，那么从 $i$ 连向 $i$ 父亲的边，的贡献是 $size_i(n-size_i)$。其中 $size_u$ 表示 $u$ 的子树大小。枚举 $i$，把这个式子加起来就是答案了。</p><p>然后我们现在树是不确定的…注意到 $n\le 2000$，所以我们考虑再加一维枚举 $size$。关键就是，如何计算点 $i$ 的子树里有 $size$ 个点的树的方案数？</p><p>考虑点 $i$ 子树内，有 $size!$ 种生成的形态。然后我们选择哪些点呢？这个方案数有 $C_{n-1}^{size-i}$ 种。</p><p>这一部分答案为 $size!\times C_{n-i}^{size-1}$。</p><p>考虑点 $i$ 子树外。在树生成到 $i$ 之前，有 $i!$ 种方案。然后我们后面的 $n-i-size+1$ 个点，还要保证不能放到 $i$ 子树内。然后第一次有 $i-1$ 种方案，第二次 $i$ 种，第 $k$ 次有 $i-k+2$ 种方案。一共就是 $(i-1)i(i+1)(i+2)…(n-size-1)$ 种方案。</p><p>这一部分答案为 $i!\times (i-1)i(i+1)(i+2)…(n-size-1)=(n-size-1)!\times i (i+1)$</p><p>于是，枚举 $i,size$ 后，总共的答案就是</p><p>$size(n-size) \times size!C_{n-i}^{size-1}\times i(i-1)(n-size-1)!$</p><p>$i$ 从 $2$ 到 $n$，$size$ 从 $1$ 到 $n-i+1$，求和即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">I</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args; va_start(args,cnt);</span><br><span class="line">    F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=I();&#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 预处理阶乘,组合数</span></span><br><span class="line"><span class="keyword">int</span> C[N][N],fac[N];</span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">2000</span>;</span><br><span class="line">C[<span class="number">0</span>][<span class="number">0</span>]=fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">F(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line"></span><br><span class="line">C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">F(j,<span class="number">1</span>,i) C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ====================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Rd(<span class="number">2</span>,&amp;n,&amp;mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InSubtree</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> size)</span> </span>&#123;<span class="keyword">return</span> C[n-i][size<span class="number">-1</span>]*fac[size]%mod;&#125;</span><br><span class="line">    <span class="comment">// 在子树内的方案</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OutSubtree</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> size)</span> </span>&#123;<span class="keyword">return</span> fac[n-size<span class="number">-1</span>]%mod*i%mod*(i<span class="number">-1</span>)%mod;&#125;</span><br><span class="line">    <span class="comment">// 在子树外的方案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">F(i,<span class="number">2</span>,n) F(size,<span class="number">1</span>,n-i+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cur=size*(n-size)%mod;</span><br><span class="line">cur=cur*InSubtree(i,size)%mod;</span><br><span class="line">cur=cur*OutSubtree(i,size)%mod;</span><br><span class="line">ans=(ans+cur)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line"><span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Input();</span><br><span class="line">Init();</span><br><span class="line">Soviet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int <span class="comment">//long long</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Flandre_Scarlet::IsMyWife();</span><br><span class="line">getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://lightninguz2.github.io/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="期望" scheme="https://lightninguz2.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="数学" scheme="https://lightninguz2.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 5295 [北京省选集训2019]图的难题 题解</title>
    <link href="https://lightninguz2.github.io/2020/04/11/%E6%B4%9B%E8%B0%B7-5295-%E5%8C%97%E4%BA%AC%E7%9C%81%E9%80%89%E9%9B%86%E8%AE%AD2019-%E5%9B%BE%E7%9A%84%E9%9A%BE%E9%A2%98-%E9%A2%98%E8%A7%A3/"/>
    <id>https://lightninguz2.github.io/2020/04/11/洛谷-5295-北京省选集训2019-图的难题-题解/</id>
    <published>2020-04-11T11:01:02.000Z</published>
    <updated>2020-04-11T11:51:02.943Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>给你一个 $n$ 个点 $m$ 条边的无向图，判断是否能将一些边染色为白色，其它的染成黑色，并且没有一个纯色的环。</p><p>$n\le 501,m\le 2n$</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一张图有 $E$ 条边，$V$ 个点。那么，它要满足没有纯色的环，$E$ 最大值为 $2(V-1)$（此时的情况就是白色和黑色分别构成两颗生成树）。</p><p>$E\le 2V-2$，可以变成 $E-2V\le -2$。</p><p>那么我们现在总的图都要满足条件，那对于任意一个子图当然也满足条件了。我们可以这样转换：$E-2V$ 最大的子图，也满足 $E-2V\le -2$。</p><p>那如何求 $E-2V$ 最大的子图呢？把边当成点，点当成边，这就变成了最大权闭合子图问题。</p><p>（不会的百度一下）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div><div class="fold_hider"><div class="close hider_title">点击</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100055</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x5f5f5f5f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">I</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args; va_start(args,cnt);</span><br><span class="line">    F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=I();&#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> EdgeCount;</span><br><span class="line">        <span class="keyword">int</span> head[N];</span><br><span class="line">        <span class="keyword">int</span> To[N],Label[N],Next[N];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            MEM(head,<span class="number">-1</span>);</span><br><span class="line">            EdgeCount=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            ++EdgeCount;</span><br><span class="line">            To[EdgeCount]=v; Label[EdgeCount]=w; Next[EdgeCount]=head[u];</span><br><span class="line">            head[u]=EdgeCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Source,Sink;</span><br><span class="line">        <span class="keyword">int</span> deep[N];</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!Q.empty()) Q.pop();</span><br><span class="line">            FK(deep);</span><br><span class="line"></span><br><span class="line">            Q.push(Source);</span><br><span class="line">            deep[Source]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> u=Q.front();Q.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=head[u];~i;i=Next[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> v=To[i];</span><br><span class="line">                    <span class="keyword">if</span> (!deep[v] <span class="keyword">and</span> Label[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        deep[v]=deep[u]+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (v==Sink) &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">                        Q.push(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">while</span>(!Q.empty());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">bool</span>)(deep[Sink]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> MinFlow)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (u==Sink) <span class="keyword">return</span> MinFlow;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> rest=MinFlow;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=head[u];~i <span class="keyword">and</span> rest;i=Next[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> v=To[i];</span><br><span class="line">                <span class="keyword">if</span> (deep[v]==deep[u]+<span class="number">1</span> <span class="keyword">and</span> Label[i]!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> d=DFS(v,min(MinFlow,Label[i]));</span><br><span class="line">                    <span class="keyword">if</span> (!d) deep[v]=<span class="number">0</span>;</span><br><span class="line">                        Label[i]-=d;</span><br><span class="line">                        Label[i^<span class="number">1</span>]+=d;</span><br><span class="line">                        rest-=d;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> MinFlow-rest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(BFS()) ans+=DFS(Source,INF);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;Nt; <span class="comment">// 网络流</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> uu[N],vv[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Rd(<span class="number">2</span>,&amp;n,&amp;m);</span><br><span class="line">F(i,<span class="number">1</span>,m) uu[i]=I(),vv[i]=I();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S Nt.Source</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T Nt.Sink</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AddFlow(u,v,w) &#123;Nt.AddEdge(u,v,w); Nt.AddEdge(v,u,0);&#125;</span></span><br><span class="line">    <span class="comment">// 建流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MustChoose</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="comment">// 强制选择点 s 的答案</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Nt.clear();</span><br><span class="line">F(i,<span class="number">1</span>,m) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=uu[i],v=vv[i];</span><br><span class="line">AddFlow(S,i,<span class="number">1</span>);</span><br><span class="line">AddFlow(i,m+u,INF);</span><br><span class="line">AddFlow(i,m+v,INF);</span><br><span class="line">&#125;</span><br><span class="line">F(i,<span class="number">1</span>,n) <span class="keyword">if</span> (i!=s)</span><br><span class="line">&#123;</span><br><span class="line">AddFlow(i+m,T,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m<span class="number">-2</span>-Nt.Dinic();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S=n+m+<span class="number">1</span>,T=n+m+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> ans=-INF;</span><br><span class="line">F(i,<span class="number">1</span>,n) </span><br><span class="line">&#123;</span><br><span class="line">ans=max(ans,MustChoose(i)); <span class="comment">// 把每个强制选 i 的答案取 max，就是最大闭合子图了</span></span><br><span class="line"><span class="keyword">if</span> (ans&gt;<span class="number">-2</span>) &#123;<span class="built_in">puts</span>(<span class="string">"No"</span>); <span class="keyword">return</span>;&#125; <span class="comment">// 每一个都要 &lt;=-2，有一个 &gt; 就直接输出 No</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>((ans&lt;=<span class="number">-2</span>)?<span class="string">"Yes"</span>:<span class="string">"No"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line"><span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=I();</span><br><span class="line">F(i,<span class="number">1</span>,t)</span><br><span class="line">&#123;</span><br><span class="line">Input();</span><br><span class="line">Soviet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Flandre_Scarlet::IsMyWife();</span><br><span class="line">getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://lightninguz2.github.io/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="思维" scheme="https://lightninguz2.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="网络流" scheme="https://lightninguz2.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 5112 FZOUTSY 题解</title>
    <link href="https://lightninguz2.github.io/2020/04/11/%E6%B4%9B%E8%B0%B7-5112-FZOUTSY-%E9%A2%98%E8%A7%A3/"/>
    <id>https://lightninguz2.github.io/2020/04/11/洛谷-5112-FZOUTSY-题解/</id>
    <published>2020-04-11T10:02:36.000Z</published>
    <updated>2020-04-11T10:26:12.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>给定字符串 $S$，设 $suf(i)$ 表示从 $i$ 开始的后缀。支持 $q$ 个询问，每次给定 $[l,r]$，求这段区间中有多少对 $i,j$  使得 $suf(i)$ 和 $suf(j)$ 的最长公共前缀长度 $\ge k$。$k$ 是一个定值，每次都一样。</p><p>（备注：$(i,j)$ 和 $(j,i)$ 是同样的一对，只算一次）</p><p>$k\le |S|\le 3\times 10^6,m\le 10^5$，并且满足 $n^2m\le 10^{15}$。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>$n^2m\le 10^{15}$？这看起来很奇怪。</p><p>冷静分析一下，这提示着我们，$O(n\sqrt{m})$ 的算法是可以通过的。仔细想一下 ，带根号的静态区间询问的算法…</p><p><strong>莫队</strong> ！</p><p>然后，$suf(i),suf(j)$ 最长公共前缀长度 $\ge k$，等价于：$i$ 往后 $k$ 个的子串，和 $j$ 往后 $k$ 个的子串相同。</p><p>然后我们要快速比较两端子串是否相同…</p><p><strong>哈希</strong> ！</p><p>于是问题变为：</p><ol><li>处理第 $i$ 位往后 $k$ 个位置的哈希值，设为 $h[i]$</li><li>每次询问，就相当于询问 $h[l,r]$ 中有多少不重复的数，显然可以莫队维护。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div><div class="fold_hider"><div class="close hider_title">点击</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3000006</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">I</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args; va_start(args,cnt);</span><br><span class="line">    F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=I();&#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k; <span class="keyword">char</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Rd(<span class="number">3</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,a+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll pre[N],pw[N];</span><br><span class="line"><span class="function">ll <span class="title">RHash</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;<span class="keyword">return</span> pre[r]-pre[l<span class="number">-1</span>]*pw[r-l+<span class="number">1</span>];&#125; <span class="comment">// Range Hash，求区间哈希值</span></span><br><span class="line"></span><br><span class="line">ll h[N]; <span class="built_in">unordered_map</span>&lt;ll,<span class="keyword">int</span>&gt; desc;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> l,r,id;&#125;q[N]; <span class="keyword">int</span> sn; <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node a,node b)&#123;<span class="keyword">return</span> (a.l/sn&lt;b.l/sn) <span class="keyword">or</span> (a.l/sn==b.l/sn <span class="keyword">and</span> a.r&lt;b.r);&#125; </span><br><span class="line">    <span class="comment">// 莫队</span></span><br><span class="line">    <span class="comment">// sn 为块大小</span></span><br><span class="line">ll cnt[N]; ll cur=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cur+=cnt[h[x]]; cnt[h[x]]++;&#125; <span class="comment">// 加入一个位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cnt[h[x]]--; cur-=cnt[h[x]];&#125; <span class="comment">// 删除一个位置</span></span><br><span class="line">ll ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pw[<span class="number">0</span>]=<span class="number">1</span>; F(i,<span class="number">1</span>,n) pw[i]=pw[i<span class="number">-1</span>]*<span class="number">233l</span>l; <span class="comment">// 哈希底数开大点</span></span><br><span class="line">F(i,<span class="number">1</span>,n) pre[i]=(pre[i<span class="number">-1</span>]*<span class="number">233l</span>l+(a[i]-<span class="string">'a'</span>));</span><br><span class="line"></span><br><span class="line">F(i,<span class="number">1</span>,n-k+<span class="number">1</span>) h[i]=RHash(i,i+k<span class="number">-1</span>); <span class="comment">// 预处理出 h[i] 数组</span></span><br><span class="line"><span class="keyword">int</span> dcnt=<span class="number">0</span>;</span><br><span class="line">F(i,<span class="number">1</span>,n-k+<span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!desc[h[i]]) desc[h[i]]=++dcnt;</span><br><span class="line">h[i]=desc[h[i]];</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 离散化</span></span><br><span class="line">        <span class="comment">// 只是一个重新编号</span></span><br><span class="line">        <span class="comment">// 我们只保证：原来相等的还相等，原来不相等的还不相等</span></span><br><span class="line">        <span class="comment">// 并不保证 &lt; 的关系 （也没有必要）</span></span><br><span class="line"></span><br><span class="line">sn=n/<span class="built_in">sqrt</span>(m); </span><br><span class="line">        <span class="comment">// 块长开 n/sqrt(m)</span></span><br><span class="line"><span class="comment">// 据说开 sqrt(n) 也不会被卡</span></span><br><span class="line">        F(i,<span class="number">1</span>,m) q[i]=(node)&#123;I(),min(I(),n-k+<span class="number">1</span>),i&#125;;</span><br><span class="line">        <span class="comment">// 因为右端点 &gt;n-k+1 的时候显然不可能有长度为 k 的最长公共前缀</span></span><br><span class="line">        <span class="comment">// 所以 r 和 n-k+1 取 min</span></span><br><span class="line">sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>; cur=<span class="number">0l</span>l;</span><br><span class="line">F(i,<span class="number">1</span>,m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q[i].l&gt;q[i].r) &#123;ans[q[i].id]=<span class="number">0</span>; <span class="keyword">continue</span>;&#125; <span class="comment">// 会有这种情况...判掉</span></span><br><span class="line"><span class="keyword">while</span>(r&lt;q[i].r) ++r,Add(r);</span><br><span class="line"><span class="keyword">while</span>(r&gt;q[i].r) Del(r),--r;</span><br><span class="line"> <span class="keyword">while</span>(l&lt;q[i].l) Del(l),++l;</span><br><span class="line"><span class="keyword">while</span>(l&gt;q[i].l) --l,Add(l);</span><br><span class="line">ans[q[i].id]=cur;</span><br><span class="line">&#125; </span><br><span class="line">F(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line"><span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Input();</span><br><span class="line">Soviet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int <span class="comment">//long long </span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Flandre_Scarlet::IsMyWife();</span><br><span class="line">getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="莫队" scheme="https://lightninguz2.github.io/tags/%E8%8E%AB%E9%98%9F/"/>
    
      <category term="哈希" scheme="https://lightninguz2.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>libreoj 6270 数据结构板子题 题解</title>
    <link href="https://lightninguz2.github.io/2020/04/06/libreoj-6270-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90%E9%A2%98-%E9%A2%98%E8%A7%A3/"/>
    <id>https://lightninguz2.github.io/2020/04/06/libreoj-6270-数据结构板子题-题解/</id>
    <published>2020-04-06T02:30:40.000Z</published>
    <updated>2020-04-06T02:51:37.354Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>给定 $n$ 个区间 $[l_i,r_i]$，和 $Q$ 个询问，每次给你三个整数 $[l,r,k]$，求被 $[l,r]$ 完全包含且长度 $\ge k$ 的区间数量。</p><p>注：定义一个区间  $[l,r]$ 的长度是 $r-l$。 </p><p>$n,q\le 10^6$，$1\le l_i,r_i,l,r,k\le n$，$l_i&lt;r_i,l&lt;r$</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果没有 $k$ 的限制，只是要求完全包含的区间数量，可以用两个树状数组，然后计算右端点在 $[1,r]$ 中的数量减去左端点在 $[1,l-1]$ 中的数量。</p><p>然后现在有了 $k$ 的限制，我们把一个询问拆成 $[l,r,r-l]$ 减去 $[l,r,k-1]$。然后把询问和区间都按长度排序，一个一个处理即可。还有就是记录一下这个答案属于第几个询问，带正号还是带负号</p><p>（$[l,r,r-l]$ 带正号，$[l,r,k-1]$ 带负号，看上面答案是怎么算的）</p><p>然后就做完了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div><div class="fold_hider"><div class="close hider_title">点击</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1666666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">I</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args; va_start(args,cnt);</span><br><span class="line">    F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=I();&#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> tree[N],len;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> _len)</span> </span>&#123;FK(tree); len=_len;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(pos&lt;=len) tree[pos]+=x,pos+=(pos&amp;(-pos));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos&gt;<span class="number">0</span>) ans+=tree[pos],pos-=(pos&amp;(-pos));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;L,R;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span>&#123;</span><span class="keyword">int</span> l,r;&#125;a[N]; <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(seg a,seg b)&#123;<span class="keyword">return</span> a.r-a.l&lt;b.r-b.l;&#125;</span><br><span class="line">    <span class="comment">// 给定的线段，按长度排序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">que</span>&#123;</span><span class="keyword">int</span> l,r,k,id,tp;&#125;q[N]; <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(que a,que b)&#123;<span class="keyword">return</span> a.k&lt;b.k;&#125;</span><br><span class="line"><span class="comment">// 询问，也是按长度排序</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> n,m; <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Rd(<span class="number">2</span>,&amp;n,&amp;m);</span><br><span class="line">F(i,<span class="number">1</span>,n) &#123;a[i].l=I(); a[i].r=I();&#125;</span><br><span class="line">F(i,<span class="number">1</span>,m) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l,r,k; Rd(<span class="number">3</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line"><span class="keyword">if</span> (k&gt;r-l) <span class="keyword">continue</span>;</span><br><span class="line">q[++cnt]=(que)&#123;l,r,r-l,i,<span class="number">1</span>&#125;; <span class="comment">// 记录编号和符号</span></span><br><span class="line">q[++cnt]=(que)&#123;l,r,k<span class="number">-1</span>,i,<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>); sort(q+<span class="number">1</span>,q+cnt+<span class="number">1</span>);</span><br><span class="line">L.Build(n); R.Build(n); <span class="comment">// 两颗树状数组，记录左端点和右端点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">1</span>;</span><br><span class="line">F(i,<span class="number">1</span>,cnt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(pos&lt;=n <span class="keyword">and</span> a[pos].r-a[pos].l&lt;=q[i].k) </span><br><span class="line">&#123;</span><br><span class="line">L.Add(a[pos].l,<span class="number">1</span>); R.Add(a[pos].r,<span class="number">1</span>); ++pos;</span><br><span class="line">&#125;</span><br><span class="line">ans[q[i].id]+=q[i].tp*(R.Query(q[i].r)-L.Query(q[i].l<span class="number">-1</span>));</span><br><span class="line">&#125; </span><br><span class="line">F(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line"><span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Input();</span><br><span class="line">Soviet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Flandre_Scarlet::IsMyWife();</span><br><span class="line">getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="思维" scheme="https://lightninguz2.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="树状数组" scheme="https://lightninguz2.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>bzoj 5102 [POI2018]Prawnicy 题解</title>
    <link href="https://lightninguz2.github.io/2020/04/06/bzoj-5102-POI2018-Prawnicy-%E9%A2%98%E8%A7%A3/"/>
    <id>https://lightninguz2.github.io/2020/04/06/bzoj-5102-POI2018-Prawnicy-题解/</id>
    <published>2020-04-06T00:53:40.000Z</published>
    <updated>2020-04-06T01:11:55.948Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>给你 $n$ 个区间 $[l_i,r_i]$，选出 <strong>恰好</strong> $k$ 个，使得交集最大。输出最长的长度和方案。</p><p>注：区间 $[l,r]$ 的长度被定义为 $r-l$。</p><p> $1\le k\le n\le 10^5$。 </p><h3 id="思路框架"><a href="#思路框架" class="headerlink" title="思路框架"></a>思路框架</h3><p>若干的区间的交集，显然，左端点是所有左端点的最大值，右端点是所有右端点的最小值。</p><p>然后我们枚举左端点的最大值。怎么枚举呢？按左端点从小到大排序，枚举到 $i$ 表示只能用 $i$ 之前的区间。那么所有的左端点就都 $\le l_i$ 了。</p><p>然后这个时候我们怎么选最大值呢？</p><ol><li>我们只能在 $1\sim i$  中选</li><li>选择 $k$ 个使得最小值最大</li></ol><p>怎么选择 $k$ 个使得最小值最大呢？那肯定是从大到小排序之后选前 $k$ 个啊！然后这时候最大的最小值，就是从大到小之后排第 $k$ 位的数。那么我们现在就是要支持动态插入（无删除）的第 $k$ 大。可以用对顶堆做。</p><div><div class="fold_hider"><div class="close hider_title">点击</div></div><div class="fold"><h4 id="对顶堆如何做"><a href="#对顶堆如何做" class="headerlink" title="对顶堆如何做"></a>对顶堆如何做</h4><p>维护一个小根堆（堆顶是最小值），和一个大根堆（堆顶是最大值）。我们默认把数字插入到小根堆中，如果小根堆中的数字个数 $&gt;k$，那么我们把小根堆中的 <strong>最小值</strong> 放到大根堆里。</p><p>那么有一个显然易证的性质：大根堆中的所有数，任何时候都 $\le$ 小根堆中的所有数。也就是，大根堆的堆顶 $\le$ 小根堆的堆顶。</p><p>而且我们还保证了小根堆中只有 $k$ 个数。那么这 $k$ 个数 $\ge$ 当前的其它所有数，显然，这 $k$ 个数字就是前 $k$ 大。求出这 $k$ 个数中的最小值（小根堆顶），就是当前的第 $k$ 大。</p><p>这个办法也可以用于求中位数 （也就是 $k$ 不一定静态，单调递增的情况也可以求）</p></div></div><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div><div class="fold_hider"><div class="close hider_title">点击</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> N 1666666</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> all(a) a.begin(),a.end()</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">I</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">        <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">        <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        va_list args; va_start(args,cnt);</span><br><span class="line">        F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=I();&#125;</span><br><span class="line">        va_end(args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> l,r,id;&#125; a[N];</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node a,node b)&#123;<span class="keyword">return</span> a.l&lt;b.l;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Rd(<span class="number">2</span>,&amp;n,&amp;k);</span><br><span class="line">        F(i,<span class="number">1</span>,n) a[i]=(node)&#123;I(),I(),i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; Q1; <span class="comment">// 小根堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; Q2; <span class="comment">// 大根堆</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> Max=<span class="number">-0x3f3f3f3f</span>,l,r;</span><br><span class="line">        F(i,<span class="number">1</span>,n)</span><br><span class="line">        &#123;</span><br><span class="line">            Q1.push(a[i].r);</span><br><span class="line">            <span class="keyword">if</span> (sz(Q1)&gt;k) </span><br><span class="line">            <span class="comment">// 其实这里理论上应该是个 while 循环</span></span><br><span class="line">            <span class="comment">// 然而实际上我们每次只会新加入一个数，那么 sz(Q1) 顶多等于 k+1，弹一次即可</span></span><br><span class="line">            <span class="comment">// 写中位数的话，这里要改成 while !</span></span><br><span class="line">            &#123;</span><br><span class="line">                Q2.push(Q1.top()); Q1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (i&gt;=k) <span class="comment">// 这里注意判一下 i&gt;=k，很重要，会出错！ （我就挂在这的QaQ</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> rr=Q1.top(),ll=a[i].l;</span><br><span class="line">                <span class="keyword">if</span> (rr-ll&gt;Max)</span><br><span class="line">                &#123;</span><br><span class="line">                    Max=rr-ll; l=ll; r=rr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Max);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        F(i,<span class="number">1</span>,n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i].l&lt;=l <span class="keyword">and</span> r&lt;=a[i].r) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i].id);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt==k) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line">    <span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Input();</span><br><span class="line">        Soviet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Flandre_Scarlet::IsMyWife();</span><br><span class="line">    getchar();getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="思维" scheme="https://lightninguz2.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="贪心" scheme="https://lightninguz2.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="优先队列" scheme="https://lightninguz2.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>libreoj 2037 洛谷 4344 [SHOI2015]脑洞治疗仪 题解</title>
    <link href="https://lightninguz2.github.io/2020/04/01/libreoj-2037-%E6%B4%9B%E8%B0%B7-4344-SHOI2015-%E8%84%91%E6%B4%9E%E6%B2%BB%E7%96%97%E4%BB%AA-%E9%A2%98%E8%A7%A3/"/>
    <id>https://lightninguz2.github.io/2020/04/01/libreoj-2037-洛谷-4344-SHOI2015-脑洞治疗仪-题解/</id>
    <published>2020-04-01T14:17:11.000Z</published>
    <updated>2020-04-06T00:54:23.325Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>友链：<a href="https://www.luogu.com.cn/blog/180242/solution-p4344" target="_blank" rel="noopener">zhk 的题解</a></p><p>但是我觉得他这篇里面提的有点简单（主要是没给代码），于是我自己来写一下~</p><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>zps 是又可爱又傻的女孩子！于是她决定自己治疗她的脑子</p><p>zps 的垃圾脑子是一个长度为 $n$ 的序列，每个位置用 $1$ 表示这里有脑组织，$0$ 表示有脑洞（没有脑组织）。初始时全部正常。支持操作若干：</p><p><code>0 l r</code> zps 在 $[l,r]$ 之间所有脑组织都挖掉</p><p><code>1 l0 r0 l1 r1</code> zps 把 $[l_0,r_0]$ 中的脑组织都挖出来，假设有 $K$ 个，那么她会用这些脑洞来填补 $[l_1,r_1]$ 中从左到右前 $K$ 个脑洞。如果还有剩下的脑组织，她会选择直接扔掉</p><p><code>3 l r</code> 询问区间 $[l,r]$ 中，最长连续脑洞长度。</p><p>$1\le n,m\le 2\times 10^5$</p><h3 id="思路框架"><a href="#思路框架" class="headerlink" title="思路框架"></a>思路框架</h3><p>线段树维护。我们整理一下需要哪些操作。</p><p>对于 $0$ 操作，我们需要区间覆盖操作</p><p>对于 $1$ 操作，我们需要求出 $[l_0,r_0]$ 中的脑洞个数 $K$（即维护区间和 $S$），把这一段区间全都覆盖为 $0$，然后还要把 $l_1,r_1$ 的前 $k$ 个脑洞变成脑组织。</p><p>对于 $2$ 操作，我们要支持维护区间的最大连续长度操作。</p><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>要维护区间<strong>脑洞个数</strong> $S$，然后要维护最长左连续脑洞长度 $LC$，右连续脑洞长度 $RC$，还有一个最长连续脑洞长度 $X$。</p><p>$S$ 就是左右加起来，显然。</p><p>如果左儿子的 $LC$ 等于左儿子的长度，那么我们的 $LC$ 跨过整个左半边再加上右儿子的 $LC$。否则 $LC$ 等于左儿子的 $LC$。</p><p>$RC$ 和 $LC$ 类似的，就是判一下能不能跨过整个右半边。</p><p>$X$ 就等于左右儿子 $X$ 的最大值，再和 左 $RC$ 加上右 $LC$ 取 $\max$。</p><p>我们把每个线段树节点封装成一个 <code>struct</code>，然后重载运算符来实现这个合并。</p><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><h5 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h5><p>我们打一个 $C$ 标记 （<code>C=Cover</code>）。然后每次我们先打一下 $C$ 标记，然后如果覆盖的是 $0$（脑洞），$S=LC=RC=X=R-L+1$。否则 $S=LC=RC=X=0$。</p><h5 id="区间填充前-k-个"><a href="#区间填充前-k-个" class="headerlink" title="区间填充前 k 个"></a>区间填充前 k 个</h5><p>把区间分成左右两块，设左半边的脑洞个数为 $lson$。</p><p>如果 $k&lt;=lson$，那么只在左边填即可。</p><p>否则我们就把左半区间整个覆盖上 $1$ （脑组织），然后在右半边填充 $k-lson$ 个。</p><p>线段树上查找的边界为，当：</p><ol><li>当前区间完全被查询区间覆盖</li><li>（且）$k&gt;=S$</li></ol><p>（这种情况显然是直接整个区间覆盖上 $1$ 就行了）</p><p>为了方便写代码，我们填充完 一段区间后，函数返回一个整数，表示成功填充了多少个。 （就是有多少挖出来的脑组织没有被扔掉）。后面就会知道它为啥好写了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 255555</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">R</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args; va_start(args,cnt);</span><br><span class="line">    F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=R();&#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> l,r,lc,rc,s,x,c;&#125; ;</span><br><span class="line">node <span class="keyword">operator</span>+(node ls,node rs) <span class="comment">// 重载一个加号~</span></span><br><span class="line">&#123;</span><br><span class="line">node t;</span><br><span class="line">t.l=ls.l; t.r=rs.r; t.c=<span class="number">-1</span>;</span><br><span class="line">t.s=ls.s+rs.s;</span><br><span class="line">t.x=max(max(ls.x,rs.x),ls.rc+rs.lc);</span><br><span class="line">t.lc=ls.lc; <span class="keyword">if</span> (ls.lc==ls.r-ls.l+<span class="number">1</span>) t.lc+=rs.lc;</span><br><span class="line">t.rc=rs.rc; <span class="keyword">if</span> (rs.rc==rs.r-rs.l+<span class="number">1</span>) t.rc+=ls.rc;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegementTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">node tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls index&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs index&lt;&lt;1|1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L  tree[index].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R  tree[index].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC tree[index].lc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC tree[index].rc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S  tree[index].s</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X  tree[index].x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C  tree[index].c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> index=<span class="number">1</span>)</span> </span>&#123;tree[index]=tree[ls]+tree[rs];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> index=<span class="number">1</span>)</span> <span class="comment">// 常规的建树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L=l,R=r;</span><br><span class="line"><span class="keyword">if</span> (l==r) &#123;S=X=LC=RC=<span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="comment">// 一开始都是脑组织，所以脑洞数量为 0</span></span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">Build(l,mid,ls); Build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">Update(index); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CoverOne</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> index=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C=x;</span><br><span class="line"><span class="keyword">if</span> (x==<span class="number">1</span>) &#123;S=X=LC=RC=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">else</span>   &#123;S=X=LC=RC=R-L+<span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> index=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (~C)</span><br><span class="line">&#123;</span><br><span class="line">CoverOne(C,ls); CoverOne(C,rs);</span><br><span class="line">C=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cover</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> index=<span class="number">1</span>)</span> <span class="comment">// 区间覆盖操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l&gt;R <span class="keyword">or</span> L&gt;r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (l&lt;=L <span class="keyword">and</span> R&lt;=r) <span class="keyword">return</span> CoverOne(x,index);</span><br><span class="line">PushDown(index);</span><br><span class="line">Cover(l,r,x,ls); Cover(l,r,x,rs);</span><br><span class="line">Update(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fill</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> cnt,<span class="keyword">int</span> index=<span class="number">1</span>)</span> <span class="comment">// 区间填充操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l&lt;=L <span class="keyword">and</span> R&lt;=r <span class="keyword">and</span> cnt&gt;=S) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> s=S;</span><br><span class="line">CoverOne(<span class="number">1</span>,index);</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PushDown(index);</span><br><span class="line"><span class="keyword">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>; <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (r&lt;=mid) sum=Fill(l,r,cnt,ls);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (l&gt;mid) sum=Fill(l,r,cnt,rs);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sum=Fill(l,mid,cnt,ls); </span><br><span class="line"><span class="keyword">if</span> (cnt&gt;sum) sum+=Fill(mid+<span class="number">1</span>,r,cnt-sum,rs);</span><br><span class="line">&#125;</span><br><span class="line">Update(index);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> index=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l&lt;=L <span class="keyword">and</span> R&lt;=r) <span class="keyword">return</span> tree[index];</span><br><span class="line">PushDown(index);</span><br><span class="line"><span class="keyword">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (r&lt;=mid) <span class="keyword">return</span> Query(l,r,ls);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (l&gt;mid) <span class="keyword">return</span> Query(l,r,rs);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> Query(l,mid,ls)+Query(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Rd(<span class="number">2</span>,&amp;n,&amp;q);</span><br><span class="line">T.Build(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">F(i,<span class="number">1</span>,q)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> o,l,r; Rd(<span class="number">3</span>,&amp;o,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">if</span> (o==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">T.Cover(l,r,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (o==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l2,r2; Rd(<span class="number">2</span>,&amp;l2,&amp;r2);</span><br><span class="line"><span class="keyword">int</span> cnt=(r-l+<span class="number">1</span>)-T.Query(l,r).s;</span><br><span class="line">T.Cover(l,r,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (cnt&gt;<span class="number">0</span>) T.Fill(l2,r2,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (o==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,T.Query(l,r).x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line"><span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Input();</span><br><span class="line">Soviet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Flandre_Scarlet::IsMyWife();</span><br><span class="line">getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="线段树" scheme="https://lightninguz2.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>扩展卢卡斯定理 笔记</title>
    <link href="https://lightninguz2.github.io/2020/03/27/%E6%89%A9%E5%B1%95%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86-%E7%AC%94%E8%AE%B0/"/>
    <id>https://lightninguz2.github.io/2020/03/27/扩展卢卡斯定理-笔记/</id>
    <published>2020-03-27T02:14:20.000Z</published>
    <updated>2020-03-27T04:42:00.385Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先问一个简单的问题，求：</p><script type="math/tex; mode=display">C_{n}^{m}\pmod {q}</script><p><strong>不保证</strong> $q$ <strong>是质数</strong>。$1\le q\le 10^6,1\le m\le n\le 10^{18}$。</p><p>（<a href="https://www.luogu.com.cn/problem/P4720" target="_blank" rel="noopener">原题：洛谷上的板子</a>）</p><p>这很毒瘤了！我们平常熟知的几个方法，预处理阶乘和阶乘逆元，或者是 <code>Lucas</code> 定理，都需要 $q$ 为质数才能这么干。现在 $q$ 连质数都不是，可咋整呢…</p><h3 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h3><p>主题思路</p><ol><li>我们用公式 $C_n^m=\dfrac{n!}{m!(n-m)!}$</li><li>把 $q$ 分解质因数，分解成若干的 $p^k$ 相乘的形式 </li><li>现在假设模数为 $p^k$，求 $C_n^m \pmod {p^k}$</li><li>用中国剩余定理合并答案</li></ol><p>那么，卢卡斯定理呢？引用某神仙写题解时，说过的一句话：</p><blockquote><p>首先，得确定先会扩展欧几里得算法和扩展中国剩余定理。至于卢卡斯定理，那并不重要。</p><p>—— <a href="https://www.luogu.com.cn/user/7035" target="_blank" rel="noopener">Great_Influence 神仙</a></p></blockquote><p>（扩展卢卡斯定理和卢卡斯定理并没有任何关系2333）</p><h4 id="对每个质因数求答案"><a href="#对每个质因数求答案" class="headerlink" title="对每个质因数求答案"></a>对每个质因数求答案</h4><p>我们发现，$n$ 的范围比 $q$ 要大很多。也就是说，分子分母两个阶乘很可能都是 $0$。</p><p>那么就出现了一个想法：我们把分子分母中的含 $p$ 的因子都<strong>单独拿出来</strong>。</p><p>设 $n!$ 中最多包含 $a$ 个 $p$ 因子，$m!$ 和 $(n-m)!$  中分别包含 $b,c$ 个。设 $f(x)$ 表示把 $x!$ 中的 $p$  因子都去掉后的值，于是答案等于</p><script type="math/tex; mode=display">\dfrac{f(n)}{f(m)f(n-m)}\times p^{a-b-c} \pmod{p^k}</script><p>然后现在我们要求两个东西：</p><ol><li>$f(x)$ （定义见上）</li><li>$x!$ 中有多少 $p$ 因子，设为 $g(x)$（这个小学就会了吧，$g(x)=g(x/p)+(x/p)$）</li></ol><p>那怎么求 $f(x)$ 呢？</p><h5 id="第一部分：拿掉所有倍数"><a href="#第一部分：拿掉所有倍数" class="headerlink" title="第一部分：拿掉所有倍数"></a>第一部分：拿掉所有倍数</h5><p>先把所有 $p$ 的倍数都拿掉，大概等于：</p><p>$[1\times 2\times 3\times …\times (p-1)]\times [(p+1)\times (p+2)\times (p+3)…\times (2p-1)]\times …$ </p><p>（一直乘到 $x$ 往下最后一个不是 $p$ 的倍数的数）</p><p>然后你们就会发现我偷偷的把每 $p-1$ 个数分在了同一个中括号里面。我们称这一个中括号为“一组”。组从 $1$ 开始编号（也就是 $1\times 2\times …\times (p-1)$ 是第 $1$ 组，然后剩下的依次编号）</p><p>找一下规律： 第 $x$ 组的积就等于 $[xp-p+1,xp-1]$ 之间的数的积。</p><p>然后考虑 $p^k-1$ 这个数，它显然是第 $p^{k-1}$ 组的最后一个。那它下一组，就是以下这些数的乘积：</p><p>$p^k+1,p^k+2,… p^k+p-1$。</p><p>别忘了我们的 $f(x)$ 模数是 $p^k$ （见上面的式子）。所以，很显然，这些数同余于：</p><p>$1,2,…p-1$</p><p>这和第一组是一样的了。那就出现了 <strong>循环节</strong>！</p><p>我们设“一节”的积为 $S$，那它就等于第 $1$ 组，第 $2$ 组,…第 $p^{k-1}$ 组中的所有数的乘积。</p><p>显然，$x!$ 一共能分出 $\dfrac{x}{p^k}$ 个 $S$。</p><p>当然，还有 $x \bmod {p^k}$ 个不完整的“一节”，设为 $R$。暴力计算即可。</p><p>这一部分的答案（设为 $A$）就等于 $(S)^{\frac{x}{p^k}} \times R$</p><p>那么求 $S$ 和求最后几个不完整的块，就都是 $O(p^k)$ 的了。因为 $q\le 10^6$，所以不会有问题。</p><h5 id="第二部分：只考虑-p-的倍数"><a href="#第二部分：只考虑-p-的倍数" class="headerlink" title="第二部分：只考虑 p 的倍数"></a>第二部分：只考虑 p 的倍数</h5><p>那这一部分就等于</p><p>$p\times 2p \times 3p \times …\times (n/p)p$</p><p>然后我们要去掉所有 $p$ 的因子。于是剩下了一个 $(n/p)!$</p><p>但是我们发现这个玩意要递归计算…于是这一部分答案为 $f(n/p)$</p><h5 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h5><script type="math/tex; mode=display">f(x)=\begin{cases}1\ & (\texttt{if}\quad x=1) \\f(x/p)+A  & (\texttt{else}) \\ \end{cases}</script><p>时间复杂度 $O(p^k\log x)$</p><h4 id="中国剩余定理合并答案"><a href="#中国剩余定理合并答案" class="headerlink" title="中国剩余定理合并答案"></a>中国剩余定理合并答案</h4><p>什么？你中国剩余定理不会？</p><p>额…好的，我会写（gu）博（gu）客（gu）的！</p><h3 id="洛谷上的板子代码"><a href="#洛谷上的板子代码" class="headerlink" title="洛谷上的板子代码"></a>洛谷上的板子代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下注释中的 ^ 均表示幂</span></span><br><span class="line"><span class="comment">// （这个代码里面没有异或.......</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 155555</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R1</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    x=(f==<span class="number">1</span>)?x:-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args,cnt);</span><br><span class="line">    F(i,<span class="number">1</span>,cnt) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);R1(*x);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,p;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Rd(<span class="number">3</span>,&amp;n,&amp;k,&amp;p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> m)</span> <span class="comment">// 快速幂，不用细看，求 a^b%m</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b&amp;<span class="number">1</span>) r=r*a%m;</span><br><span class="line">a=a*a%m,b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> <span class="comment">// exgcd，用来求逆元，以及中国剩余定理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b==<span class="number">0</span>) &#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> x2,y2;</span><br><span class="line">exgcd(b,a%b,x2,y2);</span><br><span class="line">x=y2; y=x2-(a/b)*y2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> p)</span> <span class="comment">// 求 a 模 p 的逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x,y; exgcd(a,p,x,y);</span><br><span class="line"><span class="keyword">return</span> (x%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a/__gcd(a,b)*b;&#125;</span><br><span class="line">    <span class="comment">// 以下函数中的 pk 参数均表示 p^k</span></span><br><span class="line">    <span class="comment">// 分解质因数的时候顺便求的，这样就不用再求一遍快速幂了</span></span><br><span class="line">    <span class="comment">// 常数小~</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p,<span class="keyword">int</span> pk)</span> <span class="comment">// 这个就是 f 函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r1=<span class="number">1</span>; <span class="comment">// r1 就是上面说的 A，表示完整部分</span></span><br><span class="line">F(i,<span class="number">1</span>,pk) <span class="keyword">if</span> (i%p) r1=(r1*i)%pk;</span><br><span class="line">r1=qpow(r1,n/pk,pk); <span class="comment">// 乘一个 n/pk</span></span><br><span class="line"><span class="keyword">int</span> r2=<span class="number">1</span>; <span class="comment">// r2 就是上面说的 R，表示剩余部分</span></span><br><span class="line">        <span class="comment">// 写解析的时间和上代码的时间并不同步，所以...名字不同，稍微转化下</span></span><br><span class="line">F(i,(n/pk)*pk,n) <span class="keyword">if</span> (i%p) r2=(r2*(i%pk))%pk;</span><br><span class="line"><span class="keyword">return</span> fac(n/p,p,pk)*r1%pk*r2%pk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span> <span class="comment">// 求 n! 中有多少 p 因子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> n/p+g(n/p,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> p,<span class="keyword">int</span> pk)</span> <span class="comment">// 求 C(n,m)%pk</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> f1=fac(n,p,pk);</span><br><span class="line"><span class="keyword">int</span> i1=inv(fac(m,p,pk),pk),i2=inv(fac(n-m,p,pk),pk);</span><br><span class="line"><span class="keyword">int</span> gg=g(n,p)-g(m,p)-g(n-m,p);</span><br><span class="line"><span class="keyword">return</span> f1%pk*i1%pk*i2%pk*qpow(p,gg,pk)%pk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m[N],a[N];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> <span class="comment">// 求方程 ax+by=c 的其中一组特殊解，直接修改 x,y 的值并返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> g=__gcd(a,b); </span><br><span class="line"><span class="keyword">if</span> (c%g) &#123;x=<span class="number">-1e9</span>; y=<span class="number">-1e9</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">a/=g; b/=g; c/=g;</span><br><span class="line">exgcd(a,b,x,y);</span><br><span class="line">x*=c; y*=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">China</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="comment">// 中国剩余定理（看这伟大的函数名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> M=m[<span class="number">1</span>],A=a[<span class="number">1</span>];</span><br><span class="line">F(i,<span class="number">2</span>,cnt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">solve(M,m[i],a[i]-A,x,y);</span><br><span class="line"><span class="keyword">if</span> (x==<span class="number">-1e9</span> <span class="keyword">and</span> y==<span class="number">-1e9</span>) &#123;<span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line">x%=m[i];</span><br><span class="line">A=(A+M*x);</span><br><span class="line">M=lcm(M,m[i]);</span><br><span class="line">A=(A%M+M)%M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exLucas</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> mod)</span> <span class="comment">// 正片：求 C(n,k)%mod</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=mod;++i) <span class="keyword">if</span> (mod%i==<span class="number">0</span>) <span class="comment">// 分解质因数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> p=i,pk=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(mod%i==<span class="number">0</span>) pk*=i,mod/=i;</span><br><span class="line">            <span class="comment">// 找到一个质因数，就顺便把 p^k 给求了</span></span><br><span class="line">++cnt;</span><br><span class="line">m[cnt]=pk;</span><br><span class="line">a[cnt]=C(n,k,p,pk)%pk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mod!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">++cnt;</span><br><span class="line">m[cnt]=mod;</span><br><span class="line">a[cnt]=C(n,k,mod,mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> China();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,exLucas(n,k,p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line"><span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Input();</span><br><span class="line">Soviet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int <span class="comment">//long long</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Flandre_Scarlet::IsMyWife();</span><br><span class="line">getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://lightninguz2.github.io/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="组合数学" scheme="https://lightninguz2.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>libreoj 10051 「一本通 2.3 例 3」Nikitosh 和异或 </title>
    <link href="https://lightninguz2.github.io/2020/03/26/libreoj%2010051%20%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-2-3-%E4%BE%8B-3%E3%80%8DNikitosh-%E5%92%8C%E5%BC%82%E6%88%96/"/>
    <id>https://lightninguz2.github.io/2020/03/26/libreoj 10051 「一本通-2-3-例-3」Nikitosh-和异或/</id>
    <published>2020-03-26T12:28:22.000Z</published>
    <updated>2020-03-26T14:08:48.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>给一个长度为 $n$ 的序列 $a_1,a_2…a_n$，求两个区间 $[l_1,r_1],[l_2,r_2]$，使得两端区间不相交，且两端区间的异或和加起来最大。</p><p>$n\le 10^5$，每个 $a_i\le 10^9$。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设 $s_i$ 为前缀 $i$ 个的异或和。那么 $[l,r]$ 的异或和相当于 $s_r\oplus s_{l-1}$（$\oplus$ 表示异或）。</p><p>设 $pre[i]$ 表示在 $[1,i]$ 中区间的异或和的最大值。$suf[i]$ 表示 $[i,n]$ 中区间的异或和的最大值。那么答案就是 $max\{pre[i]+suf[i+1]\},1\le i\le n-1$。</p><p>然后 $pre$ 和 $suf$ 求法基本相同，如果会求 $pre$，只要反过来求一遍就能求出 $suf$ 了。</p><p>然后我们可以用 <code>01-TRIE</code> 求出必须以 $i$ 为右端点的最大区间异或和。然后求一个前缀最大值，就能得到 $pre$ 数组了。</p><h4 id="如何求（会的跳过）"><a href="#如何求（会的跳过）" class="headerlink" title="如何求（会的跳过）"></a>如何求（会的跳过）</h4><div><div class="fold_hider"><div class="close hider_title">点击</div></div><div class="fold"><p>假设我们当前有一些数。我们把它二进制拆分成 $32$ 位，然后从高到低插入 <code>TRIE</code> 树中。</p><p>现在我们要查询，这些数中哪个和 $x$ 异或起来最大。</p><p>我们把 $x$ 也拆开，对于当前这一位 $x[i]$（其值为 $0/1$），如果有一个儿子编号和 $x[i]$ 不同，尽量往不同的这里走，并且答案加上 $2^i$。否则就只能走相同的那一条边了，因为相同的异或起来为 $0$，所以这时对答案没有贡献。</p><p>我们把 $s[0,1,2\cdots i-1]$ 都插入到 <code>TRIE</code> 树中，然后查询必须选 $s[i]$ 的答案，就能得到以 $i$ 为右端点的最大区间异或和。然后求一遍前缀最大值，就能得到 $pre$ 数组。</p></div></div><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R1</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    x=(f==<span class="number">1</span>)?x:-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args,cnt);</span><br><span class="line">    F(i,<span class="number">1</span>,cnt) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);R1(*x);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>]; <span class="comment">//01-TRIE 树，儿子编号开 0/1 即可</span></span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;FK(ch); tot=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">D(i,<span class="number">30</span>,<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> id=((x&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!ch[cur][id]) ch[cur][id]=++tot;</span><br><span class="line">cur=ch[cur][id];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cur=<span class="number">0</span>;<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">D(i,<span class="number">30</span>,<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> id=((x&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ch[cur][id^<span class="number">1</span>]) cur=ch[cur][id^<span class="number">1</span>],ans|=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch[cur][id]) cur=ch[cur][id];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">R1(n); F(i,<span class="number">1</span>,n) R1(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> L[N],R[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T.Init();</span><br><span class="line">F(i,<span class="number">1</span>,n) </span><br><span class="line">&#123;</span><br><span class="line">L[i]=max(L[i<span class="number">-1</span>],T.Query(a[i])); <span class="comment">// 一边求答案，一边求了前缀最大值</span></span><br><span class="line">T.Insert(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T.Init(); <span class="comment">//注意每次都要把树清空一下</span></span><br><span class="line">D(i,n,<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">R[i]=max(R[i+<span class="number">1</span>],T.Query(a[i]));</span><br><span class="line">T.Insert(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">F(i,<span class="number">1</span>,n) ans=max(ans,<span class="number">1l</span>l*L[i]+<span class="number">1l</span>l*R[i+<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line"><span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Input();</span><br><span class="line">Soviet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Flandre_Scarlet::IsMyWife();</span><br><span class="line">getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="思维" scheme="https://lightninguz2.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="TRIE" scheme="https://lightninguz2.github.io/tags/TRIE/"/>
    
  </entry>
  
  <entry>
    <title>主席树 笔记</title>
    <link href="https://lightninguz2.github.io/2020/03/23/%E4%B8%BB%E5%B8%AD%E6%A0%91-%E7%AC%94%E8%AE%B0/"/>
    <id>https://lightninguz2.github.io/2020/03/23/主席树-笔记/</id>
    <published>2020-03-22T20:30:06.000Z</published>
    <updated>2020-04-18T15:25:57.462Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于现在的我来说，只要有“可持久化”这个标签，一定伴随着 “毒瘤“，毕竟我刚学会…</p><p>好的首先介绍一下主席树是啥。主席树是“可持久化线段树”（<code>Persistant Segment Tree</code>）的中文民间俗称。不知道是因为有人把 <code>Persistant</code> 看成了 <code>Presidant</code>，还是因为它的发明者是 <code>HJT</code>（和某一任国家主席简称相同），被叫做“主席树”。</p><p>但是，可持久化是啥呢？</p><h3 id="可持久化是啥"><a href="#可持久化是啥" class="headerlink" title="可持久化是啥"></a>可持久化是啥</h3><p>可持久化是亿点小优化，当你要开 $n$ 个线段树，但是线段树之间只差一次修改的时候，把空间复杂度降到 $O(n\log n)$。</p><p>如何优化呢？考虑我们现在要对一个<strong>单点</strong>进行修改，那么我们能影响到的位置（就是这个点以及它的祖先），一共才 $\log n$ ，个而其它位置都一样，所以我们可以 <strong>只新建 $\log n$  个位置</strong>，整一个副本出来，其余位置直接继承原树即可。</p><p>蒯一张图举个例子，$n=5$，修改了第四个点：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/20234.png" alt></p><p>（<a href="https://www.luogu.com.cn/user/50871" target="_blank" rel="noopener">原作者</a>）</p><p>（<a href="https://www.luogu.com.cn/blog/LonecharmRiver/zhu-xi-shu" target="_blank" rel="noopener">原博客</a>）</p><p>（侵权删）（私信 3348064478@qq.com，本站评论有锅）</p><p>这样就能节省下超级多的空间！</p><p>但是，有利总有弊。这样的结构破坏的原来线段树的编号的完美特性，不能再用 <code>index&lt;&lt;1</code> 和 <code>index&lt;&lt;1|1</code> 来访问左右儿子了。我们要在线段树中多维护两个元素，左儿子和右儿子的编号。</p><h3 id="经典题型"><a href="#经典题型" class="headerlink" title="经典题型"></a>经典题型</h3><p>静态/动态区间第 $k$ 位：给定一个序列，每次给出 $l,r,k$，求 $[l,r]$ 中的数排序后，第 $k$ 个位置的数是谁。（当然，我们不会实际去排序，所以询问操作对原序列没有影响）</p><p>如果是动态的，那你还要支持单点修改的操作，会给定 $x,y$，要支持把第 $x$ 个位置上的数改成 $y$。</p><p>（假设我们离散化过了所有 $a_i$，和所有询问修改后变成的 $y$）</p><h4 id="静态的问题"><a href="#静态的问题" class="headerlink" title="静态的问题"></a>静态的问题</h4><p>板子见 <a href="https://www.luogu.com.cn/problem/P3834" target="_blank" rel="noopener">洛谷 3834</a></p><p>对于一个查询 $(l,r,k)$ ，（假设我们能）把 $a[l\cdots r]$ 拿出来建一颗权值线段树 $T$，查询就很容易了：把区间分成左半部分和右半部分，设左半部分中数字的个数为  $lsum$。如果 $k\le lsum$，那么就在左半部分中查找，否则就在右半部分中查找第 $k-lsum$ 个。</p><p>但是我们怎么把 $a[l\cdots r]$ 拿出来建一颗权值线段树呢？这个时空复杂度都是 $O(nlogn)$ 每次，再乘一个询问次数，肯定炸。</p><p>但是我们发现，线段树满足一种微妙的“可减性”：我们考虑建 $n$ 颗线段树 $T$，$T_i$ 表示 $a[1\cdots i]$ 组成的权值线段树。然后 $a[l\cdots r]$ 组成的权值线段树的对应位置就是 $T_r$ 的对应位置减去 $T_{l-1}$的对应位置。但是把 $T$ 建出来，光空间就够炸的了，是 $O(n^2)$ 的</p><p>考虑用上面“可持久化”的办法来优化求 $T$ 的过程：$T_i$ 和 $T_{i-1}$之间，差的只是在（离散化后的） $a_i$ 位置上加一。那么我们就让 $T_i$ 在 $T_{i-1}$ 的基础上，复制其中的 $\log$ 条链即可。这样就可以空间复杂度 $O(n\log n)$ ，时间复杂度 $O(n\log^2 n)$ 的过去了。</p><h5 id="一个伏笔"><a href="#一个伏笔" class="headerlink" title="一个伏笔"></a>一个伏笔</h5><p>请把它理解成“前缀和套线段树”。</p><p><del>那么恭喜您，现在您已经会了一个嵌套型的数据结构了</del></p><p>关于为什么要把它理解成这样…看到后面就知道啦，现在保密哦，不能告诉你(ฅ&gt;ω&lt;*ฅ) </p><h5 id="静态问题-板子-的代码"><a href="#静态问题-板子-的代码" class="headerlink" title="静态问题(板子)的代码"></a>静态问题(板子)的代码</h5><div><div class="fold_hider"><div class="close hider_title">点击</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> N 200005</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">I</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">        <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">        <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        va_list args; va_start(args,cnt);</span><br><span class="line">        F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=I();&#125;</span><br><span class="line">        va_end(args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Persistant_Tree</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> lid,rid; <span class="keyword">int</span> l,r; <span class="keyword">int</span> s;&#125; t[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 注意空间往死里开</span></span><br><span class="line">        <span class="comment">// lid,rid 存储左右儿子编号</span></span><br><span class="line">        <span class="keyword">int</span> rt[N],tot=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// rt[i] 存第 i 颗线段树的根的编号</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> ls(x) t[x].lid</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> rs(x) t[x].rid</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> L  t[rt].l</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> R  t[rt].r</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> S  t[rt].s</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> up(x) t[x].s=t[t[x].lid].s+t[t[x].rid].s</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;tot=<span class="number">0</span>;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> <span class="comment">// 建树，这一步和普通的线段树差别不大</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rt=++tot;</span><br><span class="line">            L=l,R=r,S=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                ls(rt)=Build(l,mid); </span><br><span class="line">                rs(rt)=Build(mid+<span class="number">1</span>,r); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> rt)</span> </span></span><br><span class="line"><span class="function">        <span class="comment">// 在 rt 这个根的基础上，修改了 pos 位置</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 把一路上修改的线段树上的链存一个副本，并返回这个链的顶端</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rr=++tot;</span><br><span class="line">            t[rr].l=L; t[rr].r=R; t[rr].s=S+<span class="number">1</span>;</span><br><span class="line">            ls(rr)=ls(rt); rs(rr)=rs(rt); <span class="comment">// 默认直接继承</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (L&lt;R)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (pos&lt;=mid) ls(rr)=Insert(pos,ls(rt)); <span class="comment">// 如果要修改左儿子，那么就左儿子开一个副本</span></span><br><span class="line">                <span class="keyword">else</span>          rs(rr)=Insert(pos,rs(rt)); <span class="comment">// 右儿子同理</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">QueryKth</span><span class="params">(<span class="keyword">int</span> r1,<span class="keyword">int</span> r2,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span> <span class="comment">// 在 T[r2]-T[r1] 这颗权值线段树中，查询排名为 k 的位置</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l==r) <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> lsum=t[ls(r2)].s-t[ls(r1)].s; <span class="comment">// 左边有多少数</span></span><br><span class="line">            <span class="keyword">if</span> (k&lt;=lsum) <span class="keyword">return</span> QueryKth(ls(r1),ls(r2),l,mid,k); <span class="comment">// k&lt;=lsum，在左边找</span></span><br><span class="line">            <span class="keyword">else</span>         <span class="keyword">return</span> QueryKth(rs(r1),rs(r2),mid+<span class="number">1</span>,r,k-lsum); <span class="comment">// 否则在右边找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n,q,a[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Rd(<span class="number">2</span>,&amp;n,&amp;q);</span><br><span class="line">        F(i,<span class="number">1</span>,n) a[i]=I();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        F(i,<span class="number">1</span>,n) d[i]=a[i];</span><br><span class="line">        sort(d+<span class="number">1</span>,d+n+<span class="number">1</span>);</span><br><span class="line">        F(i,<span class="number">1</span>,n) a[i]=lower_bound(d+<span class="number">1</span>,d+n+<span class="number">1</span>,a[i])-d;</span><br><span class="line"></span><br><span class="line">        T.Init();</span><br><span class="line">        T.rt[<span class="number">0</span>]=T.Build(<span class="number">1</span>,n);</span><br><span class="line">        F(i,<span class="number">1</span>,n)</span><br><span class="line">        &#123;</span><br><span class="line">            T.rt[i]=T.Insert(a[i],T.rt[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="comment">// 第 i 颗线段树的根，就是在第 i-1 颗线段树的基础上，在 a[i] 的位置上加了一</span></span><br><span class="line">        &#125;</span><br><span class="line">        F(i,<span class="number">1</span>,q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l=I(),r=I(),k=I();</span><br><span class="line">            <span class="keyword">int</span> pos=T.QueryKth(T.rt[l<span class="number">-1</span>],T.rt[r],<span class="number">1</span>,n,k);</span><br><span class="line">            <span class="comment">// 查询第 r 颗树减去第 l-1 颗树的第 k 位，就相当于 a[l...r] 中的第 k 位</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line">    <span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Input();</span><br><span class="line">        Soviet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Flandre_Scarlet::IsMyWife();</span><br><span class="line">    getchar();getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="动态的问题"><a href="#动态的问题" class="headerlink" title="动态的问题"></a>动态的问题</h4><p>板子见 <a href="https://www.luogu.com.cn/problem/P2617" target="_blank" rel="noopener">洛谷 2617</a></p><p>做好准备，这比静态的问题要困难的多。我当时调试了 $10$ 个小时才过去。</p><h4 id="前置芝士：-树状数组"><a href="#前置芝士：-树状数组" class="headerlink" title="前置芝士： 树状数组"></a>前置芝士： 树状数组</h4><div><div class="fold_hider"><div class="close hider_title">点击</div></div><div class="fold"><blockquote><p> （你不会这个还来学主席树？）</p><p>（算了，还是先复习一下）</p></blockquote><p>首先回顾一下树状数组的概念：</p><p>对于第 $i$ 个位置，我们维护从 $i$ 开始往前 $\operatorname{lowbit}(i)$ 个数的和。然后每次修改只需要改 $\log$ 个位置，</p><p>查询也只要求 $\log$ 个位置的和。</p></div></div><p>为了方便说明，下面设 $nex(i)=i+\operatorname{lowbit}(i)$，$pre(i)=i-\operatorname{lowbit}(i)$</p><p>（才不是因为我懒得打 $\operatorname{lowbit}$ 呢！哼╭(╯^╰)╮）</p><h4 id="故-技-重-施"><a href="#故-技-重-施" class="headerlink" title="故 技 重 施"></a>故 技 重 施</h4><p>动态的问题就是我们要支持对其中一个位置进行修改了。修改 了第 $i$ 个位置后，$[i,n]$ 范围内的所有线段树都要被修改一次，时间复杂度就爆炸了。</p><p>等等，这个问题我们是不是见过一次？</p><p>把时间倒回大约一两年前，我们遇到过这样一个问题：“单点修改，求区间和”</p><p>我们当时是用的树状数组解决的问题：树状数组 $T$，第 $i$ 个位置 $T_i$ 维护 $pre(i)+1$ 到 $i$ 的和。要查询 $i$ 的前缀和，只要求 $T_i,T_{pre(i)},T_{pre(pre(i))}\cdots $ 的和即可。</p><p>那么我们可以用树状数组的思路维护主席树啊！</p><h4 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h4><p>那么我们怎么写呢？我们写一个“树状数组套线段树”：维护 $n$ 个线段树 $T$，其中 $T_i$ 维护 $[pre(i)+1,i]$ 之间的所有 $a_{x}$ 组成的权值线段树即可。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>对于初始化操作，我们建树。先开 $n$ 颗线段树，但是初始的时候 $n$ 颗线段树 <strong>全部</strong> 和初始的线段树共用 （也就是对于每个 $i$，$root[i]=root[0]$）</p><p>然后对于第 $i$ 个位置，它只能影响到 $i,nex(i),nex(nex(i))\cdots $ 位置上的线段树。对于这些位置上的每一个线段树 $T_i$，我们在它 <strong>自己</strong> 的基础上，插入 $a[i]$ 位置（并加一）。</p><h5 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h5><p>对于修改第 $x$ 个位置从原来的 $a[x]$ 变成 $y$ （修改完令 $a[x]=y$），我们要找到所有包含它的线段树，$T$，在第 $a[x]$ 个位置 $-1$，在 $y$ 的位置 $+1$，这样就完成了修改操作。</p><h5 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h5><p>静态的问题中，查询 $[l,r]$ 的第 $k$ 大，用 $T_r$ 来减掉 $T_{l-1}$，然后判断答案在左边还是在右边。传参数只要传入 $T_{l-1}$ 和 $T_r$ 的根节点编号即可。</p><p>然而我们现在是树状数组套线段树，两者相减，可不是两颗线段树相减了，而是</p><p>第 $r,pre(r),pre(pre(r))\cdots$ 颗线段树的和，减去</p><p>第 $l-1,pre(l-1),pre(pre(l-1)) \cdots$ 颗线段树的和。</p><p>然后我们显然没法一次性传这么多参数进去（而且还是不定长度，更麻烦了）。我们的办法是，在查询之前，先把所有的 $l-1,pre(l-1),pre(pre(l-1)) \cdots$ 保存在一个数组 $R_1$ 里，再把所有的 $r,pre(r),pre(pre(r)) \cdots$ 保存在一个数组 $R_2$ 里（并记下这两个数组的长度）（从 $1$ 开始编号的同学可以考虑用第 $0$ 个位置作为长度，我就是这么写的）</p><p>每次查询前缀 $r$ 颗树减去前缀 $l-1$ 颗树的时候，就遍历 $R_1,R_2$，把第 $R_{2i}$ 颗树的对应位置都加起来，把第 $R_{1i}$ 颗树的对应位置都减掉，得到 $lsum$。然后用静态里面的做法即可。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><div><div class="fold_hider"><div class="close hider_title">点击</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">I</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args; va_start(args,cnt);</span><br><span class="line">    F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=I();&#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Persistant_tree</span> // 被卡常了的主席树...</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> lid,rid,s;&#125; t[N*<span class="number">400</span>];</span><br><span class="line"><span class="comment">// 去掉了存储左右区间的成员变量，左右区间在函数调用过程中记录</span></span><br><span class="line"><span class="comment">// 从而把空间优化成原来的 3/5，然后数组开大点</span></span><br><span class="line"><span class="keyword">int</span> rt[N],tot;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) t[x].lid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) t[x].rid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S     t[rt].s</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;tot=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rt=++tot; S=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ls(rt)=Build(l,mid);</span><br><span class="line">rs(rt)=Build(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rt;</span><br><span class="line">&#125; <span class="comment">// 这个一样的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> type,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 修改操作可能会有 -1，于是加上一个 type，type=1或-1表示加还是减</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rr=++tot;</span><br><span class="line">ls(rr)=ls(rt); rs(rr)=rs(rt); t[rr].s=S+type;</span><br><span class="line"><span class="keyword">if</span> (l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;=mid) ls(rr)=Insert(l,mid,pos,type,ls(rt));</span><br><span class="line"><span class="keyword">else</span>   rs(rr)=Insert(mid+<span class="number">1</span>,r,pos,type,rs(rt));</span><br><span class="line"><span class="comment">// 这些一样的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> R2[<span class="number">30</span>],R1[<span class="number">30</span>];</span><br><span class="line"><span class="comment">// R2,R1 含义见上面</span></span><br><span class="line"><span class="comment">// 数组第 0 个位置保存数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryKth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r) <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lsum=<span class="number">0</span>;</span><br><span class="line">F(i,<span class="number">1</span>,R2[<span class="number">0</span>]) lsum+=t[ls(R2[i])].s;</span><br><span class="line">F(i,<span class="number">1</span>,R1[<span class="number">0</span>]) lsum-=t[ls(R1[i])].s;</span><br><span class="line"><span class="comment">// 这个就是要遍历累加来求出 lsum 的值了</span></span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (k&lt;=lsum) </span><br><span class="line">&#123;</span><br><span class="line">F(i,<span class="number">1</span>,R2[<span class="number">0</span>]) R2[i]=ls(R2[i]);</span><br><span class="line">F(i,<span class="number">1</span>,R1[<span class="number">0</span>]) R1[i]=ls(R1[i]);</span><br><span class="line"><span class="comment">// 跳左右儿子也要一块跳...这个复杂度活生生的多一个 log 啊</span></span><br><span class="line"><span class="keyword">return</span> QueryKth(l,mid,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">F(i,<span class="number">1</span>,R2[<span class="number">0</span>]) R2[i]=rs(R2[i]);</span><br><span class="line">F(i,<span class="number">1</span>,R1[<span class="number">0</span>]) R1[i]=rs(R1[i]);</span><br><span class="line"><span class="keyword">return</span> QueryKth(mid+<span class="number">1</span>,r,k-lsum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">char</span> type; <span class="keyword">int</span> a,b,c;&#125; q[N];</span><br><span class="line"><span class="comment">// 如果是 C 操作，那么我们只用 a,b，表示将 a 位置变成了 b</span></span><br><span class="line"><span class="comment">// 如果是 Q 操作，那么我们 a,b,c 都用，表示 [a,b] 区间排名第 c 位的数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Rd(<span class="number">2</span>,&amp;n,&amp;m);</span><br><span class="line">F(i,<span class="number">1</span>,n) a[i]=I();</span><br><span class="line">F(i,<span class="number">1</span>,m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> o[<span class="number">3</span>]; <span class="built_in">scanf</span>(<span class="string">"%s"</span>,o);</span><br><span class="line"><span class="keyword">if</span> (o[<span class="number">0</span>]==<span class="string">'Q'</span>) </span><br><span class="line">&#123;</span><br><span class="line">q[i]=(node)&#123;o[<span class="number">0</span>],I(),I(),I()&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">q[i]=(node)&#123;o[<span class="number">0</span>],I(),I()&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[N&lt;&lt;<span class="number">2</span>],dcnt=<span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Find(x) (lower_bound(d+1,d+dcnt+1,x)-d)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=Find(a[pos]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;=n;i+=(i&amp;(-i))) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> lastr=T.rt[i]; <span class="comment">// 保存原来的根</span></span><br><span class="line">T.rt[i]=T.Insert(<span class="number">1</span>,dcnt,x,type,lastr); <span class="comment">// 以便在原来的基础上插入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">F(i,<span class="number">0</span>,<span class="number">22</span>) T.R1[i]=T.R2[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&gt;<span class="number">0</span>;i-=(i&amp;(-i))) T.R2[++T.R2[<span class="number">0</span>]]=T.rt[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&gt;<span class="number">0</span>;i-=(i&amp;(-i))) T.R1[++T.R1[<span class="number">0</span>]]=T.rt[i];</span><br><span class="line"><span class="comment">// 先预先求好 R1,R2</span></span><br><span class="line"><span class="keyword">return</span> T.QueryKth(<span class="number">1</span>,dcnt,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">F(i,<span class="number">1</span>,n) d[++dcnt]=a[i];</span><br><span class="line">F(i,<span class="number">1</span>,m) <span class="keyword">if</span> (q[i].type==<span class="string">'C'</span>) d[++dcnt]=q[i].b;</span><br><span class="line">sort(d+<span class="number">1</span>,d+dcnt+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">T.Init();</span><br><span class="line">T.rt[<span class="number">0</span>]=T.Build(<span class="number">1</span>,dcnt); F(i,<span class="number">1</span>,n) T.rt[i]=<span class="number">1</span>;</span><br><span class="line">F(i,<span class="number">1</span>,n) Insert(i,<span class="number">1</span>);</span><br><span class="line">F(i,<span class="number">1</span>,m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q[i].type==<span class="string">'Q'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> pos=Query(q[i].a<span class="number">-1</span>,q[i].b,q[i].c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d[pos]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q[i].type==<span class="string">'C'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q[i].a,y=q[i].b;</span><br><span class="line">Insert(x,<span class="number">-1</span>); a[x]=y;</span><br><span class="line">Insert(x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line"><span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Input();</span><br><span class="line">Soviet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Flandre_Scarlet::IsMyWife();</span><br><span class="line">getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://lightninguz2.github.io/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="线段树" scheme="https://lightninguz2.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="可持久化" scheme="https://lightninguz2.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>libreoj 10067 「一本通 3.1 练习 2」构造完全图 题解</title>
    <link href="https://lightninguz2.github.io/2020/03/21/libreoj-10067-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-1-%E7%BB%83%E4%B9%A0-2%E3%80%8D%E6%9E%84%E9%80%A0%E5%AE%8C%E5%85%A8%E5%9B%BE-%E9%A2%98%E8%A7%A3/"/>
    <id>https://lightninguz2.github.io/2020/03/21/libreoj-10067-「一本通-3-1-练习-2」构造完全图-题解/</id>
    <published>2020-03-21T14:49:46.000Z</published>
    <updated>2020-03-21T15:06:06.530Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>给定一个树 $T$ ，求一个完全图 $G$ 使得 $T$ 是 $G$ 的最小生成树，并且 $G$ 的边权和最小。求出这个最小的边权和。$T$ 的点数 $n\le 10^5$，每个边权 $w\le 10^5​$</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们把 $T​$ 中的边权排一下序，反向推一下 <code>Kruskal</code> 算法的步骤。</p><p>我们每次考虑到第 $i​$ 条边 $(u,v,w)​$，假设这之前的 $i-1​$ 条边已经构造好了若干个都是完全图的联通块，并且 $T​$ 中的前 $i-1​$ 条边就是这些联通块的生成树（也就是保证了 <code>Kruskal</code> 算法前 $i-1​$ 步都选的是 $T​$ 中的边）。</p><p>在连上 $(u,v,w)$ 之前，$(u,v)$ 应该分在两个联通块里。我们把 $(u,v,w)$ 连起来之后，对于两个联通块里除了 $(u,v)$ 以外的所有点对，都连一条权为 $w+1$ 的边。这样，显然在 <code>Kruskal</code> 算法的第 $i$  步中，选的是第 $i$ 条边（因为现在只剩下两个联通块连接，除了 $(u,v,w)$ 之外所有的边权都 $\ge w$，肯定得选 $(u,v,w)$）</p><p>所以我们把 $T$ 中的边按边权排序，并查集合并的时候记录一下联通块大小。然后 $(u,v,w)$ 这条边的贡献就是 $(cnt[u]\times cnt[v]-1)\times (w+1)​$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div><div class="fold_hider"><div class="close hider_title">点击</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 155555</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">I</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args; va_start(args,cnt);</span><br><span class="line">    F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=I();&#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> Fa[N],Cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;F(i,<span class="number">0</span>,N<span class="number">-1</span>) Fa[i]=i,Cnt[i]=<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Find</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="keyword">return</span> u==Fa[u]?u:Fa[u]=Find(Fa[u]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> au=Find(u),av=Find(v); <span class="keyword">if</span> (au==av) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (Cnt[au]&lt;Cnt[av]) Cnt[av]+=Cnt[au],Fa[au]=av;</span><br><span class="line"><span class="keyword">else</span>  Cnt[au]+=Cnt[av],Fa[av]=au;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;D;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> u,v,w;&#125;e[N]; <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node a,node b)&#123;<span class="keyword">return</span> a.w&lt;b.w;&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=I();</span><br><span class="line">F(i,<span class="number">1</span>,n<span class="number">-1</span>) e[i]=(node)&#123;I(),I(),I()&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>; F(i,<span class="number">1</span>,n<span class="number">-1</span>) ans+=e[i].w; <span class="comment">// 初始答案为所有边的边权和，这个显然</span></span><br><span class="line">sort(e+<span class="number">1</span>,e+n);</span><br><span class="line">D.Init();</span><br><span class="line">F(i,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=e[i].u,v=e[i].v; <span class="keyword">int</span> au=D.Find(u),av=D.Find(v);</span><br><span class="line">ans+=(D.Cnt[au]*D.Cnt[av]<span class="number">-1</span>)*(e[i].w+<span class="number">1</span>);</span><br><span class="line">D.Merge(u,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line"><span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Input();</span><br><span class="line">Soviet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int <span class="comment">//long long</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Flandre_Scarlet::IsMyWife();</span><br><span class="line">getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="思维" scheme="https://lightninguz2.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="生成树" scheme="https://lightninguz2.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 3831 [SHOI2012]回家的路 题解</title>
    <link href="https://lightninguz2.github.io/2020/03/21/%E6%B4%9B%E8%B0%B7-3831-%5BSHOI2012%5D%E5%9B%9E%E5%AE%B6%E7%9A%84%E8%B7%AF-%E9%A2%98%E8%A7%A3/"/>
    <id>https://lightninguz2.github.io/2020/03/21/洛谷-3831-[SHOI2012]回家的路-题解/</id>
    <published>2020-03-21T03:08:00.000Z</published>
    <updated>2020-03-21T15:43:48.341Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>$n$ 行 $n$ 列的矩阵上，只有 $m$ 个“关键点”处（在第 $x$ 行 $y$ 列）才能拐弯。从格子到上下左右四个相邻格子花费 $2$，转弯花费 $1$。 求从某个位置走到另一个位置的最小花费。无解输出 $-1​$。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>新建两个点 $S$ 和 $T$ 表示起点。 然后把所有点 $A$（包括关键点和 $S,T$） 拆成两个点 $A_1$ 和 $A_2$，分别表示横向跑和纵向跑。</p><p>对于所有关键点 $K$ （不包括 $S,T$），$K_1$ 到 $K_2$ 连一条边权为 $1$ 的无向边，表示换乘。</p><p>然后对于所有同一行 （$x$ 相同）的点，按照列号 $y$ 排序。对于相邻的 $A,B$，连边 $(A_1,B_1,2\times dis)$，其中 $dis$ 为 $A,B$ 两点 $y$ 值的距离。为啥乘二，是因为相邻格子要花费 $2$。 同一列同理（同一列连的是 $A_2$ 和 $B_2$）。</p><p>然后我们从 $S_1$ 跑到 $T_1,T_2$，从 $S_2$ 跑到 $T_1,T_2$ ，四种方案，看哪个最小。如果都不能到达…那就输出 $-1$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div><div class="fold_hider"><div class="close hider_title">点击</div></div><div class="fold"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Flandre_Scarlet</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 255555</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(i,r,l) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fs(i,l,r,c) for(int i=l;i&lt;=r;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ds(i,r,l,c) for(int i=r;i&gt;=l;c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(x,a) memset(x,a,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FK(x) MEM(x,0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) ((int)a.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter(a,p) (a.begin()+p)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">I</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();<span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span> <span class="keyword">or</span> c&gt;<span class="string">'9'</span>) f=(c==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> <span class="keyword">and</span> c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    <span class="keyword">return</span> (x=(f==<span class="number">1</span>)?x:-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rd</span><span class="params">(<span class="keyword">int</span> cnt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args; va_start(args,cnt);</span><br><span class="line">    F(i,<span class="number">1</span>,cnt) &#123;<span class="keyword">int</span>* x=va_arg(args,<span class="keyword">int</span>*);(*x)=I();&#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> head[N];</span><br><span class="line">        <span class="keyword">int</span> EdgeCount;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">int</span> To,Label,Next;</span><br><span class="line">        &#125;Ed[<span class="number">1666666</span>];</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> _V=N,<span class="keyword">int</span> _E=N&lt;&lt;<span class="number">1</span>)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(Ed,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Edge)*(_E));</span><br><span class="line">            <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(_V));</span><br><span class="line">            EdgeCount=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Ed[++EdgeCount]=(Edge)&#123;v,w,head[u]&#125;;</span><br><span class="line">            head[u]=EdgeCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Add2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w=<span class="number">1</span>)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        <span class="comment">// printf("Add %d %d\n",u,v);</span></span><br><span class="line">        AddEdge(u,v,w);AddEdge(v,u,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Start</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">return</span> head[u];&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">To</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="keyword">return</span> Ed[u].To;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Label</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="keyword">return</span> Ed[u].Label;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Next</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="keyword">return</span> Ed[u].Next;&#125;</span><br><span class="line">&#125;G;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> x,y,id;&#125;a[N]; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_x</span><span class="params">(node a,node b)</span> </span>&#123;<span class="keyword">return</span> a.x&lt;b.x <span class="keyword">or</span> (a.x==b.x <span class="keyword">and</span> a.y&lt;b.y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_y</span><span class="params">(node a,node b)</span> </span>&#123;<span class="keyword">return</span> a.y&lt;b.y <span class="keyword">or</span> (a.y==b.y <span class="keyword">and</span> a.x&lt;b.x);&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lin(x) x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> col(x) (x)+m+2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Rd(<span class="number">2</span>,&amp;n,&amp;m); F(i,<span class="number">1</span>,m) a[i]=(node)&#123;I(),I(),i&#125;;</span><br><span class="line">a[m+<span class="number">1</span>]=(node)&#123;I(),I(),m+<span class="number">1</span>&#125;;</span><br><span class="line">a[m+<span class="number">2</span>]=(node)&#123;I(),I(),m+<span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">G.clear();</span><br><span class="line">sort(a+<span class="number">1</span>,a+m+<span class="number">3</span>,cmp_x);</span><br><span class="line">F(i,<span class="number">2</span>,m+<span class="number">2</span>) <span class="keyword">if</span> (a[i].x==a[i<span class="number">-1</span>].x) G.Add2(lin(a[i].id),lin(a[i<span class="number">-1</span>].id),<span class="number">2</span>*<span class="built_in">abs</span>(a[i].y-a[i<span class="number">-1</span>].y));</span><br><span class="line">sort(a+<span class="number">1</span>,a+m+<span class="number">3</span>,cmp_y);</span><br><span class="line">F(i,<span class="number">2</span>,m+<span class="number">2</span>) <span class="keyword">if</span> (a[i].y==a[i<span class="number">-1</span>].y) G.Add2(col(a[i].id),col(a[i<span class="number">-1</span>].id),<span class="number">2</span>*<span class="built_in">abs</span>(a[i].x-a[i<span class="number">-1</span>].x));</span><br><span class="line">F(i,<span class="number">1</span>,m+<span class="number">2</span>) <span class="keyword">if</span> (a[i].id&lt;=m) G.Add2(lin(a[i].id),col(a[i].id),<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">djnode</span>&#123;</span><span class="keyword">int</span> v,w;&#125;; <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(djnode a,djnode b)&#123;<span class="keyword">return</span> a.w&gt;b.w;&#125;</span><br><span class="line">priority_queue&lt;djnode&gt; Q; <span class="keyword">bool</span> vis[N];<span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MEM(dis,<span class="number">0x3f</span>); FK(vis); <span class="keyword">while</span>(!Q.empty()) Q.pop();</span><br><span class="line">Q.push((djnode)&#123;s,<span class="number">0</span>&#125;); dis[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!Q.empty())</span><br><span class="line">&#123;</span><br><span class="line">djnode Min=Q.top(); Q.pop();</span><br><span class="line"><span class="keyword">int</span> u=Min.v;</span><br><span class="line"><span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Tra(i,u) <span class="keyword">if</span> (!vis[v] <span class="keyword">and</span> dis[v]&gt;dis[u]+G.Label(i)) </span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[u]+G.Label(i);</span><br><span class="line">Q.push((djnode)&#123;v,dis[v]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// F(i,1,2*(m+2)) printf("%d ",dis[i]&gt;1e9?-1:dis[i]);</span></span><br><span class="line"><span class="comment">// putchar('\n'); </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Soviet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Build();</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">Dijkstra(lin(m+<span class="number">1</span>)); ans=min(ans,min(dis[lin(m+<span class="number">2</span>)],dis[col(m+<span class="number">2</span>)]));</span><br><span class="line">Dijkstra(col(m+<span class="number">1</span>)); ans=min(ans,min(dis[lin(m+<span class="number">2</span>)],dis[col(m+<span class="number">2</span>)]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans&gt;<span class="number">1e9</span>?<span class="number">-1</span>:ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Flan void</span></span><br><span class="line"><span class="function">Flan <span class="title">IsMyWife</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Input();</span><br><span class="line">Soviet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Flandre_Scarlet::IsMyWife();</span><br><span class="line">getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="思维" scheme="https://lightninguz2.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="建图" scheme="https://lightninguz2.github.io/tags/%E5%BB%BA%E5%9B%BE/"/>
    
  </entry>
  
</feed>
